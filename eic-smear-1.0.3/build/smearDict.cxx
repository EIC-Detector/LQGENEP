//
// File generated by /afs/rhic.bnl.gov/sphenix/sys/x8664_sl6/new.3/root/bin/rootcint at Tue Sep 26 14:31:34 2017

// Do NOT change. Changes will be lost next time file is generated
//

#define R__DICTIONARY_FILENAME dIphenixdIudIspjeffasdILQGENEPdIeicmIsmearmI1dO0dO3dIbuilddIsmearDict
#include "RConfig.h" //rootcint 4834
#if !defined(R__ACCESS_IN_SYMBOL)
//Break the privacy of classes -- Disabled for the moment
#define private public
#define protected public
#endif

// Since CINT ignores the std namespace, we need to do so in this file.
namespace std {} using namespace std;
#include "smearDict.h"

#include "TCollectionProxyInfo.h"
#include "TClass.h"
#include "TBuffer.h"
#include "TMemberInspector.h"
#include "TInterpreter.h"
#include "TVirtualMutex.h"
#include "TError.h"

#ifndef G__ROOT
#define G__ROOT
#endif

#include "RtypesImp.h"
#include "TIsAProxy.h"
#include "TFileMergeInfo.h"

// Direct notice to TROOT of the dictionary's loading.
namespace {
   static struct DictInit {
      DictInit() {
         ROOT::RegisterModule();
      }
   } __TheDictionaryInitializer;
}

// START OF SHADOWS

namespace ROOTShadow {
   namespace Shadow {
      namespace Smear {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::Smear::Acceptance Acceptance;
      #else
      class Acceptance  {
         public:
         //friend XX;
         #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
         typedef ::Smear::Acceptance::CustomCut CustomCut;
         #else
         class CustomCut  {
            public:
            //friend XX;
            // To force the creation of a virtual table, throw just in case.
            virtual ~CustomCut() throw() {};
            ::TFormula mFormula; //
            int dim; //
            ::Smear::KinType Kin1; //
            ::Smear::KinType Kin2; //
            double Min; //
            double Max; //
         };
         #endif

         // To force the creation of a virtual table, throw just in case.
         virtual ~Acceptance() throw() {};
      };
      #endif
      } 
      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::auto_ptr< ::erhic::ParticleMC > auto_ptrlEerhiccLcLParticleMCgR;
      #else
      class auto_ptrlEerhiccLcLParticleMCgR  {
         public:
         //friend XX;
         typedef ::erhic::ParticleMC element_type;
         ::erhic::ParticleMC* ptr; //
      };
      #endif

   } // of namespace Shadow
} // of namespace ROOTShadow
// END OF SHADOWS

namespace Smear {
   namespace ROOTDict {
      inline ::ROOT::TGenericClassInfo *GenerateInitInstance();
      static void Smear_Dictionary();

      // Function generating the singleton type initializer
      inline ::ROOT::TGenericClassInfo *GenerateInitInstance()
      {
         static ::ROOT::TGenericClassInfo 
            instance("Smear", 0 /*version*/, "/phenix/u/spjeffas/LQGENEP/eic-smear-1.0.3/include/eicsmear/smear/RadialTracker.h", 24,
                     ::ROOT::DefineBehavior((void*)0,(void*)0),
                     &Smear_Dictionary, 0);
         return &instance;
      }
      // Insure that the inline function is _not_ optimized away by the compiler
      ::ROOT::TGenericClassInfo *(*_R__UNIQUE_(InitFunctionKeeper))() = &GenerateInitInstance;  
      // Static variable to force the class initialization
      static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstance(); R__UseDummy(_R__UNIQUE_(Init));

      // Dictionary for non-ClassDef classes
      static void Smear_Dictionary() {
         GenerateInitInstance()->GetClass();
      }

   }
}

namespace ROOTDict {
   void SmearcLcLEvent_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void *new_SmearcLcLEvent(void *p = 0);
   static void *newArray_SmearcLcLEvent(Long_t size, void *p);
   static void delete_SmearcLcLEvent(void *p);
   static void deleteArray_SmearcLcLEvent(void *p);
   static void destruct_SmearcLcLEvent(void *p);
   static void streamer_SmearcLcLEvent(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::Smear::Event*)
   {
      ::Smear::Event *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::Smear::Event >(0);
      static ::ROOT::TGenericClassInfo 
         instance("Smear::Event", ::Smear::Event::Class_Version(), "/phenix/u/spjeffas/LQGENEP/eic-smear-1.0.3/include/eicsmear/smear/EventSmear.h", 29,
                  typeid(::Smear::Event), ::ROOT::DefineBehavior(ptr, ptr),
                  &::Smear::Event::Dictionary, isa_proxy, 0,
                  sizeof(::Smear::Event) );
      instance.SetNew(&new_SmearcLcLEvent);
      instance.SetNewArray(&newArray_SmearcLcLEvent);
      instance.SetDelete(&delete_SmearcLcLEvent);
      instance.SetDeleteArray(&deleteArray_SmearcLcLEvent);
      instance.SetDestructor(&destruct_SmearcLcLEvent);
      instance.SetStreamerFunc(&streamer_SmearcLcLEvent);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::Smear::Event*)
   {
      return GenerateInitInstanceLocal((::Smear::Event*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Smear::Event*)0x0); R__UseDummy(_R__UNIQUE_(Init));
} // end of namespace ROOTDict

namespace ROOTDict {
   void SmearcLcLParticleMCS_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void *new_SmearcLcLParticleMCS(void *p = 0);
   static void *newArray_SmearcLcLParticleMCS(Long_t size, void *p);
   static void delete_SmearcLcLParticleMCS(void *p);
   static void deleteArray_SmearcLcLParticleMCS(void *p);
   static void destruct_SmearcLcLParticleMCS(void *p);
   static void streamer_SmearcLcLParticleMCS(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::Smear::ParticleMCS*)
   {
      ::Smear::ParticleMCS *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::Smear::ParticleMCS >(0);
      static ::ROOT::TGenericClassInfo 
         instance("Smear::ParticleMCS", ::Smear::ParticleMCS::Class_Version(), "/phenix/u/spjeffas/LQGENEP/eic-smear-1.0.3/include/eicsmear/smear/ParticleMCS.h", 27,
                  typeid(::Smear::ParticleMCS), ::ROOT::DefineBehavior(ptr, ptr),
                  &::Smear::ParticleMCS::Dictionary, isa_proxy, 0,
                  sizeof(::Smear::ParticleMCS) );
      instance.SetNew(&new_SmearcLcLParticleMCS);
      instance.SetNewArray(&newArray_SmearcLcLParticleMCS);
      instance.SetDelete(&delete_SmearcLcLParticleMCS);
      instance.SetDeleteArray(&deleteArray_SmearcLcLParticleMCS);
      instance.SetDestructor(&destruct_SmearcLcLParticleMCS);
      instance.SetStreamerFunc(&streamer_SmearcLcLParticleMCS);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::Smear::ParticleMCS*)
   {
      return GenerateInitInstanceLocal((::Smear::ParticleMCS*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Smear::ParticleMCS*)0x0); R__UseDummy(_R__UNIQUE_(Init));
} // end of namespace ROOTDict

namespace ROOTDict {
   void SmearcLcLAcceptance_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void *new_SmearcLcLAcceptance(void *p = 0);
   static void *newArray_SmearcLcLAcceptance(Long_t size, void *p);
   static void delete_SmearcLcLAcceptance(void *p);
   static void deleteArray_SmearcLcLAcceptance(void *p);
   static void destruct_SmearcLcLAcceptance(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::Smear::Acceptance*)
   {
      ::Smear::Acceptance *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::Smear::Acceptance >(0);
      static ::ROOT::TGenericClassInfo 
         instance("Smear::Acceptance", ::Smear::Acceptance::Class_Version(), "/phenix/u/spjeffas/LQGENEP/eic-smear-1.0.3/include/eicsmear/smear/Acceptance.h", 36,
                  typeid(::Smear::Acceptance), ::ROOT::DefineBehavior(ptr, ptr),
                  &::Smear::Acceptance::Dictionary, isa_proxy, 4,
                  sizeof(::Smear::Acceptance) );
      instance.SetNew(&new_SmearcLcLAcceptance);
      instance.SetNewArray(&newArray_SmearcLcLAcceptance);
      instance.SetDelete(&delete_SmearcLcLAcceptance);
      instance.SetDeleteArray(&deleteArray_SmearcLcLAcceptance);
      instance.SetDestructor(&destruct_SmearcLcLAcceptance);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::Smear::Acceptance*)
   {
      return GenerateInitInstanceLocal((::Smear::Acceptance*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Smear::Acceptance*)0x0); R__UseDummy(_R__UNIQUE_(Init));
} // end of namespace ROOTDict

namespace ROOTDict {
   void SmearcLcLAcceptancecLcLCustomCut_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void SmearcLcLAcceptancecLcLCustomCut_Dictionary();
   static void *new_SmearcLcLAcceptancecLcLCustomCut(void *p = 0);
   static void *newArray_SmearcLcLAcceptancecLcLCustomCut(Long_t size, void *p);
   static void delete_SmearcLcLAcceptancecLcLCustomCut(void *p);
   static void deleteArray_SmearcLcLAcceptancecLcLCustomCut(void *p);
   static void destruct_SmearcLcLAcceptancecLcLCustomCut(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::Smear::Acceptance::CustomCut*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::Smear::Acceptance::CustomCut) == sizeof( ::ROOTShadow::Shadow::Smear::Acceptance::CustomCut));
      ::Smear::Acceptance::CustomCut *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Smear::Acceptance::CustomCut),0);
      static ::ROOT::TGenericClassInfo 
         instance("Smear::Acceptance::CustomCut", "/phenix/u/spjeffas/LQGENEP/eic-smear-1.0.3/include/eicsmear/smear/Acceptance.h", 44,
                  typeid(::Smear::Acceptance::CustomCut), ::ROOT::DefineBehavior(ptr, ptr),
                  &SmearcLcLAcceptancecLcLCustomCut_ShowMembers, &SmearcLcLAcceptancecLcLCustomCut_Dictionary, isa_proxy, 4,
                  sizeof(::Smear::Acceptance::CustomCut) );
      instance.SetNew(&new_SmearcLcLAcceptancecLcLCustomCut);
      instance.SetNewArray(&newArray_SmearcLcLAcceptancecLcLCustomCut);
      instance.SetDelete(&delete_SmearcLcLAcceptancecLcLCustomCut);
      instance.SetDeleteArray(&deleteArray_SmearcLcLAcceptancecLcLCustomCut);
      instance.SetDestructor(&destruct_SmearcLcLAcceptancecLcLCustomCut);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::Smear::Acceptance::CustomCut*)
   {
      return GenerateInitInstanceLocal((::Smear::Acceptance::CustomCut*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Smear::Acceptance::CustomCut*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void SmearcLcLAcceptancecLcLCustomCut_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::Smear::Acceptance::CustomCut*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void SmearcLcLAcceptancecLcLZone_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void *new_SmearcLcLAcceptancecLcLZone(void *p = 0);
   static void *newArray_SmearcLcLAcceptancecLcLZone(Long_t size, void *p);
   static void delete_SmearcLcLAcceptancecLcLZone(void *p);
   static void deleteArray_SmearcLcLAcceptancecLcLZone(void *p);
   static void destruct_SmearcLcLAcceptancecLcLZone(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::Smear::Acceptance::Zone*)
   {
      ::Smear::Acceptance::Zone *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::Smear::Acceptance::Zone >(0);
      static ::ROOT::TGenericClassInfo 
         instance("Smear::Acceptance::Zone", ::Smear::Acceptance::Zone::Class_Version(), "/phenix/u/spjeffas/LQGENEP/eic-smear-1.0.3/include/eicsmear/smear/Acceptance.h", 62,
                  typeid(::Smear::Acceptance::Zone), ::ROOT::DefineBehavior(ptr, ptr),
                  &::Smear::Acceptance::Zone::Dictionary, isa_proxy, 4,
                  sizeof(::Smear::Acceptance::Zone) );
      instance.SetNew(&new_SmearcLcLAcceptancecLcLZone);
      instance.SetNewArray(&newArray_SmearcLcLAcceptancecLcLZone);
      instance.SetDelete(&delete_SmearcLcLAcceptancecLcLZone);
      instance.SetDeleteArray(&deleteArray_SmearcLcLAcceptancecLcLZone);
      instance.SetDestructor(&destruct_SmearcLcLAcceptancecLcLZone);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::Smear::Acceptance::Zone*)
   {
      return GenerateInitInstanceLocal((::Smear::Acceptance::Zone*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Smear::Acceptance::Zone*)0x0); R__UseDummy(_R__UNIQUE_(Init));
} // end of namespace ROOTDict

namespace ROOTDict {
   void SmearcLcLDistributor_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void *new_SmearcLcLDistributor(void *p = 0);
   static void *newArray_SmearcLcLDistributor(Long_t size, void *p);
   static void delete_SmearcLcLDistributor(void *p);
   static void deleteArray_SmearcLcLDistributor(void *p);
   static void destruct_SmearcLcLDistributor(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::Smear::Distributor*)
   {
      ::Smear::Distributor *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::Smear::Distributor >(0);
      static ::ROOT::TGenericClassInfo 
         instance("Smear::Distributor", ::Smear::Distributor::Class_Version(), "/phenix/u/spjeffas/LQGENEP/eic-smear-1.0.3/include/eicsmear/smear/Distributor.h", 32,
                  typeid(::Smear::Distributor), ::ROOT::DefineBehavior(ptr, ptr),
                  &::Smear::Distributor::Dictionary, isa_proxy, 4,
                  sizeof(::Smear::Distributor) );
      instance.SetNew(&new_SmearcLcLDistributor);
      instance.SetNewArray(&newArray_SmearcLcLDistributor);
      instance.SetDelete(&delete_SmearcLcLDistributor);
      instance.SetDeleteArray(&deleteArray_SmearcLcLDistributor);
      instance.SetDestructor(&destruct_SmearcLcLDistributor);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::Smear::Distributor*)
   {
      return GenerateInitInstanceLocal((::Smear::Distributor*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Smear::Distributor*)0x0); R__UseDummy(_R__UNIQUE_(Init));
} // end of namespace ROOTDict

namespace ROOTDict {
   void SmearcLcLSmearer_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void delete_SmearcLcLSmearer(void *p);
   static void deleteArray_SmearcLcLSmearer(void *p);
   static void destruct_SmearcLcLSmearer(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::Smear::Smearer*)
   {
      ::Smear::Smearer *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::Smear::Smearer >(0);
      static ::ROOT::TGenericClassInfo 
         instance("Smear::Smearer", ::Smear::Smearer::Class_Version(), "/phenix/u/spjeffas/LQGENEP/eic-smear-1.0.3/include/eicsmear/smear/Smearer.h", 33,
                  typeid(::Smear::Smearer), ::ROOT::DefineBehavior(ptr, ptr),
                  &::Smear::Smearer::Dictionary, isa_proxy, 4,
                  sizeof(::Smear::Smearer) );
      instance.SetDelete(&delete_SmearcLcLSmearer);
      instance.SetDeleteArray(&deleteArray_SmearcLcLSmearer);
      instance.SetDestructor(&destruct_SmearcLcLSmearer);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::Smear::Smearer*)
   {
      return GenerateInitInstanceLocal((::Smear::Smearer*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Smear::Smearer*)0x0); R__UseDummy(_R__UNIQUE_(Init));
} // end of namespace ROOTDict

namespace ROOTDict {
   void SmearcLcLFormulaString_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void *new_SmearcLcLFormulaString(void *p = 0);
   static void *newArray_SmearcLcLFormulaString(Long_t size, void *p);
   static void delete_SmearcLcLFormulaString(void *p);
   static void deleteArray_SmearcLcLFormulaString(void *p);
   static void destruct_SmearcLcLFormulaString(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::Smear::FormulaString*)
   {
      ::Smear::FormulaString *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::Smear::FormulaString >(0);
      static ::ROOT::TGenericClassInfo 
         instance("Smear::FormulaString", ::Smear::FormulaString::Class_Version(), "/phenix/u/spjeffas/LQGENEP/eic-smear-1.0.3/include/eicsmear/smear/FormulaString.h", 27,
                  typeid(::Smear::FormulaString), ::ROOT::DefineBehavior(ptr, ptr),
                  &::Smear::FormulaString::Dictionary, isa_proxy, 4,
                  sizeof(::Smear::FormulaString) );
      instance.SetNew(&new_SmearcLcLFormulaString);
      instance.SetNewArray(&newArray_SmearcLcLFormulaString);
      instance.SetDelete(&delete_SmearcLcLFormulaString);
      instance.SetDeleteArray(&deleteArray_SmearcLcLFormulaString);
      instance.SetDestructor(&destruct_SmearcLcLFormulaString);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::Smear::FormulaString*)
   {
      return GenerateInitInstanceLocal((::Smear::FormulaString*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Smear::FormulaString*)0x0); R__UseDummy(_R__UNIQUE_(Init));
} // end of namespace ROOTDict

namespace ROOTDict {
   void SmearcLcLDevice_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void *new_SmearcLcLDevice(void *p = 0);
   static void *newArray_SmearcLcLDevice(Long_t size, void *p);
   static void delete_SmearcLcLDevice(void *p);
   static void deleteArray_SmearcLcLDevice(void *p);
   static void destruct_SmearcLcLDevice(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::Smear::Device*)
   {
      ::Smear::Device *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::Smear::Device >(0);
      static ::ROOT::TGenericClassInfo 
         instance("Smear::Device", ::Smear::Device::Class_Version(), "/phenix/u/spjeffas/LQGENEP/eic-smear-1.0.3/include/eicsmear/smear/Device.h", 44,
                  typeid(::Smear::Device), ::ROOT::DefineBehavior(ptr, ptr),
                  &::Smear::Device::Dictionary, isa_proxy, 4,
                  sizeof(::Smear::Device) );
      instance.SetNew(&new_SmearcLcLDevice);
      instance.SetNewArray(&newArray_SmearcLcLDevice);
      instance.SetDelete(&delete_SmearcLcLDevice);
      instance.SetDeleteArray(&deleteArray_SmearcLcLDevice);
      instance.SetDestructor(&destruct_SmearcLcLDevice);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::Smear::Device*)
   {
      return GenerateInitInstanceLocal((::Smear::Device*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Smear::Device*)0x0); R__UseDummy(_R__UNIQUE_(Init));
} // end of namespace ROOTDict

namespace ROOTDict {
   void SmearcLcLBremsstrahlung_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void *new_SmearcLcLBremsstrahlung(void *p = 0);
   static void *newArray_SmearcLcLBremsstrahlung(Long_t size, void *p);
   static void delete_SmearcLcLBremsstrahlung(void *p);
   static void deleteArray_SmearcLcLBremsstrahlung(void *p);
   static void destruct_SmearcLcLBremsstrahlung(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::Smear::Bremsstrahlung*)
   {
      ::Smear::Bremsstrahlung *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::Smear::Bremsstrahlung >(0);
      static ::ROOT::TGenericClassInfo 
         instance("Smear::Bremsstrahlung", ::Smear::Bremsstrahlung::Class_Version(), "/phenix/u/spjeffas/LQGENEP/eic-smear-1.0.3/include/eicsmear/smear/Bremsstrahlung.h", 32,
                  typeid(::Smear::Bremsstrahlung), ::ROOT::DefineBehavior(ptr, ptr),
                  &::Smear::Bremsstrahlung::Dictionary, isa_proxy, 4,
                  sizeof(::Smear::Bremsstrahlung) );
      instance.SetNew(&new_SmearcLcLBremsstrahlung);
      instance.SetNewArray(&newArray_SmearcLcLBremsstrahlung);
      instance.SetDelete(&delete_SmearcLcLBremsstrahlung);
      instance.SetDeleteArray(&deleteArray_SmearcLcLBremsstrahlung);
      instance.SetDestructor(&destruct_SmearcLcLBremsstrahlung);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::Smear::Bremsstrahlung*)
   {
      return GenerateInitInstanceLocal((::Smear::Bremsstrahlung*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Smear::Bremsstrahlung*)0x0); R__UseDummy(_R__UNIQUE_(Init));
} // end of namespace ROOTDict

namespace ROOTDict {
   void auto_ptrlEerhiccLcLParticleMCgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void auto_ptrlEerhiccLcLParticleMCgR_Dictionary();
   static void *new_auto_ptrlEerhiccLcLParticleMCgR(void *p = 0);
   static void *newArray_auto_ptrlEerhiccLcLParticleMCgR(Long_t size, void *p);
   static void delete_auto_ptrlEerhiccLcLParticleMCgR(void *p);
   static void deleteArray_auto_ptrlEerhiccLcLParticleMCgR(void *p);
   static void destruct_auto_ptrlEerhiccLcLParticleMCgR(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const auto_ptr<erhic::ParticleMC>*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(auto_ptr<erhic::ParticleMC>) == sizeof( ::ROOTShadow::Shadow::auto_ptrlEerhiccLcLParticleMCgR));
      auto_ptr<erhic::ParticleMC> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(auto_ptr<erhic::ParticleMC>),0);
      static ::ROOT::TGenericClassInfo 
         instance("auto_ptr<erhic::ParticleMC>", "prec_stl/memory", 210,
                  typeid(auto_ptr<erhic::ParticleMC>), ::ROOT::DefineBehavior(ptr, ptr),
                  &auto_ptrlEerhiccLcLParticleMCgR_ShowMembers, &auto_ptrlEerhiccLcLParticleMCgR_Dictionary, isa_proxy, 0,
                  sizeof(auto_ptr<erhic::ParticleMC>) );
      instance.SetNew(&new_auto_ptrlEerhiccLcLParticleMCgR);
      instance.SetNewArray(&newArray_auto_ptrlEerhiccLcLParticleMCgR);
      instance.SetDelete(&delete_auto_ptrlEerhiccLcLParticleMCgR);
      instance.SetDeleteArray(&deleteArray_auto_ptrlEerhiccLcLParticleMCgR);
      instance.SetDestructor(&destruct_auto_ptrlEerhiccLcLParticleMCgR);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const auto_ptr<erhic::ParticleMC>*)
   {
      return GenerateInitInstanceLocal((auto_ptr<erhic::ParticleMC>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const auto_ptr<erhic::ParticleMC>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void auto_ptrlEerhiccLcLParticleMCgR_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const auto_ptr<erhic::ParticleMC>*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void SmearcLcLDetector_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void *new_SmearcLcLDetector(void *p = 0);
   static void *newArray_SmearcLcLDetector(Long_t size, void *p);
   static void delete_SmearcLcLDetector(void *p);
   static void deleteArray_SmearcLcLDetector(void *p);
   static void destruct_SmearcLcLDetector(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::Smear::Detector*)
   {
      ::Smear::Detector *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::Smear::Detector >(0);
      static ::ROOT::TGenericClassInfo 
         instance("Smear::Detector", ::Smear::Detector::Class_Version(), "/phenix/u/spjeffas/LQGENEP/eic-smear-1.0.3/include/eicsmear/smear/Detector.h", 44,
                  typeid(::Smear::Detector), ::ROOT::DefineBehavior(ptr, ptr),
                  &::Smear::Detector::Dictionary, isa_proxy, 4,
                  sizeof(::Smear::Detector) );
      instance.SetNew(&new_SmearcLcLDetector);
      instance.SetNewArray(&newArray_SmearcLcLDetector);
      instance.SetDelete(&delete_SmearcLcLDetector);
      instance.SetDeleteArray(&deleteArray_SmearcLcLDetector);
      instance.SetDestructor(&destruct_SmearcLcLDetector);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::Smear::Detector*)
   {
      return GenerateInitInstanceLocal((::Smear::Detector*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Smear::Detector*)0x0); R__UseDummy(_R__UNIQUE_(Init));
} // end of namespace ROOTDict

namespace ROOTDict {
   void SmearcLcLParticleID_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void *new_SmearcLcLParticleID(void *p = 0);
   static void *newArray_SmearcLcLParticleID(Long_t size, void *p);
   static void delete_SmearcLcLParticleID(void *p);
   static void deleteArray_SmearcLcLParticleID(void *p);
   static void destruct_SmearcLcLParticleID(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::Smear::ParticleID*)
   {
      ::Smear::ParticleID *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::Smear::ParticleID >(0);
      static ::ROOT::TGenericClassInfo 
         instance("Smear::ParticleID", ::Smear::ParticleID::Class_Version(), "/phenix/u/spjeffas/LQGENEP/eic-smear-1.0.3/include/eicsmear/smear/ParticleID.h", 67,
                  typeid(::Smear::ParticleID), ::ROOT::DefineBehavior(ptr, ptr),
                  &::Smear::ParticleID::Dictionary, isa_proxy, 4,
                  sizeof(::Smear::ParticleID) );
      instance.SetNew(&new_SmearcLcLParticleID);
      instance.SetNewArray(&newArray_SmearcLcLParticleID);
      instance.SetDelete(&delete_SmearcLcLParticleID);
      instance.SetDeleteArray(&deleteArray_SmearcLcLParticleID);
      instance.SetDestructor(&destruct_SmearcLcLParticleID);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::Smear::ParticleID*)
   {
      return GenerateInitInstanceLocal((::Smear::ParticleID*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Smear::ParticleID*)0x0); R__UseDummy(_R__UNIQUE_(Init));
} // end of namespace ROOTDict

namespace ROOTDict {
   void SmearcLcLPerfectID_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void *new_SmearcLcLPerfectID(void *p = 0);
   static void *newArray_SmearcLcLPerfectID(Long_t size, void *p);
   static void delete_SmearcLcLPerfectID(void *p);
   static void deleteArray_SmearcLcLPerfectID(void *p);
   static void destruct_SmearcLcLPerfectID(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::Smear::PerfectID*)
   {
      ::Smear::PerfectID *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::Smear::PerfectID >(0);
      static ::ROOT::TGenericClassInfo 
         instance("Smear::PerfectID", ::Smear::PerfectID::Class_Version(), "/phenix/u/spjeffas/LQGENEP/eic-smear-1.0.3/include/eicsmear/smear/PerfectID.h", 27,
                  typeid(::Smear::PerfectID), ::ROOT::DefineBehavior(ptr, ptr),
                  &::Smear::PerfectID::Dictionary, isa_proxy, 4,
                  sizeof(::Smear::PerfectID) );
      instance.SetNew(&new_SmearcLcLPerfectID);
      instance.SetNewArray(&newArray_SmearcLcLPerfectID);
      instance.SetDelete(&delete_SmearcLcLPerfectID);
      instance.SetDeleteArray(&deleteArray_SmearcLcLPerfectID);
      instance.SetDestructor(&destruct_SmearcLcLPerfectID);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::Smear::PerfectID*)
   {
      return GenerateInitInstanceLocal((::Smear::PerfectID*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Smear::PerfectID*)0x0); R__UseDummy(_R__UNIQUE_(Init));
} // end of namespace ROOTDict

namespace ROOTDict {
   void SmearcLcLTracker_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void delete_SmearcLcLTracker(void *p);
   static void deleteArray_SmearcLcLTracker(void *p);
   static void destruct_SmearcLcLTracker(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::Smear::Tracker*)
   {
      ::Smear::Tracker *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::Smear::Tracker >(0);
      static ::ROOT::TGenericClassInfo 
         instance("Smear::Tracker", ::Smear::Tracker::Class_Version(), "/phenix/u/spjeffas/LQGENEP/eic-smear-1.0.3/include/eicsmear/smear/Tracker.h", 35,
                  typeid(::Smear::Tracker), ::ROOT::DefineBehavior(ptr, ptr),
                  &::Smear::Tracker::Dictionary, isa_proxy, 4,
                  sizeof(::Smear::Tracker) );
      instance.SetDelete(&delete_SmearcLcLTracker);
      instance.SetDeleteArray(&deleteArray_SmearcLcLTracker);
      instance.SetDestructor(&destruct_SmearcLcLTracker);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::Smear::Tracker*)
   {
      return GenerateInitInstanceLocal((::Smear::Tracker*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Smear::Tracker*)0x0); R__UseDummy(_R__UNIQUE_(Init));
} // end of namespace ROOTDict

namespace ROOTDict {
   void SmearcLcLPlanarTracker_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void *new_SmearcLcLPlanarTracker(void *p = 0);
   static void *newArray_SmearcLcLPlanarTracker(Long_t size, void *p);
   static void delete_SmearcLcLPlanarTracker(void *p);
   static void deleteArray_SmearcLcLPlanarTracker(void *p);
   static void destruct_SmearcLcLPlanarTracker(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::Smear::PlanarTracker*)
   {
      ::Smear::PlanarTracker *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::Smear::PlanarTracker >(0);
      static ::ROOT::TGenericClassInfo 
         instance("Smear::PlanarTracker", ::Smear::PlanarTracker::Class_Version(), "/phenix/u/spjeffas/LQGENEP/eic-smear-1.0.3/include/eicsmear/smear/PlanarTracker.h", 32,
                  typeid(::Smear::PlanarTracker), ::ROOT::DefineBehavior(ptr, ptr),
                  &::Smear::PlanarTracker::Dictionary, isa_proxy, 4,
                  sizeof(::Smear::PlanarTracker) );
      instance.SetNew(&new_SmearcLcLPlanarTracker);
      instance.SetNewArray(&newArray_SmearcLcLPlanarTracker);
      instance.SetDelete(&delete_SmearcLcLPlanarTracker);
      instance.SetDeleteArray(&deleteArray_SmearcLcLPlanarTracker);
      instance.SetDestructor(&destruct_SmearcLcLPlanarTracker);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::Smear::PlanarTracker*)
   {
      return GenerateInitInstanceLocal((::Smear::PlanarTracker*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Smear::PlanarTracker*)0x0); R__UseDummy(_R__UNIQUE_(Init));
} // end of namespace ROOTDict

namespace ROOTDict {
   void SmearcLcLRadialTracker_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void *new_SmearcLcLRadialTracker(void *p = 0);
   static void *newArray_SmearcLcLRadialTracker(Long_t size, void *p);
   static void delete_SmearcLcLRadialTracker(void *p);
   static void deleteArray_SmearcLcLRadialTracker(void *p);
   static void destruct_SmearcLcLRadialTracker(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::Smear::RadialTracker*)
   {
      ::Smear::RadialTracker *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::Smear::RadialTracker >(0);
      static ::ROOT::TGenericClassInfo 
         instance("Smear::RadialTracker", ::Smear::RadialTracker::Class_Version(), "/phenix/u/spjeffas/LQGENEP/eic-smear-1.0.3/include/eicsmear/smear/RadialTracker.h", 32,
                  typeid(::Smear::RadialTracker), ::ROOT::DefineBehavior(ptr, ptr),
                  &::Smear::RadialTracker::Dictionary, isa_proxy, 4,
                  sizeof(::Smear::RadialTracker) );
      instance.SetNew(&new_SmearcLcLRadialTracker);
      instance.SetNewArray(&newArray_SmearcLcLRadialTracker);
      instance.SetDelete(&delete_SmearcLcLRadialTracker);
      instance.SetDeleteArray(&deleteArray_SmearcLcLRadialTracker);
      instance.SetDestructor(&destruct_SmearcLcLRadialTracker);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::Smear::RadialTracker*)
   {
      return GenerateInitInstanceLocal((::Smear::RadialTracker*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Smear::RadialTracker*)0x0); R__UseDummy(_R__UNIQUE_(Init));
} // end of namespace ROOTDict

      namespace Smear {
//______________________________________________________________________________
atomic_TClass_ptr Event::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *Event::Class_Name()
{
   return "Smear::Event";
}

//______________________________________________________________________________
const char *Event::ImplFileName()
{
   return ::ROOTDict::GenerateInitInstanceLocal((const ::Smear::Event*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int Event::ImplFileLine()
{
   return ::ROOTDict::GenerateInitInstanceLocal((const ::Smear::Event*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
void Event::Dictionary()
{
   fgIsA = ::ROOTDict::GenerateInitInstanceLocal((const ::Smear::Event*)0x0)->GetClass();
}

//______________________________________________________________________________
TClass *Event::Class()
{
   if (!fgIsA) { R__LOCKGUARD2(gCINTMutex); if(!fgIsA) {fgIsA = ::ROOTDict::GenerateInitInstanceLocal((const ::Smear::Event*)0x0)->GetClass();} }
   return fgIsA;
}

} // namespace Smear
      namespace Smear {
//______________________________________________________________________________
atomic_TClass_ptr ParticleMCS::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *ParticleMCS::Class_Name()
{
   return "Smear::ParticleMCS";
}

//______________________________________________________________________________
const char *ParticleMCS::ImplFileName()
{
   return ::ROOTDict::GenerateInitInstanceLocal((const ::Smear::ParticleMCS*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int ParticleMCS::ImplFileLine()
{
   return ::ROOTDict::GenerateInitInstanceLocal((const ::Smear::ParticleMCS*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
void ParticleMCS::Dictionary()
{
   fgIsA = ::ROOTDict::GenerateInitInstanceLocal((const ::Smear::ParticleMCS*)0x0)->GetClass();
}

//______________________________________________________________________________
TClass *ParticleMCS::Class()
{
   if (!fgIsA) { R__LOCKGUARD2(gCINTMutex); if(!fgIsA) {fgIsA = ::ROOTDict::GenerateInitInstanceLocal((const ::Smear::ParticleMCS*)0x0)->GetClass();} }
   return fgIsA;
}

} // namespace Smear
      namespace Smear {
//______________________________________________________________________________
atomic_TClass_ptr Acceptance::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *Acceptance::Class_Name()
{
   return "Smear::Acceptance";
}

//______________________________________________________________________________
const char *Acceptance::ImplFileName()
{
   return ::ROOTDict::GenerateInitInstanceLocal((const ::Smear::Acceptance*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int Acceptance::ImplFileLine()
{
   return ::ROOTDict::GenerateInitInstanceLocal((const ::Smear::Acceptance*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
void Acceptance::Dictionary()
{
   fgIsA = ::ROOTDict::GenerateInitInstanceLocal((const ::Smear::Acceptance*)0x0)->GetClass();
}

//______________________________________________________________________________
TClass *Acceptance::Class()
{
   if (!fgIsA) { R__LOCKGUARD2(gCINTMutex); if(!fgIsA) {fgIsA = ::ROOTDict::GenerateInitInstanceLocal((const ::Smear::Acceptance*)0x0)->GetClass();} }
   return fgIsA;
}

} // namespace Smear
      namespace Smear {
//______________________________________________________________________________
atomic_TClass_ptr Acceptance::Zone::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *Acceptance::Zone::Class_Name()
{
   return "Smear::Acceptance::Zone";
}

//______________________________________________________________________________
const char *Acceptance::Zone::ImplFileName()
{
   return ::ROOTDict::GenerateInitInstanceLocal((const ::Smear::Acceptance::Zone*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int Acceptance::Zone::ImplFileLine()
{
   return ::ROOTDict::GenerateInitInstanceLocal((const ::Smear::Acceptance::Zone*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
void Acceptance::Zone::Dictionary()
{
   fgIsA = ::ROOTDict::GenerateInitInstanceLocal((const ::Smear::Acceptance::Zone*)0x0)->GetClass();
}

//______________________________________________________________________________
TClass *Acceptance::Zone::Class()
{
   if (!fgIsA) { R__LOCKGUARD2(gCINTMutex); if(!fgIsA) {fgIsA = ::ROOTDict::GenerateInitInstanceLocal((const ::Smear::Acceptance::Zone*)0x0)->GetClass();} }
   return fgIsA;
}

} // namespace Smear
      namespace Smear {
//______________________________________________________________________________
atomic_TClass_ptr Distributor::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *Distributor::Class_Name()
{
   return "Smear::Distributor";
}

//______________________________________________________________________________
const char *Distributor::ImplFileName()
{
   return ::ROOTDict::GenerateInitInstanceLocal((const ::Smear::Distributor*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int Distributor::ImplFileLine()
{
   return ::ROOTDict::GenerateInitInstanceLocal((const ::Smear::Distributor*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
void Distributor::Dictionary()
{
   fgIsA = ::ROOTDict::GenerateInitInstanceLocal((const ::Smear::Distributor*)0x0)->GetClass();
}

//______________________________________________________________________________
TClass *Distributor::Class()
{
   if (!fgIsA) { R__LOCKGUARD2(gCINTMutex); if(!fgIsA) {fgIsA = ::ROOTDict::GenerateInitInstanceLocal((const ::Smear::Distributor*)0x0)->GetClass();} }
   return fgIsA;
}

} // namespace Smear
      namespace Smear {
//______________________________________________________________________________
atomic_TClass_ptr Smearer::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *Smearer::Class_Name()
{
   return "Smear::Smearer";
}

//______________________________________________________________________________
const char *Smearer::ImplFileName()
{
   return ::ROOTDict::GenerateInitInstanceLocal((const ::Smear::Smearer*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int Smearer::ImplFileLine()
{
   return ::ROOTDict::GenerateInitInstanceLocal((const ::Smear::Smearer*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
void Smearer::Dictionary()
{
   fgIsA = ::ROOTDict::GenerateInitInstanceLocal((const ::Smear::Smearer*)0x0)->GetClass();
}

//______________________________________________________________________________
TClass *Smearer::Class()
{
   if (!fgIsA) { R__LOCKGUARD2(gCINTMutex); if(!fgIsA) {fgIsA = ::ROOTDict::GenerateInitInstanceLocal((const ::Smear::Smearer*)0x0)->GetClass();} }
   return fgIsA;
}

} // namespace Smear
      namespace Smear {
//______________________________________________________________________________
atomic_TClass_ptr FormulaString::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *FormulaString::Class_Name()
{
   return "Smear::FormulaString";
}

//______________________________________________________________________________
const char *FormulaString::ImplFileName()
{
   return ::ROOTDict::GenerateInitInstanceLocal((const ::Smear::FormulaString*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int FormulaString::ImplFileLine()
{
   return ::ROOTDict::GenerateInitInstanceLocal((const ::Smear::FormulaString*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
void FormulaString::Dictionary()
{
   fgIsA = ::ROOTDict::GenerateInitInstanceLocal((const ::Smear::FormulaString*)0x0)->GetClass();
}

//______________________________________________________________________________
TClass *FormulaString::Class()
{
   if (!fgIsA) { R__LOCKGUARD2(gCINTMutex); if(!fgIsA) {fgIsA = ::ROOTDict::GenerateInitInstanceLocal((const ::Smear::FormulaString*)0x0)->GetClass();} }
   return fgIsA;
}

} // namespace Smear
      namespace Smear {
//______________________________________________________________________________
atomic_TClass_ptr Device::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *Device::Class_Name()
{
   return "Smear::Device";
}

//______________________________________________________________________________
const char *Device::ImplFileName()
{
   return ::ROOTDict::GenerateInitInstanceLocal((const ::Smear::Device*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int Device::ImplFileLine()
{
   return ::ROOTDict::GenerateInitInstanceLocal((const ::Smear::Device*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
void Device::Dictionary()
{
   fgIsA = ::ROOTDict::GenerateInitInstanceLocal((const ::Smear::Device*)0x0)->GetClass();
}

//______________________________________________________________________________
TClass *Device::Class()
{
   if (!fgIsA) { R__LOCKGUARD2(gCINTMutex); if(!fgIsA) {fgIsA = ::ROOTDict::GenerateInitInstanceLocal((const ::Smear::Device*)0x0)->GetClass();} }
   return fgIsA;
}

} // namespace Smear
      namespace Smear {
//______________________________________________________________________________
atomic_TClass_ptr Bremsstrahlung::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *Bremsstrahlung::Class_Name()
{
   return "Smear::Bremsstrahlung";
}

//______________________________________________________________________________
const char *Bremsstrahlung::ImplFileName()
{
   return ::ROOTDict::GenerateInitInstanceLocal((const ::Smear::Bremsstrahlung*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int Bremsstrahlung::ImplFileLine()
{
   return ::ROOTDict::GenerateInitInstanceLocal((const ::Smear::Bremsstrahlung*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
void Bremsstrahlung::Dictionary()
{
   fgIsA = ::ROOTDict::GenerateInitInstanceLocal((const ::Smear::Bremsstrahlung*)0x0)->GetClass();
}

//______________________________________________________________________________
TClass *Bremsstrahlung::Class()
{
   if (!fgIsA) { R__LOCKGUARD2(gCINTMutex); if(!fgIsA) {fgIsA = ::ROOTDict::GenerateInitInstanceLocal((const ::Smear::Bremsstrahlung*)0x0)->GetClass();} }
   return fgIsA;
}

} // namespace Smear
      namespace Smear {
//______________________________________________________________________________
atomic_TClass_ptr Detector::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *Detector::Class_Name()
{
   return "Smear::Detector";
}

//______________________________________________________________________________
const char *Detector::ImplFileName()
{
   return ::ROOTDict::GenerateInitInstanceLocal((const ::Smear::Detector*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int Detector::ImplFileLine()
{
   return ::ROOTDict::GenerateInitInstanceLocal((const ::Smear::Detector*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
void Detector::Dictionary()
{
   fgIsA = ::ROOTDict::GenerateInitInstanceLocal((const ::Smear::Detector*)0x0)->GetClass();
}

//______________________________________________________________________________
TClass *Detector::Class()
{
   if (!fgIsA) { R__LOCKGUARD2(gCINTMutex); if(!fgIsA) {fgIsA = ::ROOTDict::GenerateInitInstanceLocal((const ::Smear::Detector*)0x0)->GetClass();} }
   return fgIsA;
}

} // namespace Smear
      namespace Smear {
//______________________________________________________________________________
atomic_TClass_ptr ParticleID::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *ParticleID::Class_Name()
{
   return "Smear::ParticleID";
}

//______________________________________________________________________________
const char *ParticleID::ImplFileName()
{
   return ::ROOTDict::GenerateInitInstanceLocal((const ::Smear::ParticleID*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int ParticleID::ImplFileLine()
{
   return ::ROOTDict::GenerateInitInstanceLocal((const ::Smear::ParticleID*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
void ParticleID::Dictionary()
{
   fgIsA = ::ROOTDict::GenerateInitInstanceLocal((const ::Smear::ParticleID*)0x0)->GetClass();
}

//______________________________________________________________________________
TClass *ParticleID::Class()
{
   if (!fgIsA) { R__LOCKGUARD2(gCINTMutex); if(!fgIsA) {fgIsA = ::ROOTDict::GenerateInitInstanceLocal((const ::Smear::ParticleID*)0x0)->GetClass();} }
   return fgIsA;
}

} // namespace Smear
      namespace Smear {
//______________________________________________________________________________
atomic_TClass_ptr PerfectID::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *PerfectID::Class_Name()
{
   return "Smear::PerfectID";
}

//______________________________________________________________________________
const char *PerfectID::ImplFileName()
{
   return ::ROOTDict::GenerateInitInstanceLocal((const ::Smear::PerfectID*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int PerfectID::ImplFileLine()
{
   return ::ROOTDict::GenerateInitInstanceLocal((const ::Smear::PerfectID*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
void PerfectID::Dictionary()
{
   fgIsA = ::ROOTDict::GenerateInitInstanceLocal((const ::Smear::PerfectID*)0x0)->GetClass();
}

//______________________________________________________________________________
TClass *PerfectID::Class()
{
   if (!fgIsA) { R__LOCKGUARD2(gCINTMutex); if(!fgIsA) {fgIsA = ::ROOTDict::GenerateInitInstanceLocal((const ::Smear::PerfectID*)0x0)->GetClass();} }
   return fgIsA;
}

} // namespace Smear
      namespace Smear {
//______________________________________________________________________________
atomic_TClass_ptr Tracker::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *Tracker::Class_Name()
{
   return "Smear::Tracker";
}

//______________________________________________________________________________
const char *Tracker::ImplFileName()
{
   return ::ROOTDict::GenerateInitInstanceLocal((const ::Smear::Tracker*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int Tracker::ImplFileLine()
{
   return ::ROOTDict::GenerateInitInstanceLocal((const ::Smear::Tracker*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
void Tracker::Dictionary()
{
   fgIsA = ::ROOTDict::GenerateInitInstanceLocal((const ::Smear::Tracker*)0x0)->GetClass();
}

//______________________________________________________________________________
TClass *Tracker::Class()
{
   if (!fgIsA) { R__LOCKGUARD2(gCINTMutex); if(!fgIsA) {fgIsA = ::ROOTDict::GenerateInitInstanceLocal((const ::Smear::Tracker*)0x0)->GetClass();} }
   return fgIsA;
}

} // namespace Smear
      namespace Smear {
//______________________________________________________________________________
atomic_TClass_ptr PlanarTracker::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *PlanarTracker::Class_Name()
{
   return "Smear::PlanarTracker";
}

//______________________________________________________________________________
const char *PlanarTracker::ImplFileName()
{
   return ::ROOTDict::GenerateInitInstanceLocal((const ::Smear::PlanarTracker*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int PlanarTracker::ImplFileLine()
{
   return ::ROOTDict::GenerateInitInstanceLocal((const ::Smear::PlanarTracker*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
void PlanarTracker::Dictionary()
{
   fgIsA = ::ROOTDict::GenerateInitInstanceLocal((const ::Smear::PlanarTracker*)0x0)->GetClass();
}

//______________________________________________________________________________
TClass *PlanarTracker::Class()
{
   if (!fgIsA) { R__LOCKGUARD2(gCINTMutex); if(!fgIsA) {fgIsA = ::ROOTDict::GenerateInitInstanceLocal((const ::Smear::PlanarTracker*)0x0)->GetClass();} }
   return fgIsA;
}

} // namespace Smear
      namespace Smear {
//______________________________________________________________________________
atomic_TClass_ptr RadialTracker::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RadialTracker::Class_Name()
{
   return "Smear::RadialTracker";
}

//______________________________________________________________________________
const char *RadialTracker::ImplFileName()
{
   return ::ROOTDict::GenerateInitInstanceLocal((const ::Smear::RadialTracker*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RadialTracker::ImplFileLine()
{
   return ::ROOTDict::GenerateInitInstanceLocal((const ::Smear::RadialTracker*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
void RadialTracker::Dictionary()
{
   fgIsA = ::ROOTDict::GenerateInitInstanceLocal((const ::Smear::RadialTracker*)0x0)->GetClass();
}

//______________________________________________________________________________
TClass *RadialTracker::Class()
{
   if (!fgIsA) { R__LOCKGUARD2(gCINTMutex); if(!fgIsA) {fgIsA = ::ROOTDict::GenerateInitInstanceLocal((const ::Smear::RadialTracker*)0x0)->GetClass();} }
   return fgIsA;
}

} // namespace Smear
      namespace Smear {
//______________________________________________________________________________
void Event::Streamer(TBuffer &R__b)
{
   // Stream an object of class Smear::Event.

   //This works around a msvc bug and should be harmless on other platforms
   typedef ::Smear::Event thisClass;
   UInt_t R__s, R__c;
   if (R__b.IsReading()) {
      Version_t R__v = R__b.ReadVersion(&R__s, &R__c); if (R__v) { }
      //This works around a msvc bug and should be harmless on other platforms
      typedef erhic::EventDis baseClass0;
      baseClass0::Streamer(R__b);
      R__b >> nTracks;
      {
         vector<ParticleMCS*> &R__stl =  particles;
         R__stl.clear();
         TClass *R__tcl1 = TBuffer::GetClass(typeid(Smear::ParticleMCS));
         if (R__tcl1==0) {
            Error("particles streamer","Missing the TClass object for Smear::ParticleMCS!");
            return;
         }
         int R__i, R__n;
         R__b >> R__n;
         R__stl.reserve(R__n);
         for (R__i = 0; R__i < R__n; R__i++) {
            Smear::ParticleMCS* R__t;
            R__t = (Smear::ParticleMCS*)R__b.ReadObjectAny(R__tcl1);
            R__stl.push_back(R__t);
         }
      }
      R__b >> mScatteredIndex;
      R__b.CheckByteCount(R__s, R__c, thisClass::IsA());
   } else {
      R__c = R__b.WriteVersion(thisClass::IsA(), kTRUE);
      //This works around a msvc bug and should be harmless on other platforms
      typedef erhic::EventDis baseClass0;
      baseClass0::Streamer(R__b);
      R__b << nTracks;
      {
         vector<ParticleMCS*> &R__stl =  particles;
         int R__n=(true) ? int(R__stl.size()) : 0;
         R__b << R__n;
         if(R__n) {
            vector<ParticleMCS*>::iterator R__k;
            for (R__k = R__stl.begin(); R__k != R__stl.end(); ++R__k) {
            R__b << (*R__k);
            }
         }
      }
      R__b << mScatteredIndex;
      R__b.SetByteCount(R__c, kTRUE);
   }
}

} // namespace Smear
//______________________________________________________________________________
      namespace Smear {
void Event::ShowMembers(TMemberInspector &R__insp)
{
      // Inspect the data members of an object of class Smear::Event.
      TClass *R__cl = ::Smear::Event::IsA();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "nTracks", &nTracks);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "particles", (void*)&particles);
      R__insp.InspectMember("vector<ParticleMCS*>", (void*)&particles, "particles.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "mScatteredIndex", &mScatteredIndex);
      //This works around a msvc bug and should be harmless on other platforms
      typedef erhic::EventDis baseClass1;
      baseClass1::ShowMembers(R__insp);
}

} // namespace Smear
namespace ROOTDict {
   // Wrappers around operator new
   static void *new_SmearcLcLEvent(void *p) {
      return  p ? new(p) ::Smear::Event : new ::Smear::Event;
   }
   static void *newArray_SmearcLcLEvent(Long_t nElements, void *p) {
      return p ? new(p) ::Smear::Event[nElements] : new ::Smear::Event[nElements];
   }
   // Wrapper around operator delete
   static void delete_SmearcLcLEvent(void *p) {
      delete ((::Smear::Event*)p);
   }
   static void deleteArray_SmearcLcLEvent(void *p) {
      delete [] ((::Smear::Event*)p);
   }
   static void destruct_SmearcLcLEvent(void *p) {
      typedef ::Smear::Event current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_SmearcLcLEvent(TBuffer &buf, void *obj) {
      ((::Smear::Event*)obj)->::Smear::Event::Streamer(buf);
   }
} // end of namespace ROOTDict for class ::Smear::Event

      namespace Smear {
//______________________________________________________________________________
void ParticleMCS::Streamer(TBuffer &R__b)
{
   // Stream an object of class Smear::ParticleMCS.

   //This works around a msvc bug and should be harmless on other platforms
   typedef ::Smear::ParticleMCS thisClass;
   UInt_t R__s, R__c;
   if (R__b.IsReading()) {
      Version_t R__v = R__b.ReadVersion(&R__s, &R__c); if (R__v) { }
      //This works around a msvc bug and should be harmless on other platforms
      typedef erhic::VirtualParticle baseClass0;
      baseClass0::Streamer(R__b);
      R__b >> status;
      R__b >> id;
      {float R_Dummy; R__b >> R_Dummy; px=Double32_t(R_Dummy);}
      {float R_Dummy; R__b >> R_Dummy; py=Double32_t(R_Dummy);}
      {float R_Dummy; R__b >> R_Dummy; pz=Double32_t(R_Dummy);}
      {float R_Dummy; R__b >> R_Dummy; E=Double32_t(R_Dummy);}
      {float R_Dummy; R__b >> R_Dummy; pt=Double32_t(R_Dummy);}
      {float R_Dummy; R__b >> R_Dummy; p=Double32_t(R_Dummy);}
      {float R_Dummy; R__b >> R_Dummy; theta=Double32_t(R_Dummy);}
      {float R_Dummy; R__b >> R_Dummy; phi=Double32_t(R_Dummy);}
      R__b.CheckByteCount(R__s, R__c, thisClass::IsA());
   } else {
      R__c = R__b.WriteVersion(thisClass::IsA(), kTRUE);
      //This works around a msvc bug and should be harmless on other platforms
      typedef erhic::VirtualParticle baseClass0;
      baseClass0::Streamer(R__b);
      R__b << status;
      R__b << id;
      R__b << float(px);
      R__b << float(py);
      R__b << float(pz);
      R__b << float(E);
      R__b << float(pt);
      R__b << float(p);
      R__b << float(theta);
      R__b << float(phi);
      R__b.SetByteCount(R__c, kTRUE);
   }
}

} // namespace Smear
//______________________________________________________________________________
      namespace Smear {
void ParticleMCS::ShowMembers(TMemberInspector &R__insp)
{
      // Inspect the data members of an object of class Smear::ParticleMCS.
      TClass *R__cl = ::Smear::ParticleMCS::IsA();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "status", &status);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "id", &id);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "px", &px);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "py", &py);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "pz", &pz);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "E", &E);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "pt", &pt);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "p", &p);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "theta", &theta);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "phi", &phi);
      //This works around a msvc bug and should be harmless on other platforms
      typedef erhic::VirtualParticle baseClass1;
      baseClass1::ShowMembers(R__insp);
}

} // namespace Smear
namespace ROOTDict {
   // Wrappers around operator new
   static void *new_SmearcLcLParticleMCS(void *p) {
      return  p ? new(p) ::Smear::ParticleMCS : new ::Smear::ParticleMCS;
   }
   static void *newArray_SmearcLcLParticleMCS(Long_t nElements, void *p) {
      return p ? new(p) ::Smear::ParticleMCS[nElements] : new ::Smear::ParticleMCS[nElements];
   }
   // Wrapper around operator delete
   static void delete_SmearcLcLParticleMCS(void *p) {
      delete ((::Smear::ParticleMCS*)p);
   }
   static void deleteArray_SmearcLcLParticleMCS(void *p) {
      delete [] ((::Smear::ParticleMCS*)p);
   }
   static void destruct_SmearcLcLParticleMCS(void *p) {
      typedef ::Smear::ParticleMCS current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_SmearcLcLParticleMCS(TBuffer &buf, void *obj) {
      ((::Smear::ParticleMCS*)obj)->::Smear::ParticleMCS::Streamer(buf);
   }
} // end of namespace ROOTDict for class ::Smear::ParticleMCS

      namespace Smear {
//______________________________________________________________________________
void Acceptance::Streamer(TBuffer &R__b)
{
   // Stream an object of class Smear::Acceptance.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(Smear::Acceptance::Class(),this);
   } else {
      R__b.WriteClassBuffer(Smear::Acceptance::Class(),this);
   }
}

} // namespace Smear
//______________________________________________________________________________
      namespace Smear {
void Acceptance::ShowMembers(TMemberInspector &R__insp)
{
      // Inspect the data members of an object of class Smear::Acceptance.
      TClass *R__cl = ::Smear::Acceptance::IsA();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "mGenre", &mGenre);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "mCharge", &mCharge);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "mZones", (void*)&mZones);
      R__insp.InspectMember("vector<Zone>", (void*)&mZones, "mZones.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "mParticles", (void*)&mParticles);
      R__insp.InspectMember("set<int>", (void*)&mParticles, "mParticles.", false);
}

} // namespace Smear
namespace ROOTDict {
   // Wrappers around operator new
   static void *new_SmearcLcLAcceptance(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Smear::Acceptance : new ::Smear::Acceptance;
   }
   static void *newArray_SmearcLcLAcceptance(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Smear::Acceptance[nElements] : new ::Smear::Acceptance[nElements];
   }
   // Wrapper around operator delete
   static void delete_SmearcLcLAcceptance(void *p) {
      delete ((::Smear::Acceptance*)p);
   }
   static void deleteArray_SmearcLcLAcceptance(void *p) {
      delete [] ((::Smear::Acceptance*)p);
   }
   static void destruct_SmearcLcLAcceptance(void *p) {
      typedef ::Smear::Acceptance current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::Smear::Acceptance

//______________________________________________________________________________
namespace ROOTDict {
   void SmearcLcLAcceptancecLcLCustomCut_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class Smear::Acceptance::CustomCut.
      typedef ::ROOTShadow::Shadow::Smear::Acceptance::CustomCut ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOTDict::GenerateInitInstanceLocal((const ::Smear::Acceptance::CustomCut*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "mFormula", &sobj->mFormula);
      R__insp.InspectMember(sobj->mFormula, "mFormula.");
      R__insp.Inspect(R__cl, R__insp.GetParent(), "dim", &sobj->dim);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Kin1", &sobj->Kin1);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Kin2", &sobj->Kin2);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Min", &sobj->Min);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Max", &sobj->Max);
   }

}

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_SmearcLcLAcceptancecLcLCustomCut(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Smear::Acceptance::CustomCut : new ::Smear::Acceptance::CustomCut;
   }
   static void *newArray_SmearcLcLAcceptancecLcLCustomCut(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Smear::Acceptance::CustomCut[nElements] : new ::Smear::Acceptance::CustomCut[nElements];
   }
   // Wrapper around operator delete
   static void delete_SmearcLcLAcceptancecLcLCustomCut(void *p) {
      delete ((::Smear::Acceptance::CustomCut*)p);
   }
   static void deleteArray_SmearcLcLAcceptancecLcLCustomCut(void *p) {
      delete [] ((::Smear::Acceptance::CustomCut*)p);
   }
   static void destruct_SmearcLcLAcceptancecLcLCustomCut(void *p) {
      typedef ::Smear::Acceptance::CustomCut current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::Smear::Acceptance::CustomCut

      namespace Smear {
//______________________________________________________________________________
void Acceptance::Zone::Streamer(TBuffer &R__b)
{
   // Stream an object of class Smear::Acceptance::Zone.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(Smear::Acceptance::Zone::Class(),this);
   } else {
      R__b.WriteClassBuffer(Smear::Acceptance::Zone::Class(),this);
   }
}

} // namespace Smear
//______________________________________________________________________________
      namespace Smear {
void Acceptance::Zone::ShowMembers(TMemberInspector &R__insp)
{
      // Inspect the data members of an object of class Smear::Acceptance::Zone.
      TClass *R__cl = ::Smear::Acceptance::Zone::IsA();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "thetaMin", &thetaMin);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "thetaMax", &thetaMax);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "phiMin", &phiMin);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "phiMax", &phiMax);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "EMin", &EMin);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "EMax", &EMax);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "PMin", &PMin);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "PMax", &PMax);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "pTMin", &pTMin);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "pTMax", &pTMax);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "pZMin", &pZMin);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "pZMax", &pZMax);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "CustomCuts", (void*)&CustomCuts);
      R__insp.InspectMember("vector<Smear::Acceptance::CustomCut>", (void*)&CustomCuts, "CustomCuts.", false);
}

} // namespace Smear
namespace ROOTDict {
   // Wrappers around operator new
   static void *new_SmearcLcLAcceptancecLcLZone(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Smear::Acceptance::Zone : new ::Smear::Acceptance::Zone;
   }
   static void *newArray_SmearcLcLAcceptancecLcLZone(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Smear::Acceptance::Zone[nElements] : new ::Smear::Acceptance::Zone[nElements];
   }
   // Wrapper around operator delete
   static void delete_SmearcLcLAcceptancecLcLZone(void *p) {
      delete ((::Smear::Acceptance::Zone*)p);
   }
   static void deleteArray_SmearcLcLAcceptancecLcLZone(void *p) {
      delete [] ((::Smear::Acceptance::Zone*)p);
   }
   static void destruct_SmearcLcLAcceptancecLcLZone(void *p) {
      typedef ::Smear::Acceptance::Zone current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::Smear::Acceptance::Zone

      namespace Smear {
//______________________________________________________________________________
void Detector::Streamer(TBuffer &R__b)
{
   // Stream an object of class Smear::Detector.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(Smear::Detector::Class(),this);
   } else {
      R__b.WriteClassBuffer(Smear::Detector::Class(),this);
   }
}

} // namespace Smear
//______________________________________________________________________________
      namespace Smear {
void Detector::ShowMembers(TMemberInspector &R__insp)
{
      // Inspect the data members of an object of class Smear::Detector.
      TClass *R__cl = ::Smear::Detector::IsA();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "useNM", &useNM);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "useJB", &useJB);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "useDA", &useDA);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Devices", (void*)&Devices);
      R__insp.InspectMember("vector<Smear::Smearer*,allocator<Smear::Smearer*> >", (void*)&Devices, "Devices.", false);
      TObject::ShowMembers(R__insp);
}

} // namespace Smear
namespace ROOTDict {
   // Wrappers around operator new
   static void *new_SmearcLcLDetector(void *p) {
      return  p ? new(p) ::Smear::Detector : new ::Smear::Detector;
   }
   static void *newArray_SmearcLcLDetector(Long_t nElements, void *p) {
      return p ? new(p) ::Smear::Detector[nElements] : new ::Smear::Detector[nElements];
   }
   // Wrapper around operator delete
   static void delete_SmearcLcLDetector(void *p) {
      delete ((::Smear::Detector*)p);
   }
   static void deleteArray_SmearcLcLDetector(void *p) {
      delete [] ((::Smear::Detector*)p);
   }
   static void destruct_SmearcLcLDetector(void *p) {
      typedef ::Smear::Detector current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::Smear::Detector

      namespace Smear {
//______________________________________________________________________________
void Distributor::Streamer(TBuffer &R__b)
{
   // Stream an object of class Smear::Distributor.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(Smear::Distributor::Class(),this);
   } else {
      R__b.WriteClassBuffer(Smear::Distributor::Class(),this);
   }
}

} // namespace Smear
//______________________________________________________________________________
      namespace Smear {
void Distributor::ShowMembers(TMemberInspector &R__insp)
{
      // Inspect the data members of an object of class Smear::Distributor.
      TClass *R__cl = ::Smear::Distributor::IsA();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "mPlus", &mPlus);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "mMinus", &mMinus);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*mDistribution", &mDistribution);
}

} // namespace Smear
namespace ROOTDict {
   // Wrappers around operator new
   static void *new_SmearcLcLDistributor(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Smear::Distributor : new ::Smear::Distributor;
   }
   static void *newArray_SmearcLcLDistributor(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Smear::Distributor[nElements] : new ::Smear::Distributor[nElements];
   }
   // Wrapper around operator delete
   static void delete_SmearcLcLDistributor(void *p) {
      delete ((::Smear::Distributor*)p);
   }
   static void deleteArray_SmearcLcLDistributor(void *p) {
      delete [] ((::Smear::Distributor*)p);
   }
   static void destruct_SmearcLcLDistributor(void *p) {
      typedef ::Smear::Distributor current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::Smear::Distributor

      namespace Smear {
//______________________________________________________________________________
void FormulaString::Streamer(TBuffer &R__b)
{
   // Stream an object of class Smear::FormulaString.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(Smear::FormulaString::Class(),this);
   } else {
      R__b.WriteClassBuffer(Smear::FormulaString::Class(),this);
   }
}

} // namespace Smear
//______________________________________________________________________________
      namespace Smear {
void FormulaString::ShowMembers(TMemberInspector &R__insp)
{
      // Inspect the data members of an object of class Smear::FormulaString.
      TClass *R__cl = ::Smear::FormulaString::IsA();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*mFormula", &mFormula);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "mInput", (void*)&mInput);
      R__insp.InspectMember("string", (void*)&mInput, "mInput.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "mVariables", (void*)&mVariables);
      R__insp.InspectMember("vector<Smear::KinType>", (void*)&mVariables, "mVariables.", false);
      TObject::ShowMembers(R__insp);
}

} // namespace Smear
namespace ROOTDict {
   // Wrappers around operator new
   static void *new_SmearcLcLFormulaString(void *p) {
      return  p ? new(p) ::Smear::FormulaString : new ::Smear::FormulaString;
   }
   static void *newArray_SmearcLcLFormulaString(Long_t nElements, void *p) {
      return p ? new(p) ::Smear::FormulaString[nElements] : new ::Smear::FormulaString[nElements];
   }
   // Wrapper around operator delete
   static void delete_SmearcLcLFormulaString(void *p) {
      delete ((::Smear::FormulaString*)p);
   }
   static void deleteArray_SmearcLcLFormulaString(void *p) {
      delete [] ((::Smear::FormulaString*)p);
   }
   static void destruct_SmearcLcLFormulaString(void *p) {
      typedef ::Smear::FormulaString current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::Smear::FormulaString

      namespace Smear {
//______________________________________________________________________________
void ParticleID::Streamer(TBuffer &R__b)
{
   // Stream an object of class Smear::ParticleID.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(Smear::ParticleID::Class(),this);
   } else {
      R__b.WriteClassBuffer(Smear::ParticleID::Class(),this);
   }
}

} // namespace Smear
//______________________________________________________________________________
      namespace Smear {
void ParticleID::ShowMembers(TMemberInspector &R__insp)
{
      // Inspect the data members of an object of class Smear::ParticleID.
      TClass *R__cl = ::Smear::ParticleID::IsA();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Ran", &Ran);
      R__insp.InspectMember(Ran, "Ran.");
      R__insp.Inspect(R__cl, R__insp.GetParent(), "PMatPath", &PMatPath);
      R__insp.InspectMember(PMatPath, "PMatPath.");
      R__insp.Inspect(R__cl, R__insp.GetParent(), "TrueIdent", (void*)&TrueIdent);
      R__insp.InspectMember("vector<int>", (void*)&TrueIdent, "TrueIdent.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "FalseIdent", (void*)&FalseIdent);
      R__insp.InspectMember("vector<int>", (void*)&FalseIdent, "FalseIdent.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "PMin", (void*)&PMin);
      R__insp.InspectMember("vector<double>", (void*)&PMin, "PMin.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "PMax", (void*)&PMax);
      R__insp.InspectMember("vector<double>", (void*)&PMax, "PMax.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "PMatrix", (void*)&PMatrix);
      R__insp.InspectMember("vector<std::vector<std::vector<double> > >", (void*)&PMatrix, "PMatrix.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Range", (void*)&Range);
      R__insp.InspectMember("vector<std::vector<std::vector<double> > >", (void*)&Range, "Range.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "bUseMC", &bUseMC);
      //This works around a msvc bug and should be harmless on other platforms
      typedef Smear::Smearer baseClass1;
      baseClass1::ShowMembers(R__insp);
}

} // namespace Smear
namespace ROOTDict {
   // Wrappers around operator new
   static void *new_SmearcLcLParticleID(void *p) {
      return  p ? new(p) ::Smear::ParticleID : new ::Smear::ParticleID;
   }
   static void *newArray_SmearcLcLParticleID(Long_t nElements, void *p) {
      return p ? new(p) ::Smear::ParticleID[nElements] : new ::Smear::ParticleID[nElements];
   }
   // Wrapper around operator delete
   static void delete_SmearcLcLParticleID(void *p) {
      delete ((::Smear::ParticleID*)p);
   }
   static void deleteArray_SmearcLcLParticleID(void *p) {
      delete [] ((::Smear::ParticleID*)p);
   }
   static void destruct_SmearcLcLParticleID(void *p) {
      typedef ::Smear::ParticleID current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::Smear::ParticleID

      namespace Smear {
//______________________________________________________________________________
void PerfectID::Streamer(TBuffer &R__b)
{
   // Stream an object of class Smear::PerfectID.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(Smear::PerfectID::Class(),this);
   } else {
      R__b.WriteClassBuffer(Smear::PerfectID::Class(),this);
   }
}

} // namespace Smear
//______________________________________________________________________________
      namespace Smear {
void PerfectID::ShowMembers(TMemberInspector &R__insp)
{
      // Inspect the data members of an object of class Smear::PerfectID.
      TClass *R__cl = ::Smear::PerfectID::IsA();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "mPdg", (void*)&mPdg);
      R__insp.InspectMember("set<Int_t>", (void*)&mPdg, "mPdg.", false);
      //This works around a msvc bug and should be harmless on other platforms
      typedef Smear::Smearer baseClass1;
      baseClass1::ShowMembers(R__insp);
}

} // namespace Smear
namespace ROOTDict {
   // Wrappers around operator new
   static void *new_SmearcLcLPerfectID(void *p) {
      return  p ? new(p) ::Smear::PerfectID : new ::Smear::PerfectID;
   }
   static void *newArray_SmearcLcLPerfectID(Long_t nElements, void *p) {
      return p ? new(p) ::Smear::PerfectID[nElements] : new ::Smear::PerfectID[nElements];
   }
   // Wrapper around operator delete
   static void delete_SmearcLcLPerfectID(void *p) {
      delete ((::Smear::PerfectID*)p);
   }
   static void deleteArray_SmearcLcLPerfectID(void *p) {
      delete [] ((::Smear::PerfectID*)p);
   }
   static void destruct_SmearcLcLPerfectID(void *p) {
      typedef ::Smear::PerfectID current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::Smear::PerfectID

      namespace Smear {
//______________________________________________________________________________
void Smearer::Streamer(TBuffer &R__b)
{
   // Stream an object of class Smear::Smearer.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(Smear::Smearer::Class(),this);
   } else {
      R__b.WriteClassBuffer(Smear::Smearer::Class(),this);
   }
}

} // namespace Smear
//______________________________________________________________________________
      namespace Smear {
void Smearer::ShowMembers(TMemberInspector &R__insp)
{
      // Inspect the data members of an object of class Smear::Smearer.
      TClass *R__cl = ::Smear::Smearer::IsA();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Accept", &Accept);
      R__insp.InspectMember(Accept, "Accept.");
      TObject::ShowMembers(R__insp);
}

} // namespace Smear
namespace ROOTDict {
   // Wrapper around operator delete
   static void delete_SmearcLcLSmearer(void *p) {
      delete ((::Smear::Smearer*)p);
   }
   static void deleteArray_SmearcLcLSmearer(void *p) {
      delete [] ((::Smear::Smearer*)p);
   }
   static void destruct_SmearcLcLSmearer(void *p) {
      typedef ::Smear::Smearer current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::Smear::Smearer

      namespace Smear {
//______________________________________________________________________________
void Bremsstrahlung::Streamer(TBuffer &R__b)
{
   // Stream an object of class Smear::Bremsstrahlung.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(Smear::Bremsstrahlung::Class(),this);
   } else {
      R__b.WriteClassBuffer(Smear::Bremsstrahlung::Class(),this);
   }
}

} // namespace Smear
//______________________________________________________________________________
      namespace Smear {
void Bremsstrahlung::ShowMembers(TMemberInspector &R__insp)
{
      // Inspect the data members of an object of class Smear::Bremsstrahlung.
      TClass *R__cl = ::Smear::Bremsstrahlung::IsA();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "mParticle", (void*)&mParticle);
      R__insp.InspectMember("auto_ptr<erhic::ParticleMC>", (void*)&mParticle, "mParticle.", true);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "mKMin", &mKMin);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "mKMax", &mKMax);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "mEpsilon", &mEpsilon);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "mTraversed", &mTraversed);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "mRadLength", &mRadLength);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*mPdf", &mPdf);
      //This works around a msvc bug and should be harmless on other platforms
      typedef Smear::Device baseClass1;
      baseClass1::ShowMembers(R__insp);
}

} // namespace Smear
namespace ROOTDict {
   // Wrappers around operator new
   static void *new_SmearcLcLBremsstrahlung(void *p) {
      return  p ? new(p) ::Smear::Bremsstrahlung : new ::Smear::Bremsstrahlung;
   }
   static void *newArray_SmearcLcLBremsstrahlung(Long_t nElements, void *p) {
      return p ? new(p) ::Smear::Bremsstrahlung[nElements] : new ::Smear::Bremsstrahlung[nElements];
   }
   // Wrapper around operator delete
   static void delete_SmearcLcLBremsstrahlung(void *p) {
      delete ((::Smear::Bremsstrahlung*)p);
   }
   static void deleteArray_SmearcLcLBremsstrahlung(void *p) {
      delete [] ((::Smear::Bremsstrahlung*)p);
   }
   static void destruct_SmearcLcLBremsstrahlung(void *p) {
      typedef ::Smear::Bremsstrahlung current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::Smear::Bremsstrahlung

      namespace Smear {
//______________________________________________________________________________
void Device::Streamer(TBuffer &R__b)
{
   // Stream an object of class Smear::Device.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(Smear::Device::Class(),this);
   } else {
      R__b.WriteClassBuffer(Smear::Device::Class(),this);
   }
}

} // namespace Smear
//______________________________________________________________________________
      namespace Smear {
void Device::ShowMembers(TMemberInspector &R__insp)
{
      // Inspect the data members of an object of class Smear::Device.
      TClass *R__cl = ::Smear::Device::IsA();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "mSmeared", &mSmeared);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*mKinematicFunction", &mKinematicFunction);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*mFormula", &mFormula);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "mDimensions", (void*)&mDimensions);
      R__insp.InspectMember("vector<Smear::KinType>", (void*)&mDimensions, "mDimensions.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "mDistribution", &mDistribution);
      R__insp.InspectMember(mDistribution, "mDistribution.");
      //This works around a msvc bug and should be harmless on other platforms
      typedef Smear::Smearer baseClass1;
      baseClass1::ShowMembers(R__insp);
}

} // namespace Smear
namespace ROOTDict {
   // Wrappers around operator new
   static void *new_SmearcLcLDevice(void *p) {
      return  p ? new(p) ::Smear::Device : new ::Smear::Device;
   }
   static void *newArray_SmearcLcLDevice(Long_t nElements, void *p) {
      return p ? new(p) ::Smear::Device[nElements] : new ::Smear::Device[nElements];
   }
   // Wrapper around operator delete
   static void delete_SmearcLcLDevice(void *p) {
      delete ((::Smear::Device*)p);
   }
   static void deleteArray_SmearcLcLDevice(void *p) {
      delete [] ((::Smear::Device*)p);
   }
   static void destruct_SmearcLcLDevice(void *p) {
      typedef ::Smear::Device current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::Smear::Device

      namespace Smear {
//______________________________________________________________________________
void Tracker::Streamer(TBuffer &R__b)
{
   // Stream an object of class Smear::Tracker.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(Smear::Tracker::Class(),this);
   } else {
      R__b.WriteClassBuffer(Smear::Tracker::Class(),this);
   }
}

} // namespace Smear
//______________________________________________________________________________
      namespace Smear {
void Tracker::ShowMembers(TMemberInspector &R__insp)
{
      // Inspect the data members of an object of class Smear::Tracker.
      TClass *R__cl = ::Smear::Tracker::IsA();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "mFactor", &mFactor);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "mMagField", &mMagField);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "mNRadLengths", &mNRadLengths);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "mSigmaRPhi", &mSigmaRPhi);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Distribution", &Distribution);
      R__insp.InspectMember(Distribution, "Distribution.");
      //This works around a msvc bug and should be harmless on other platforms
      typedef Smear::Smearer baseClass1;
      baseClass1::ShowMembers(R__insp);
}

} // namespace Smear
namespace ROOTDict {
   // Wrapper around operator delete
   static void delete_SmearcLcLTracker(void *p) {
      delete ((::Smear::Tracker*)p);
   }
   static void deleteArray_SmearcLcLTracker(void *p) {
      delete [] ((::Smear::Tracker*)p);
   }
   static void destruct_SmearcLcLTracker(void *p) {
      typedef ::Smear::Tracker current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::Smear::Tracker

      namespace Smear {
//______________________________________________________________________________
void PlanarTracker::Streamer(TBuffer &R__b)
{
   // Stream an object of class Smear::PlanarTracker.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(Smear::PlanarTracker::Class(),this);
   } else {
      R__b.WriteClassBuffer(Smear::PlanarTracker::Class(),this);
   }
}

} // namespace Smear
//______________________________________________________________________________
      namespace Smear {
void PlanarTracker::ShowMembers(TMemberInspector &R__insp)
{
      // Inspect the data members of an object of class Smear::PlanarTracker.
      TClass *R__cl = ::Smear::PlanarTracker::IsA();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "mNPlanes", &mNPlanes);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "mInnerRadius", &mInnerRadius);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "mOuterRadius", &mOuterRadius);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "mZMin", &mZMin);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "mZMax", &mZMax);
      //This works around a msvc bug and should be harmless on other platforms
      typedef Smear::Tracker baseClass1;
      baseClass1::ShowMembers(R__insp);
}

} // namespace Smear
namespace ROOTDict {
   // Wrappers around operator new
   static void *new_SmearcLcLPlanarTracker(void *p) {
      return  p ? new(p) ::Smear::PlanarTracker : new ::Smear::PlanarTracker;
   }
   static void *newArray_SmearcLcLPlanarTracker(Long_t nElements, void *p) {
      return p ? new(p) ::Smear::PlanarTracker[nElements] : new ::Smear::PlanarTracker[nElements];
   }
   // Wrapper around operator delete
   static void delete_SmearcLcLPlanarTracker(void *p) {
      delete ((::Smear::PlanarTracker*)p);
   }
   static void deleteArray_SmearcLcLPlanarTracker(void *p) {
      delete [] ((::Smear::PlanarTracker*)p);
   }
   static void destruct_SmearcLcLPlanarTracker(void *p) {
      typedef ::Smear::PlanarTracker current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::Smear::PlanarTracker

      namespace Smear {
//______________________________________________________________________________
void RadialTracker::Streamer(TBuffer &R__b)
{
   // Stream an object of class Smear::RadialTracker.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(Smear::RadialTracker::Class(),this);
   } else {
      R__b.WriteClassBuffer(Smear::RadialTracker::Class(),this);
   }
}

} // namespace Smear
//______________________________________________________________________________
      namespace Smear {
void RadialTracker::ShowMembers(TMemberInspector &R__insp)
{
      // Inspect the data members of an object of class Smear::RadialTracker.
      TClass *R__cl = ::Smear::RadialTracker::IsA();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "mNFitPoints", &mNFitPoints);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "mInnerRadius", &mInnerRadius);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "mOuterRadius", &mOuterRadius);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "mZMin", &mZMin);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "mZMax", &mZMax);
      //This works around a msvc bug and should be harmless on other platforms
      typedef Smear::Tracker baseClass1;
      baseClass1::ShowMembers(R__insp);
}

} // namespace Smear
namespace ROOTDict {
   // Wrappers around operator new
   static void *new_SmearcLcLRadialTracker(void *p) {
      return  p ? new(p) ::Smear::RadialTracker : new ::Smear::RadialTracker;
   }
   static void *newArray_SmearcLcLRadialTracker(Long_t nElements, void *p) {
      return p ? new(p) ::Smear::RadialTracker[nElements] : new ::Smear::RadialTracker[nElements];
   }
   // Wrapper around operator delete
   static void delete_SmearcLcLRadialTracker(void *p) {
      delete ((::Smear::RadialTracker*)p);
   }
   static void deleteArray_SmearcLcLRadialTracker(void *p) {
      delete [] ((::Smear::RadialTracker*)p);
   }
   static void destruct_SmearcLcLRadialTracker(void *p) {
      typedef ::Smear::RadialTracker current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::Smear::RadialTracker

//______________________________________________________________________________
namespace ROOTDict {
   void auto_ptrlEerhiccLcLParticleMCgR_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class auto_ptr<erhic::ParticleMC>.
      typedef ::ROOTShadow::Shadow::auto_ptrlEerhiccLcLParticleMCgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOTDict::GenerateInitInstanceLocal((const auto_ptr<erhic::ParticleMC>*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*ptr", &sobj->ptr);
   }

}

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_auto_ptrlEerhiccLcLParticleMCgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) auto_ptr<erhic::ParticleMC> : new auto_ptr<erhic::ParticleMC>;
   }
   static void *newArray_auto_ptrlEerhiccLcLParticleMCgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) auto_ptr<erhic::ParticleMC>[nElements] : new auto_ptr<erhic::ParticleMC>[nElements];
   }
   // Wrapper around operator delete
   static void delete_auto_ptrlEerhiccLcLParticleMCgR(void *p) {
      delete ((auto_ptr<erhic::ParticleMC>*)p);
   }
   static void deleteArray_auto_ptrlEerhiccLcLParticleMCgR(void *p) {
      delete [] ((auto_ptr<erhic::ParticleMC>*)p);
   }
   static void destruct_auto_ptrlEerhiccLcLParticleMCgR(void *p) {
      typedef auto_ptr<erhic::ParticleMC> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class auto_ptr<erhic::ParticleMC>

namespace ROOTDict {
   void setlEintgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void setlEintgR_Dictionary();
   static void *new_setlEintgR(void *p = 0);
   static void *newArray_setlEintgR(Long_t size, void *p);
   static void delete_setlEintgR(void *p);
   static void deleteArray_setlEintgR(void *p);
   static void destruct_setlEintgR(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const set<int>*)
   {
      set<int> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(set<int>),0);
      static ::ROOT::TGenericClassInfo 
         instance("set<int>", -2, "set.dll", 0,
                  typeid(set<int>), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &setlEintgR_Dictionary, isa_proxy, 0,
                  sizeof(set<int>) );
      instance.SetNew(&new_setlEintgR);
      instance.SetNewArray(&newArray_setlEintgR);
      instance.SetDelete(&delete_setlEintgR);
      instance.SetDeleteArray(&deleteArray_setlEintgR);
      instance.SetDestructor(&destruct_setlEintgR);
      instance.AdoptCollectionProxyInfo( ::ROOT::TCollectionProxyInfo::Generate( ::ROOT::TCollectionProxyInfo::Insert< set<int> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const set<int>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void setlEintgR_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const set<int>*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_setlEintgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) set<int> : new set<int>;
   }
   static void *newArray_setlEintgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) set<int>[nElements] : new set<int>[nElements];
   }
   // Wrapper around operator delete
   static void delete_setlEintgR(void *p) {
      delete ((set<int>*)p);
   }
   static void deleteArray_setlEintgR(void *p) {
      delete [] ((set<int>*)p);
   }
   static void destruct_setlEintgR(void *p) {
      typedef set<int> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class set<int>

namespace ROOTDict {
   void vectorlESmearcLcLAcceptancecLcLCustomCutgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlESmearcLcLAcceptancecLcLCustomCutgR_Dictionary();
   static void *new_vectorlESmearcLcLAcceptancecLcLCustomCutgR(void *p = 0);
   static void *newArray_vectorlESmearcLcLAcceptancecLcLCustomCutgR(Long_t size, void *p);
   static void delete_vectorlESmearcLcLAcceptancecLcLCustomCutgR(void *p);
   static void deleteArray_vectorlESmearcLcLAcceptancecLcLCustomCutgR(void *p);
   static void destruct_vectorlESmearcLcLAcceptancecLcLCustomCutgR(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const vector<Smear::Acceptance::CustomCut>*)
   {
      vector<Smear::Acceptance::CustomCut> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<Smear::Acceptance::CustomCut>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<Smear::Acceptance::CustomCut>", -2, "prec_stl/vector", 49,
                  typeid(vector<Smear::Acceptance::CustomCut>), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &vectorlESmearcLcLAcceptancecLcLCustomCutgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<Smear::Acceptance::CustomCut>) );
      instance.SetNew(&new_vectorlESmearcLcLAcceptancecLcLCustomCutgR);
      instance.SetNewArray(&newArray_vectorlESmearcLcLAcceptancecLcLCustomCutgR);
      instance.SetDelete(&delete_vectorlESmearcLcLAcceptancecLcLCustomCutgR);
      instance.SetDeleteArray(&deleteArray_vectorlESmearcLcLAcceptancecLcLCustomCutgR);
      instance.SetDestructor(&destruct_vectorlESmearcLcLAcceptancecLcLCustomCutgR);
      instance.AdoptCollectionProxyInfo( ::ROOT::TCollectionProxyInfo::Generate( ::ROOT::TCollectionProxyInfo::Pushback< vector<Smear::Acceptance::CustomCut> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<Smear::Acceptance::CustomCut>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlESmearcLcLAcceptancecLcLCustomCutgR_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const vector<Smear::Acceptance::CustomCut>*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_vectorlESmearcLcLAcceptancecLcLCustomCutgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<Smear::Acceptance::CustomCut> : new vector<Smear::Acceptance::CustomCut>;
   }
   static void *newArray_vectorlESmearcLcLAcceptancecLcLCustomCutgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<Smear::Acceptance::CustomCut>[nElements] : new vector<Smear::Acceptance::CustomCut>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlESmearcLcLAcceptancecLcLCustomCutgR(void *p) {
      delete ((vector<Smear::Acceptance::CustomCut>*)p);
   }
   static void deleteArray_vectorlESmearcLcLAcceptancecLcLCustomCutgR(void *p) {
      delete [] ((vector<Smear::Acceptance::CustomCut>*)p);
   }
   static void destruct_vectorlESmearcLcLAcceptancecLcLCustomCutgR(void *p) {
      typedef vector<Smear::Acceptance::CustomCut> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class vector<Smear::Acceptance::CustomCut>

namespace ROOTDict {
   void vectorlESmearcLcLAcceptancecLcLZonegR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlESmearcLcLAcceptancecLcLZonegR_Dictionary();
   static void *new_vectorlESmearcLcLAcceptancecLcLZonegR(void *p = 0);
   static void *newArray_vectorlESmearcLcLAcceptancecLcLZonegR(Long_t size, void *p);
   static void delete_vectorlESmearcLcLAcceptancecLcLZonegR(void *p);
   static void deleteArray_vectorlESmearcLcLAcceptancecLcLZonegR(void *p);
   static void destruct_vectorlESmearcLcLAcceptancecLcLZonegR(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const vector<Smear::Acceptance::Zone>*)
   {
      vector<Smear::Acceptance::Zone> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<Smear::Acceptance::Zone>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<Smear::Acceptance::Zone>", -2, "prec_stl/vector", 49,
                  typeid(vector<Smear::Acceptance::Zone>), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &vectorlESmearcLcLAcceptancecLcLZonegR_Dictionary, isa_proxy, 0,
                  sizeof(vector<Smear::Acceptance::Zone>) );
      instance.SetNew(&new_vectorlESmearcLcLAcceptancecLcLZonegR);
      instance.SetNewArray(&newArray_vectorlESmearcLcLAcceptancecLcLZonegR);
      instance.SetDelete(&delete_vectorlESmearcLcLAcceptancecLcLZonegR);
      instance.SetDeleteArray(&deleteArray_vectorlESmearcLcLAcceptancecLcLZonegR);
      instance.SetDestructor(&destruct_vectorlESmearcLcLAcceptancecLcLZonegR);
      instance.AdoptCollectionProxyInfo( ::ROOT::TCollectionProxyInfo::Generate( ::ROOT::TCollectionProxyInfo::Pushback< vector<Smear::Acceptance::Zone> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<Smear::Acceptance::Zone>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlESmearcLcLAcceptancecLcLZonegR_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const vector<Smear::Acceptance::Zone>*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_vectorlESmearcLcLAcceptancecLcLZonegR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<Smear::Acceptance::Zone> : new vector<Smear::Acceptance::Zone>;
   }
   static void *newArray_vectorlESmearcLcLAcceptancecLcLZonegR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<Smear::Acceptance::Zone>[nElements] : new vector<Smear::Acceptance::Zone>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlESmearcLcLAcceptancecLcLZonegR(void *p) {
      delete ((vector<Smear::Acceptance::Zone>*)p);
   }
   static void deleteArray_vectorlESmearcLcLAcceptancecLcLZonegR(void *p) {
      delete [] ((vector<Smear::Acceptance::Zone>*)p);
   }
   static void destruct_vectorlESmearcLcLAcceptancecLcLZonegR(void *p) {
      typedef vector<Smear::Acceptance::Zone> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class vector<Smear::Acceptance::Zone>

namespace ROOTDict {
   void vectorlESmearcLcLKinTypegR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlESmearcLcLKinTypegR_Dictionary();
   static void *new_vectorlESmearcLcLKinTypegR(void *p = 0);
   static void *newArray_vectorlESmearcLcLKinTypegR(Long_t size, void *p);
   static void delete_vectorlESmearcLcLKinTypegR(void *p);
   static void deleteArray_vectorlESmearcLcLKinTypegR(void *p);
   static void destruct_vectorlESmearcLcLKinTypegR(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const vector<Smear::KinType>*)
   {
      vector<Smear::KinType> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<Smear::KinType>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<Smear::KinType>", -2, "prec_stl/vector", 49,
                  typeid(vector<Smear::KinType>), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &vectorlESmearcLcLKinTypegR_Dictionary, isa_proxy, 0,
                  sizeof(vector<Smear::KinType>) );
      instance.SetNew(&new_vectorlESmearcLcLKinTypegR);
      instance.SetNewArray(&newArray_vectorlESmearcLcLKinTypegR);
      instance.SetDelete(&delete_vectorlESmearcLcLKinTypegR);
      instance.SetDeleteArray(&deleteArray_vectorlESmearcLcLKinTypegR);
      instance.SetDestructor(&destruct_vectorlESmearcLcLKinTypegR);
      instance.AdoptCollectionProxyInfo( ::ROOT::TCollectionProxyInfo::Generate( ::ROOT::TCollectionProxyInfo::Pushback< vector<Smear::KinType> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<Smear::KinType>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlESmearcLcLKinTypegR_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const vector<Smear::KinType>*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_vectorlESmearcLcLKinTypegR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<Smear::KinType> : new vector<Smear::KinType>;
   }
   static void *newArray_vectorlESmearcLcLKinTypegR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<Smear::KinType>[nElements] : new vector<Smear::KinType>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlESmearcLcLKinTypegR(void *p) {
      delete ((vector<Smear::KinType>*)p);
   }
   static void deleteArray_vectorlESmearcLcLKinTypegR(void *p) {
      delete [] ((vector<Smear::KinType>*)p);
   }
   static void destruct_vectorlESmearcLcLKinTypegR(void *p) {
      typedef vector<Smear::KinType> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class vector<Smear::KinType>

namespace ROOTDict {
   void vectorlESmearcLcLParticleMCSmUgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlESmearcLcLParticleMCSmUgR_Dictionary();
   static void *new_vectorlESmearcLcLParticleMCSmUgR(void *p = 0);
   static void *newArray_vectorlESmearcLcLParticleMCSmUgR(Long_t size, void *p);
   static void delete_vectorlESmearcLcLParticleMCSmUgR(void *p);
   static void deleteArray_vectorlESmearcLcLParticleMCSmUgR(void *p);
   static void destruct_vectorlESmearcLcLParticleMCSmUgR(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const vector<Smear::ParticleMCS*>*)
   {
      vector<Smear::ParticleMCS*> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<Smear::ParticleMCS*>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<Smear::ParticleMCS*>", -2, "prec_stl/vector", 49,
                  typeid(vector<Smear::ParticleMCS*>), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &vectorlESmearcLcLParticleMCSmUgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<Smear::ParticleMCS*>) );
      instance.SetNew(&new_vectorlESmearcLcLParticleMCSmUgR);
      instance.SetNewArray(&newArray_vectorlESmearcLcLParticleMCSmUgR);
      instance.SetDelete(&delete_vectorlESmearcLcLParticleMCSmUgR);
      instance.SetDeleteArray(&deleteArray_vectorlESmearcLcLParticleMCSmUgR);
      instance.SetDestructor(&destruct_vectorlESmearcLcLParticleMCSmUgR);
      instance.AdoptCollectionProxyInfo( ::ROOT::TCollectionProxyInfo::Generate( ::ROOT::TCollectionProxyInfo::Pushback< vector<Smear::ParticleMCS*> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<Smear::ParticleMCS*>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlESmearcLcLParticleMCSmUgR_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const vector<Smear::ParticleMCS*>*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_vectorlESmearcLcLParticleMCSmUgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<Smear::ParticleMCS*> : new vector<Smear::ParticleMCS*>;
   }
   static void *newArray_vectorlESmearcLcLParticleMCSmUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<Smear::ParticleMCS*>[nElements] : new vector<Smear::ParticleMCS*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlESmearcLcLParticleMCSmUgR(void *p) {
      delete ((vector<Smear::ParticleMCS*>*)p);
   }
   static void deleteArray_vectorlESmearcLcLParticleMCSmUgR(void *p) {
      delete [] ((vector<Smear::ParticleMCS*>*)p);
   }
   static void destruct_vectorlESmearcLcLParticleMCSmUgR(void *p) {
      typedef vector<Smear::ParticleMCS*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class vector<Smear::ParticleMCS*>

namespace ROOTDict {
   void vectorlESmearcLcLSmearermUgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlESmearcLcLSmearermUgR_Dictionary();
   static void *new_vectorlESmearcLcLSmearermUgR(void *p = 0);
   static void *newArray_vectorlESmearcLcLSmearermUgR(Long_t size, void *p);
   static void delete_vectorlESmearcLcLSmearermUgR(void *p);
   static void deleteArray_vectorlESmearcLcLSmearermUgR(void *p);
   static void destruct_vectorlESmearcLcLSmearermUgR(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const vector<Smear::Smearer*>*)
   {
      vector<Smear::Smearer*> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<Smear::Smearer*>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<Smear::Smearer*>", -2, "prec_stl/vector", 49,
                  typeid(vector<Smear::Smearer*>), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &vectorlESmearcLcLSmearermUgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<Smear::Smearer*>) );
      instance.SetNew(&new_vectorlESmearcLcLSmearermUgR);
      instance.SetNewArray(&newArray_vectorlESmearcLcLSmearermUgR);
      instance.SetDelete(&delete_vectorlESmearcLcLSmearermUgR);
      instance.SetDeleteArray(&deleteArray_vectorlESmearcLcLSmearermUgR);
      instance.SetDestructor(&destruct_vectorlESmearcLcLSmearermUgR);
      instance.AdoptCollectionProxyInfo( ::ROOT::TCollectionProxyInfo::Generate( ::ROOT::TCollectionProxyInfo::Pushback< vector<Smear::Smearer*> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<Smear::Smearer*>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlESmearcLcLSmearermUgR_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const vector<Smear::Smearer*>*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_vectorlESmearcLcLSmearermUgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<Smear::Smearer*> : new vector<Smear::Smearer*>;
   }
   static void *newArray_vectorlESmearcLcLSmearermUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<Smear::Smearer*>[nElements] : new vector<Smear::Smearer*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlESmearcLcLSmearermUgR(void *p) {
      delete ((vector<Smear::Smearer*>*)p);
   }
   static void deleteArray_vectorlESmearcLcLSmearermUgR(void *p) {
      delete [] ((vector<Smear::Smearer*>*)p);
   }
   static void destruct_vectorlESmearcLcLSmearermUgR(void *p) {
      typedef vector<Smear::Smearer*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class vector<Smear::Smearer*>

namespace ROOTDict {
   void vectorlEdoublegR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEdoublegR_Dictionary();
   static void *new_vectorlEdoublegR(void *p = 0);
   static void *newArray_vectorlEdoublegR(Long_t size, void *p);
   static void delete_vectorlEdoublegR(void *p);
   static void deleteArray_vectorlEdoublegR(void *p);
   static void destruct_vectorlEdoublegR(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const vector<double>*)
   {
      vector<double> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<double>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<double>", -2, "vector.dll", 0,
                  typeid(vector<double>), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &vectorlEdoublegR_Dictionary, isa_proxy, 0,
                  sizeof(vector<double>) );
      instance.SetNew(&new_vectorlEdoublegR);
      instance.SetNewArray(&newArray_vectorlEdoublegR);
      instance.SetDelete(&delete_vectorlEdoublegR);
      instance.SetDeleteArray(&deleteArray_vectorlEdoublegR);
      instance.SetDestructor(&destruct_vectorlEdoublegR);
      instance.AdoptCollectionProxyInfo( ::ROOT::TCollectionProxyInfo::Generate( ::ROOT::TCollectionProxyInfo::Pushback< vector<double> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<double>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEdoublegR_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const vector<double>*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_vectorlEdoublegR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<double> : new vector<double>;
   }
   static void *newArray_vectorlEdoublegR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<double>[nElements] : new vector<double>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEdoublegR(void *p) {
      delete ((vector<double>*)p);
   }
   static void deleteArray_vectorlEdoublegR(void *p) {
      delete [] ((vector<double>*)p);
   }
   static void destruct_vectorlEdoublegR(void *p) {
      typedef vector<double> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class vector<double>

namespace ROOTDict {
   void vectorlEintgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEintgR_Dictionary();
   static void *new_vectorlEintgR(void *p = 0);
   static void *newArray_vectorlEintgR(Long_t size, void *p);
   static void delete_vectorlEintgR(void *p);
   static void deleteArray_vectorlEintgR(void *p);
   static void destruct_vectorlEintgR(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const vector<int>*)
   {
      vector<int> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<int>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<int>", -2, "prec_stl/vector", 49,
                  typeid(vector<int>), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &vectorlEintgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<int>) );
      instance.SetNew(&new_vectorlEintgR);
      instance.SetNewArray(&newArray_vectorlEintgR);
      instance.SetDelete(&delete_vectorlEintgR);
      instance.SetDeleteArray(&deleteArray_vectorlEintgR);
      instance.SetDestructor(&destruct_vectorlEintgR);
      instance.AdoptCollectionProxyInfo( ::ROOT::TCollectionProxyInfo::Generate( ::ROOT::TCollectionProxyInfo::Pushback< vector<int> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<int>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEintgR_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const vector<int>*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_vectorlEintgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<int> : new vector<int>;
   }
   static void *newArray_vectorlEintgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<int>[nElements] : new vector<int>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEintgR(void *p) {
      delete ((vector<int>*)p);
   }
   static void deleteArray_vectorlEintgR(void *p) {
      delete [] ((vector<int>*)p);
   }
   static void destruct_vectorlEintgR(void *p) {
      typedef vector<int> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class vector<int>

namespace ROOTDict {
   void vectorlEvectorlEdoublegRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEvectorlEdoublegRsPgR_Dictionary();
   static void *new_vectorlEvectorlEdoublegRsPgR(void *p = 0);
   static void *newArray_vectorlEvectorlEdoublegRsPgR(Long_t size, void *p);
   static void delete_vectorlEvectorlEdoublegRsPgR(void *p);
   static void deleteArray_vectorlEvectorlEdoublegRsPgR(void *p);
   static void destruct_vectorlEvectorlEdoublegRsPgR(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const vector<vector<double> >*)
   {
      vector<vector<double> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<vector<double> >),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<vector<double> >", -2, "prec_stl/vector", 49,
                  typeid(vector<vector<double> >), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &vectorlEvectorlEdoublegRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<vector<double> >) );
      instance.SetNew(&new_vectorlEvectorlEdoublegRsPgR);
      instance.SetNewArray(&newArray_vectorlEvectorlEdoublegRsPgR);
      instance.SetDelete(&delete_vectorlEvectorlEdoublegRsPgR);
      instance.SetDeleteArray(&deleteArray_vectorlEvectorlEdoublegRsPgR);
      instance.SetDestructor(&destruct_vectorlEvectorlEdoublegRsPgR);
      instance.AdoptCollectionProxyInfo( ::ROOT::TCollectionProxyInfo::Generate( ::ROOT::TCollectionProxyInfo::Pushback< vector<vector<double> > >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<vector<double> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEvectorlEdoublegRsPgR_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const vector<vector<double> >*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_vectorlEvectorlEdoublegRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<vector<double> > : new vector<vector<double> >;
   }
   static void *newArray_vectorlEvectorlEdoublegRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<vector<double> >[nElements] : new vector<vector<double> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEvectorlEdoublegRsPgR(void *p) {
      delete ((vector<vector<double> >*)p);
   }
   static void deleteArray_vectorlEvectorlEdoublegRsPgR(void *p) {
      delete [] ((vector<vector<double> >*)p);
   }
   static void destruct_vectorlEvectorlEdoublegRsPgR(void *p) {
      typedef vector<vector<double> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class vector<vector<double> >

namespace ROOTDict {
   void vectorlEvectorlEvectorlEdoublegRsPgRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEvectorlEvectorlEdoublegRsPgRsPgR_Dictionary();
   static void *new_vectorlEvectorlEvectorlEdoublegRsPgRsPgR(void *p = 0);
   static void *newArray_vectorlEvectorlEvectorlEdoublegRsPgRsPgR(Long_t size, void *p);
   static void delete_vectorlEvectorlEvectorlEdoublegRsPgRsPgR(void *p);
   static void deleteArray_vectorlEvectorlEvectorlEdoublegRsPgRsPgR(void *p);
   static void destruct_vectorlEvectorlEvectorlEdoublegRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const vector<vector<vector<double> > >*)
   {
      vector<vector<vector<double> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<vector<vector<double> > >),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<vector<vector<double> > >", -2, "prec_stl/vector", 49,
                  typeid(vector<vector<vector<double> > >), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &vectorlEvectorlEvectorlEdoublegRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<vector<vector<double> > >) );
      instance.SetNew(&new_vectorlEvectorlEvectorlEdoublegRsPgRsPgR);
      instance.SetNewArray(&newArray_vectorlEvectorlEvectorlEdoublegRsPgRsPgR);
      instance.SetDelete(&delete_vectorlEvectorlEvectorlEdoublegRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_vectorlEvectorlEvectorlEdoublegRsPgRsPgR);
      instance.SetDestructor(&destruct_vectorlEvectorlEvectorlEdoublegRsPgRsPgR);
      instance.AdoptCollectionProxyInfo( ::ROOT::TCollectionProxyInfo::Generate( ::ROOT::TCollectionProxyInfo::Pushback< vector<vector<vector<double> > > >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<vector<vector<double> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEvectorlEvectorlEdoublegRsPgRsPgR_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const vector<vector<vector<double> > >*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_vectorlEvectorlEvectorlEdoublegRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<vector<vector<double> > > : new vector<vector<vector<double> > >;
   }
   static void *newArray_vectorlEvectorlEvectorlEdoublegRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<vector<vector<double> > >[nElements] : new vector<vector<vector<double> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEvectorlEvectorlEdoublegRsPgRsPgR(void *p) {
      delete ((vector<vector<vector<double> > >*)p);
   }
   static void deleteArray_vectorlEvectorlEvectorlEdoublegRsPgRsPgR(void *p) {
      delete [] ((vector<vector<vector<double> > >*)p);
   }
   static void destruct_vectorlEvectorlEvectorlEdoublegRsPgRsPgR(void *p) {
      typedef vector<vector<vector<double> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class vector<vector<vector<double> > >

/********************************************************
* /phenix/u/spjeffas/LQGENEP/eic-smear-1.0.3/build/smearDict.cxx
* CAUTION: DON'T CHANGE THIS FILE. THIS FILE IS AUTOMATICALLY GENERATED
*          FROM HEADER FILES LISTED IN G__setup_cpp_environmentXXX().
*          CHANGE THOSE HEADER FILES AND REGENERATE THIS FILE.
********************************************************/

#ifdef G__MEMTEST
#undef malloc
#undef free
#endif

#if defined(__GNUC__) && __GNUC__ >= 4 && ((__GNUC_MINOR__ == 2 && __GNUC_PATCHLEVEL__ >= 1) || (__GNUC_MINOR__ >= 3))
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif

extern "C" void G__cpp_reset_tagtablesmearDict();

extern "C" void G__set_cpp_environmentsmearDict() {
  G__add_compiledheader("TObject.h");
  G__add_compiledheader("TMemberInspector.h");
  G__add_compiledheader("/phenix/u/spjeffas/LQGENEP/eic-smear-1.0.3/include/eicsmear/smear/Acceptance.h");
  G__add_compiledheader("/phenix/u/spjeffas/LQGENEP/eic-smear-1.0.3/include/eicsmear/smear/Bremsstrahlung.h");
  G__add_compiledheader("/phenix/u/spjeffas/LQGENEP/eic-smear-1.0.3/include/eicsmear/smear/Detector.h");
  G__add_compiledheader("/phenix/u/spjeffas/LQGENEP/eic-smear-1.0.3/include/eicsmear/smear/Device.h");
  G__add_compiledheader("/phenix/u/spjeffas/LQGENEP/eic-smear-1.0.3/include/eicsmear/smear/Distributor.h");
  G__add_compiledheader("/phenix/u/spjeffas/LQGENEP/eic-smear-1.0.3/include/eicsmear/smear/EventS.h");
  G__add_compiledheader("/phenix/u/spjeffas/LQGENEP/eic-smear-1.0.3/include/eicsmear/smear/EventSmear.h");
  G__add_compiledheader("/phenix/u/spjeffas/LQGENEP/eic-smear-1.0.3/include/eicsmear/smear/EventDisFactory.h");
  G__add_compiledheader("/phenix/u/spjeffas/LQGENEP/eic-smear-1.0.3/include/eicsmear/smear/FormulaString.h");
  G__add_compiledheader("/phenix/u/spjeffas/LQGENEP/eic-smear-1.0.3/include/eicsmear/smear/functions.h");
  G__add_compiledheader("/phenix/u/spjeffas/LQGENEP/eic-smear-1.0.3/include/eicsmear/smear/ParticleID.h");
  G__add_compiledheader("/phenix/u/spjeffas/LQGENEP/eic-smear-1.0.3/include/eicsmear/smear/ParticleMCS.h");
  G__add_compiledheader("/phenix/u/spjeffas/LQGENEP/eic-smear-1.0.3/include/eicsmear/smear/PerfectID.h");
  G__add_compiledheader("/phenix/u/spjeffas/LQGENEP/eic-smear-1.0.3/include/eicsmear/smear/PlanarTracker.h");
  G__add_compiledheader("/phenix/u/spjeffas/LQGENEP/eic-smear-1.0.3/include/eicsmear/smear/RadialTracker.h");
  G__add_compiledheader("/phenix/u/spjeffas/LQGENEP/eic-smear-1.0.3/include/eicsmear/smear/Smear.h");
  G__add_compiledheader("/phenix/u/spjeffas/LQGENEP/eic-smear-1.0.3/include/eicsmear/smear/Smearer.h");
  G__add_compiledheader("/phenix/u/spjeffas/LQGENEP/eic-smear-1.0.3/include/eicsmear/smear/Tracker.h");
  G__cpp_reset_tagtablesmearDict();
}
#include <new>
extern "C" int G__cpp_dllrevsmearDict() { return(30051515); }

/*********************************************************
* Member function Interface Method
*********************************************************/

/* Smear */
static int G__smearDict_436_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) Smear::PGenre(*(erhic::VirtualParticle*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_436_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) Smear::FixTheta((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_436_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) Smear::FixPhi((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_436_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) Smear::GetVariable(*(erhic::VirtualParticle*) libp->para[0].ref, (Smear::KinType) G__int(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_436_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      Smear::SetVariable(*(Smear::ParticleMCS*) libp->para[0].ref, (double) G__double(libp->para[1])
, (Smear::KinType) G__int(libp->para[2]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_436_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      Smear::HandleBogusValues(*(Smear::ParticleMCS*) libp->para[0].ref, (Smear::KinType) G__int(libp->para[1]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_436_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      Smear::HandleBogusValues(*(Smear::ParticleMCS*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_436_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) Smear::IsCoreType((Smear::KinType) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_436_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) Smear::ParseInputFunction(*(TString*) libp->para[0].ref, *(Smear::KinType*) libp->para[1].ref
, *(Smear::KinType*) libp->para[2].ref));
   return(1 || funcname || hash || result7 || libp) ;
}


/* Smear::Event */
static int G__smearDict_437_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Smear::Event* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Smear::Event[n];
     } else {
       p = new((void*) gvp) Smear::Event[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Smear::Event;
     } else {
       p = new((void*) gvp) Smear::Event;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__smearDictLN_SmearcLcLEvent));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_437_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Smear::Event*) G__getstructoffset())->Reset();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_437_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Smear::Event*) G__getstructoffset())->ClearParticles();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_437_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Smear::Event*) G__getstructoffset())->SetQ2((double) G__double(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_437_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Smear::Event*) G__getstructoffset())->SetX((double) G__double(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_437_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Smear::Event*) G__getstructoffset())->SetY((double) G__double(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_437_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Smear::Event*) G__getstructoffset())->SetW2((double) G__double(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_437_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Smear::Event*) G__getstructoffset())->SetNu((double) G__double(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_437_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Smear::Event*) G__getstructoffset())->AddLast((Smear::ParticleMCS*) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_437_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<const erhic::VirtualParticle*>* pobj;
         const vector<const erhic::VirtualParticle*> xobj = ((const Smear::Event*) G__getstructoffset())->GetTracks();
         pobj = new vector<const erhic::VirtualParticle*>(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_437_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Smear::Event*) G__getstructoffset())->SetScattered((int) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_437_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) Smear::Event::Class());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_437_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) Smear::Event::Class_Name());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_437_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 115, (long) Smear::Event::Class_Version());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_437_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      Smear::Event::Dictionary();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_437_0_28(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Smear::Event*) G__getstructoffset())->StreamerNVirtual(*(TBuffer*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_437_0_29(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) Smear::Event::DeclFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_437_0_30(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) Smear::Event::ImplFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_437_0_31(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) Smear::Event::ImplFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_437_0_32(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) Smear::Event::DeclFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__smearDict_437_0_33(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   Smear::Event* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new Smear::Event(*(Smear::Event*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__smearDictLN_SmearcLcLEvent));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Smear::Event G__TSmearcLcLEvent;
static int G__smearDict_437_0_34(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 1
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (Smear::Event*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((Smear::Event*) (soff+(sizeof(Smear::Event)*i)))->~G__TSmearcLcLEvent();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (Smear::Event*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((Smear::Event*) (soff))->~G__TSmearcLcLEvent();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__smearDict_437_0_35(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Smear::Event* dest = (Smear::Event*) G__getstructoffset();
   *dest = *(Smear::Event*) libp->para[0].ref;
   const Smear::Event& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Smear::ParticleMCS */
static int G__smearDict_438_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Smear::ParticleMCS* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Smear::ParticleMCS[n];
     } else {
       p = new((void*) gvp) Smear::ParticleMCS[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Smear::ParticleMCS;
     } else {
       p = new((void*) gvp) Smear::ParticleMCS;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__smearDictLN_SmearcLcLParticleMCS));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_438_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Smear::ParticleMCS* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 3
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new Smear::ParticleMCS(
*(TLorentzVector*) libp->para[0].ref, (int) G__int(libp->para[1])
, (int) G__int(libp->para[2]));
   } else {
     p = new((void*) gvp) Smear::ParticleMCS(
*(TLorentzVector*) libp->para[0].ref, (int) G__int(libp->para[1])
, (int) G__int(libp->para[2]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__smearDictLN_SmearcLcLParticleMCS));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_438_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const TLorentzVector* pobj;
         const TLorentzVector xobj = ((const Smear::ParticleMCS*) G__getstructoffset())->PxPyPzE();
         pobj = new TLorentzVector(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_438_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Smear::ParticleMCS*) G__getstructoffset())->SetE((Double_t) G__double(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_438_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Smear::ParticleMCS*) G__getstructoffset())->SetP((Double_t) G__double(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_438_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Smear::ParticleMCS*) G__getstructoffset())->SetPt((Double_t) G__double(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_438_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Smear::ParticleMCS*) G__getstructoffset())->SetPz((Double_t) G__double(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_438_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Smear::ParticleMCS*) G__getstructoffset())->SetPhi((Double_t) G__double(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_438_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Smear::ParticleMCS*) G__getstructoffset())->SetTheta((Double_t) G__double(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_438_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Smear::ParticleMCS*) G__getstructoffset())->SetId((Int_t) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_438_0_27(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Smear::ParticleMCS*) G__getstructoffset())->SetStatus((Int_t) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_438_0_31(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) Smear::ParticleMCS::Class());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_438_0_32(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) Smear::ParticleMCS::Class_Name());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_438_0_33(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 115, (long) Smear::ParticleMCS::Class_Version());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_438_0_34(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      Smear::ParticleMCS::Dictionary();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_438_0_38(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Smear::ParticleMCS*) G__getstructoffset())->StreamerNVirtual(*(TBuffer*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_438_0_39(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) Smear::ParticleMCS::DeclFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_438_0_40(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) Smear::ParticleMCS::ImplFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_438_0_41(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) Smear::ParticleMCS::ImplFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_438_0_42(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) Smear::ParticleMCS::DeclFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__smearDict_438_0_43(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   Smear::ParticleMCS* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new Smear::ParticleMCS(*(Smear::ParticleMCS*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__smearDictLN_SmearcLcLParticleMCS));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Smear::ParticleMCS G__TSmearcLcLParticleMCS;
static int G__smearDict_438_0_44(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 1
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (Smear::ParticleMCS*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((Smear::ParticleMCS*) (soff+(sizeof(Smear::ParticleMCS)*i)))->~G__TSmearcLcLParticleMCS();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (Smear::ParticleMCS*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((Smear::ParticleMCS*) (soff))->~G__TSmearcLcLParticleMCS();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__smearDict_438_0_45(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Smear::ParticleMCS* dest = (Smear::ParticleMCS*) G__getstructoffset();
   *dest = *(Smear::ParticleMCS*) libp->para[0].ref;
   const Smear::ParticleMCS& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Smear::Acceptance */
static int G__smearDict_442_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Smear::Acceptance* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Smear::Acceptance((int) G__int(libp->para[0]));
     } else {
       p = new((void*) gvp) Smear::Acceptance((int) G__int(libp->para[0]));
     }
     break;
   case 0:
     int n = G__getaryconstruct();
     if (n) {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new Smear::Acceptance[n];
       } else {
         p = new((void*) gvp) Smear::Acceptance[n];
       }
     } else {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new Smear::Acceptance;
       } else {
         p = new((void*) gvp) Smear::Acceptance;
       }
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__smearDictLN_SmearcLcLAcceptance));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_442_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Smear::Acceptance*) G__getstructoffset())->AddZone(*(Smear::Acceptance::Zone*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_442_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const Smear::Acceptance*) G__getstructoffset())->GetNZones());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_442_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const Smear::Acceptance*) G__getstructoffset())->GetGenre());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_442_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Smear::Acceptance*) G__getstructoffset())->SetGenre((int) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_442_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Smear::Acceptance*) G__getstructoffset())->SetCharge((Smear::ECharge) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_442_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const Smear::Acceptance*) G__getstructoffset())->GetCharge());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_442_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Smear::Acceptance*) G__getstructoffset())->AddParticle((int) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_442_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Smear::Acceptance*) G__getstructoffset())->Is(*(erhic::VirtualParticle*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_442_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) Smear::Acceptance::Class());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_442_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) Smear::Acceptance::Class_Name());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_442_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 115, (long) Smear::Acceptance::Class_Version());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_442_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      Smear::Acceptance::Dictionary();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_442_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const Smear::Acceptance*) G__getstructoffset())->IsA());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_442_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Smear::Acceptance*) G__getstructoffset())->ShowMembers(*(TMemberInspector*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_442_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Smear::Acceptance*) G__getstructoffset())->Streamer(*(TBuffer*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_442_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Smear::Acceptance*) G__getstructoffset())->StreamerNVirtual(*(TBuffer*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_442_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) Smear::Acceptance::DeclFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_442_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) Smear::Acceptance::ImplFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_442_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) Smear::Acceptance::ImplFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_442_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) Smear::Acceptance::DeclFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__smearDict_442_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   Smear::Acceptance* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new Smear::Acceptance(*(Smear::Acceptance*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__smearDictLN_SmearcLcLAcceptance));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Smear::Acceptance G__TSmearcLcLAcceptance;
static int G__smearDict_442_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (Smear::Acceptance*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((Smear::Acceptance*) (soff+(sizeof(Smear::Acceptance)*i)))->~G__TSmearcLcLAcceptance();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (Smear::Acceptance*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((Smear::Acceptance*) (soff))->~G__TSmearcLcLAcceptance();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__smearDict_442_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Smear::Acceptance* dest = (Smear::Acceptance*) G__getstructoffset();
   *dest = *(Smear::Acceptance*) libp->para[0].ref;
   const Smear::Acceptance& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Smear::Acceptance::CustomCut */
static int G__smearDict_443_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Smear::Acceptance::CustomCut* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Smear::Acceptance::CustomCut[n];
     } else {
       p = new((void*) gvp) Smear::Acceptance::CustomCut[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Smear::Acceptance::CustomCut;
     } else {
       p = new((void*) gvp) Smear::Acceptance::CustomCut;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__smearDictLN_SmearcLcLAcceptancecLcLCustomCut));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_443_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Smear::Acceptance::CustomCut* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 3
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new Smear::Acceptance::CustomCut(
*(TString*) libp->para[0].ref, (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]));
   } else {
     p = new((void*) gvp) Smear::Acceptance::CustomCut(
*(TString*) libp->para[0].ref, (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__smearDictLN_SmearcLcLAcceptancecLcLCustomCut));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_443_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Smear::Acceptance::CustomCut*) G__getstructoffset())->Contains(*(erhic::VirtualParticle*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Smear::Acceptance::CustomCut G__TSmearcLcLAcceptancecLcLCustomCut;
static int G__smearDict_443_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (Smear::Acceptance::CustomCut*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((Smear::Acceptance::CustomCut*) (soff+(sizeof(Smear::Acceptance::CustomCut)*i)))->~G__TSmearcLcLAcceptancecLcLCustomCut();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (Smear::Acceptance::CustomCut*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((Smear::Acceptance::CustomCut*) (soff))->~G__TSmearcLcLAcceptancecLcLCustomCut();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Smear::Acceptance::Zone */
static int G__smearDict_444_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Smear::Acceptance::Zone* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 12:
     //m: 12
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Smear::Acceptance::Zone(
(double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])
, (double) G__double(libp->para[4]), (double) G__double(libp->para[5])
, (double) G__double(libp->para[6]), (double) G__double(libp->para[7])
, (double) G__double(libp->para[8]), (double) G__double(libp->para[9])
, (double) G__double(libp->para[10]), (double) G__double(libp->para[11]));
     } else {
       p = new((void*) gvp) Smear::Acceptance::Zone(
(double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])
, (double) G__double(libp->para[4]), (double) G__double(libp->para[5])
, (double) G__double(libp->para[6]), (double) G__double(libp->para[7])
, (double) G__double(libp->para[8]), (double) G__double(libp->para[9])
, (double) G__double(libp->para[10]), (double) G__double(libp->para[11]));
     }
     break;
   case 11:
     //m: 11
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Smear::Acceptance::Zone(
(double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])
, (double) G__double(libp->para[4]), (double) G__double(libp->para[5])
, (double) G__double(libp->para[6]), (double) G__double(libp->para[7])
, (double) G__double(libp->para[8]), (double) G__double(libp->para[9])
, (double) G__double(libp->para[10]));
     } else {
       p = new((void*) gvp) Smear::Acceptance::Zone(
(double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])
, (double) G__double(libp->para[4]), (double) G__double(libp->para[5])
, (double) G__double(libp->para[6]), (double) G__double(libp->para[7])
, (double) G__double(libp->para[8]), (double) G__double(libp->para[9])
, (double) G__double(libp->para[10]));
     }
     break;
   case 10:
     //m: 10
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Smear::Acceptance::Zone(
(double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])
, (double) G__double(libp->para[4]), (double) G__double(libp->para[5])
, (double) G__double(libp->para[6]), (double) G__double(libp->para[7])
, (double) G__double(libp->para[8]), (double) G__double(libp->para[9]));
     } else {
       p = new((void*) gvp) Smear::Acceptance::Zone(
(double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])
, (double) G__double(libp->para[4]), (double) G__double(libp->para[5])
, (double) G__double(libp->para[6]), (double) G__double(libp->para[7])
, (double) G__double(libp->para[8]), (double) G__double(libp->para[9]));
     }
     break;
   case 9:
     //m: 9
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Smear::Acceptance::Zone(
(double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])
, (double) G__double(libp->para[4]), (double) G__double(libp->para[5])
, (double) G__double(libp->para[6]), (double) G__double(libp->para[7])
, (double) G__double(libp->para[8]));
     } else {
       p = new((void*) gvp) Smear::Acceptance::Zone(
(double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])
, (double) G__double(libp->para[4]), (double) G__double(libp->para[5])
, (double) G__double(libp->para[6]), (double) G__double(libp->para[7])
, (double) G__double(libp->para[8]));
     }
     break;
   case 8:
     //m: 8
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Smear::Acceptance::Zone(
(double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])
, (double) G__double(libp->para[4]), (double) G__double(libp->para[5])
, (double) G__double(libp->para[6]), (double) G__double(libp->para[7]));
     } else {
       p = new((void*) gvp) Smear::Acceptance::Zone(
(double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])
, (double) G__double(libp->para[4]), (double) G__double(libp->para[5])
, (double) G__double(libp->para[6]), (double) G__double(libp->para[7]));
     }
     break;
   case 7:
     //m: 7
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Smear::Acceptance::Zone(
(double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])
, (double) G__double(libp->para[4]), (double) G__double(libp->para[5])
, (double) G__double(libp->para[6]));
     } else {
       p = new((void*) gvp) Smear::Acceptance::Zone(
(double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])
, (double) G__double(libp->para[4]), (double) G__double(libp->para[5])
, (double) G__double(libp->para[6]));
     }
     break;
   case 6:
     //m: 6
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Smear::Acceptance::Zone(
(double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])
, (double) G__double(libp->para[4]), (double) G__double(libp->para[5]));
     } else {
       p = new((void*) gvp) Smear::Acceptance::Zone(
(double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])
, (double) G__double(libp->para[4]), (double) G__double(libp->para[5]));
     }
     break;
   case 5:
     //m: 5
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Smear::Acceptance::Zone(
(double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])
, (double) G__double(libp->para[4]));
     } else {
       p = new((void*) gvp) Smear::Acceptance::Zone(
(double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])
, (double) G__double(libp->para[4]));
     }
     break;
   case 4:
     //m: 4
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Smear::Acceptance::Zone(
(double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3]));
     } else {
       p = new((void*) gvp) Smear::Acceptance::Zone(
(double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3]));
     }
     break;
   case 3:
     //m: 3
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Smear::Acceptance::Zone(
(double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]));
     } else {
       p = new((void*) gvp) Smear::Acceptance::Zone(
(double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]));
     }
     break;
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Smear::Acceptance::Zone((double) G__double(libp->para[0]), (double) G__double(libp->para[1]));
     } else {
       p = new((void*) gvp) Smear::Acceptance::Zone((double) G__double(libp->para[0]), (double) G__double(libp->para[1]));
     }
     break;
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Smear::Acceptance::Zone((double) G__double(libp->para[0]));
     } else {
       p = new((void*) gvp) Smear::Acceptance::Zone((double) G__double(libp->para[0]));
     }
     break;
   case 0:
     int n = G__getaryconstruct();
     if (n) {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new Smear::Acceptance::Zone[n];
       } else {
         p = new((void*) gvp) Smear::Acceptance::Zone[n];
       }
     } else {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new Smear::Acceptance::Zone;
       } else {
         p = new((void*) gvp) Smear::Acceptance::Zone;
       }
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__smearDictLN_SmearcLcLAcceptancecLcLZone));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_444_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Smear::Acceptance::Zone*) G__getstructoffset())->Add(*(Smear::Acceptance::CustomCut*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_444_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Smear::Acceptance::Zone*) G__getstructoffset())->Contains(*(erhic::VirtualParticle*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_444_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) Smear::Acceptance::Zone::Class());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_444_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) Smear::Acceptance::Zone::Class_Name());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_444_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 115, (long) Smear::Acceptance::Zone::Class_Version());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_444_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      Smear::Acceptance::Zone::Dictionary();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_444_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const Smear::Acceptance::Zone*) G__getstructoffset())->IsA());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_444_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Smear::Acceptance::Zone*) G__getstructoffset())->ShowMembers(*(TMemberInspector*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_444_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Smear::Acceptance::Zone*) G__getstructoffset())->Streamer(*(TBuffer*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_444_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Smear::Acceptance::Zone*) G__getstructoffset())->StreamerNVirtual(*(TBuffer*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_444_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) Smear::Acceptance::Zone::DeclFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_444_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) Smear::Acceptance::Zone::ImplFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_444_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) Smear::Acceptance::Zone::ImplFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_444_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) Smear::Acceptance::Zone::DeclFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__smearDict_444_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   Smear::Acceptance::Zone* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new Smear::Acceptance::Zone(*(Smear::Acceptance::Zone*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__smearDictLN_SmearcLcLAcceptancecLcLZone));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Smear::Acceptance::Zone G__TSmearcLcLAcceptancecLcLZone;
static int G__smearDict_444_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (Smear::Acceptance::Zone*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((Smear::Acceptance::Zone*) (soff+(sizeof(Smear::Acceptance::Zone)*i)))->~G__TSmearcLcLAcceptancecLcLZone();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (Smear::Acceptance::Zone*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((Smear::Acceptance::Zone*) (soff))->~G__TSmearcLcLAcceptancecLcLZone();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__smearDict_444_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Smear::Acceptance::Zone* dest = (Smear::Acceptance::Zone*) G__getstructoffset();
   *dest = *(Smear::Acceptance::Zone*) libp->para[0].ref;
   const Smear::Acceptance::Zone& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Smear::Distributor */
static int G__smearDict_453_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Smear::Distributor* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Smear::Distributor[n];
     } else {
       p = new((void*) gvp) Smear::Distributor[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Smear::Distributor;
     } else {
       p = new((void*) gvp) Smear::Distributor;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__smearDictLN_SmearcLcLDistributor));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_453_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Smear::Distributor* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 5:
     //m: 5
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Smear::Distributor(
*(TString*) libp->para[0].ref, (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])
, (double) G__double(libp->para[4]));
     } else {
       p = new((void*) gvp) Smear::Distributor(
*(TString*) libp->para[0].ref, (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])
, (double) G__double(libp->para[4]));
     }
     break;
   case 4:
     //m: 4
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Smear::Distributor(
*(TString*) libp->para[0].ref, (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3]));
     } else {
       p = new((void*) gvp) Smear::Distributor(
*(TString*) libp->para[0].ref, (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3]));
     }
     break;
   case 3:
     //m: 3
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Smear::Distributor(
*(TString*) libp->para[0].ref, (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]));
     } else {
       p = new((void*) gvp) Smear::Distributor(
*(TString*) libp->para[0].ref, (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]));
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__smearDictLN_SmearcLcLDistributor));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_453_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((Smear::Distributor*) G__getstructoffset())->Generate((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_453_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) Smear::Distributor::Class());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_453_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) Smear::Distributor::Class_Name());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_453_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 115, (long) Smear::Distributor::Class_Version());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_453_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      Smear::Distributor::Dictionary();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_453_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const Smear::Distributor*) G__getstructoffset())->IsA());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_453_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Smear::Distributor*) G__getstructoffset())->ShowMembers(*(TMemberInspector*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_453_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Smear::Distributor*) G__getstructoffset())->Streamer(*(TBuffer*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_453_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Smear::Distributor*) G__getstructoffset())->StreamerNVirtual(*(TBuffer*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_453_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) Smear::Distributor::DeclFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_453_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) Smear::Distributor::ImplFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_453_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) Smear::Distributor::ImplFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_453_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) Smear::Distributor::DeclFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__smearDict_453_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   Smear::Distributor* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new Smear::Distributor(*(Smear::Distributor*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__smearDictLN_SmearcLcLDistributor));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Smear::Distributor G__TSmearcLcLDistributor;
static int G__smearDict_453_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (Smear::Distributor*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((Smear::Distributor*) (soff+(sizeof(Smear::Distributor)*i)))->~G__TSmearcLcLDistributor();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (Smear::Distributor*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((Smear::Distributor*) (soff))->~G__TSmearcLcLDistributor();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__smearDict_453_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Smear::Distributor* dest = (Smear::Distributor*) G__getstructoffset();
   *dest = *(Smear::Distributor*) libp->para[0].ref;
   const Smear::Distributor& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Smear::Smearer */
static int G__smearDict_454_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Smear::Smearer*) G__getstructoffset())->Smear(*(erhic::VirtualParticle*) libp->para[0].ref, *(Smear::ParticleMCS*) libp->para[1].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_454_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) Smear::Smearer::Class());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_454_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) Smear::Smearer::Class_Name());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_454_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 115, (long) Smear::Smearer::Class_Version());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_454_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      Smear::Smearer::Dictionary();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_454_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Smear::Smearer*) G__getstructoffset())->StreamerNVirtual(*(TBuffer*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_454_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) Smear::Smearer::DeclFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_454_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) Smear::Smearer::ImplFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_454_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) Smear::Smearer::ImplFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_454_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) Smear::Smearer::DeclFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Smear::Smearer G__TSmearcLcLSmearer;
static int G__smearDict_454_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 1
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (Smear::Smearer*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((Smear::Smearer*) (soff+(sizeof(Smear::Smearer)*i)))->~G__TSmearcLcLSmearer();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (Smear::Smearer*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((Smear::Smearer*) (soff))->~G__TSmearcLcLSmearer();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__smearDict_454_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Smear::Smearer* dest = (Smear::Smearer*) G__getstructoffset();
   *dest = *(Smear::Smearer*) libp->para[0].ref;
   const Smear::Smearer& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Smear::FormulaString */
static int G__smearDict_455_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Smear::FormulaString* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Smear::FormulaString[n];
     } else {
       p = new((void*) gvp) Smear::FormulaString[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Smear::FormulaString;
     } else {
       p = new((void*) gvp) Smear::FormulaString;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__smearDictLN_SmearcLcLFormulaString));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_455_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Smear::FormulaString* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new Smear::FormulaString(*(string*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) Smear::FormulaString(*(string*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__smearDictLN_SmearcLcLFormulaString));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_455_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const Smear::FormulaString*) G__getstructoffset())->Eval(*(vector<double>*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_455_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<Smear::KinType>* pobj;
         const vector<Smear::KinType> xobj = ((const Smear::FormulaString*) G__getstructoffset())->Variables();
         pobj = new vector<Smear::KinType>(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_455_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const string* pobj;
         const string xobj = ((const Smear::FormulaString*) G__getstructoffset())->GetString();
         pobj = new string(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_455_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const string* pobj;
         const string xobj = ((const Smear::FormulaString*) G__getstructoffset())->GetInputString();
         pobj = new string(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_455_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         string* pobj;
         string xobj = Smear::FormulaString::GetKinName((Smear::KinType) G__int(libp->para[0]));
         pobj = new string(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_455_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) Smear::FormulaString::GetKinType(*(string*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_455_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) Smear::FormulaString::Class());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_455_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) Smear::FormulaString::Class_Name());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_455_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 115, (long) Smear::FormulaString::Class_Version());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_455_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      Smear::FormulaString::Dictionary();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_455_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Smear::FormulaString*) G__getstructoffset())->StreamerNVirtual(*(TBuffer*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_455_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) Smear::FormulaString::DeclFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_455_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) Smear::FormulaString::ImplFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_455_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) Smear::FormulaString::ImplFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_455_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) Smear::FormulaString::DeclFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__smearDict_455_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   Smear::FormulaString* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new Smear::FormulaString(*(Smear::FormulaString*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__smearDictLN_SmearcLcLFormulaString));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Smear::FormulaString G__TSmearcLcLFormulaString;
static int G__smearDict_455_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 1
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (Smear::FormulaString*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((Smear::FormulaString*) (soff+(sizeof(Smear::FormulaString)*i)))->~G__TSmearcLcLFormulaString();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (Smear::FormulaString*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((Smear::FormulaString*) (soff))->~G__TSmearcLcLFormulaString();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__smearDict_455_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Smear::FormulaString* dest = (Smear::FormulaString*) G__getstructoffset();
   *dest = *(Smear::FormulaString*) libp->para[0].ref;
   const Smear::FormulaString& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Smear::Device */
static int G__smearDict_456_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Smear::Device* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 3:
     //m: 3
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Smear::Device(
(Smear::KinType) G__int(libp->para[0]), *(TString*) libp->para[1].ref
, (Smear::EGenre) G__int(libp->para[2]));
     } else {
       p = new((void*) gvp) Smear::Device(
(Smear::KinType) G__int(libp->para[0]), *(TString*) libp->para[1].ref
, (Smear::EGenre) G__int(libp->para[2]));
     }
     break;
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Smear::Device((Smear::KinType) G__int(libp->para[0]), *(TString*) libp->para[1].ref);
     } else {
       p = new((void*) gvp) Smear::Device((Smear::KinType) G__int(libp->para[0]), *(TString*) libp->para[1].ref);
     }
     break;
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Smear::Device((Smear::KinType) G__int(libp->para[0]));
     } else {
       p = new((void*) gvp) Smear::Device((Smear::KinType) G__int(libp->para[0]));
     }
     break;
   case 0:
     int n = G__getaryconstruct();
     if (n) {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new Smear::Device[n];
       } else {
         p = new((void*) gvp) Smear::Device[n];
       }
     } else {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new Smear::Device;
       } else {
         p = new((void*) gvp) Smear::Device;
       }
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__smearDictLN_SmearcLcLDevice));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_456_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Smear::Device* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 3:
     //m: 3
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Smear::Device(
*(TString*) libp->para[0].ref, *(TString*) libp->para[1].ref
, (Smear::EGenre) G__int(libp->para[2]));
     } else {
       p = new((void*) gvp) Smear::Device(
*(TString*) libp->para[0].ref, *(TString*) libp->para[1].ref
, (Smear::EGenre) G__int(libp->para[2]));
     }
     break;
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Smear::Device(*(TString*) libp->para[0].ref, *(TString*) libp->para[1].ref);
     } else {
       p = new((void*) gvp) Smear::Device(*(TString*) libp->para[0].ref, *(TString*) libp->para[1].ref);
     }
     break;
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Smear::Device(*(TString*) libp->para[0].ref);
     } else {
       p = new((void*) gvp) Smear::Device(*(TString*) libp->para[0].ref);
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__smearDictLN_SmearcLcLDevice));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_456_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Smear::Device* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new Smear::Device(*(Smear::Device*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) Smear::Device(*(Smear::Device*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__smearDictLN_SmearcLcLDevice));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_456_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Smear::Device*) G__getstructoffset())->SetDistribution(*(Smear::Distributor*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_456_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) Smear::Device::Class());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_456_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) Smear::Device::Class_Name());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_456_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 115, (long) Smear::Device::Class_Version());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_456_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      Smear::Device::Dictionary();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_456_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Smear::Device*) G__getstructoffset())->StreamerNVirtual(*(TBuffer*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_456_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) Smear::Device::DeclFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_456_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) Smear::Device::ImplFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_456_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) Smear::Device::ImplFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_456_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) Smear::Device::DeclFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Smear::Device G__TSmearcLcLDevice;
static int G__smearDict_456_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 1
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (Smear::Device*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((Smear::Device*) (soff+(sizeof(Smear::Device)*i)))->~G__TSmearcLcLDevice();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (Smear::Device*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((Smear::Device*) (soff))->~G__TSmearcLcLDevice();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* vector<Smear::KinType,allocator<Smear::KinType> > */
static int G__smearDict_458_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<Smear::KinType,allocator<Smear::KinType> >::reference obj = ((vector<Smear::KinType,allocator<Smear::KinType> >*) G__getstructoffset())->at((vector<Smear::KinType,allocator<Smear::KinType> >::size_type) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         G__letint(result7, 'i', (long)obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_458_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<Smear::KinType,allocator<Smear::KinType> >::const_reference obj = ((const vector<Smear::KinType,allocator<Smear::KinType> >*) G__getstructoffset())->at((vector<Smear::KinType,allocator<Smear::KinType> >::size_type) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         G__letint(result7, 'i', (long)obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_458_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<Smear::KinType,allocator<Smear::KinType> >::iterator* pobj;
         vector<Smear::KinType,allocator<Smear::KinType> >::iterator xobj = ((vector<Smear::KinType,allocator<Smear::KinType> >*) G__getstructoffset())->begin();
         pobj = new vector<Smear::KinType,allocator<Smear::KinType> >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_458_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<Smear::KinType,allocator<Smear::KinType> >::iterator* pobj;
         vector<Smear::KinType,allocator<Smear::KinType> >::iterator xobj = ((vector<Smear::KinType,allocator<Smear::KinType> >*) G__getstructoffset())->end();
         pobj = new vector<Smear::KinType,allocator<Smear::KinType> >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_458_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<Smear::KinType,allocator<Smear::KinType> >::reverse_iterator* pobj;
         vector<Smear::KinType,allocator<Smear::KinType> >::reverse_iterator xobj = ((vector<Smear::KinType,allocator<Smear::KinType> >*) G__getstructoffset())->rbegin();
         pobj = new vector<Smear::KinType,allocator<Smear::KinType> >::reverse_iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_458_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<Smear::KinType,allocator<Smear::KinType> >::reverse_iterator* pobj;
         vector<Smear::KinType,allocator<Smear::KinType> >::reverse_iterator xobj = ((vector<Smear::KinType,allocator<Smear::KinType> >*) G__getstructoffset())->rend();
         pobj = new vector<Smear::KinType,allocator<Smear::KinType> >::reverse_iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_458_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 107, (long) ((const vector<Smear::KinType,allocator<Smear::KinType> >*) G__getstructoffset())->size());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_458_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 107, (long) ((const vector<Smear::KinType,allocator<Smear::KinType> >*) G__getstructoffset())->max_size());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_458_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<Smear::KinType,allocator<Smear::KinType> >*) G__getstructoffset())->resize((vector<Smear::KinType,allocator<Smear::KinType> >::size_type) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_458_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<Smear::KinType,allocator<Smear::KinType> >*) G__getstructoffset())->resize((vector<Smear::KinType,allocator<Smear::KinType> >::size_type) G__int(libp->para[0]), (Smear::KinType) G__int(libp->para[1]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_458_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 107, (long) ((const vector<Smear::KinType,allocator<Smear::KinType> >*) G__getstructoffset())->capacity());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_458_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const vector<Smear::KinType,allocator<Smear::KinType> >*) G__getstructoffset())->empty());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_458_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<Smear::KinType,allocator<Smear::KinType> >::reference obj = ((vector<Smear::KinType,allocator<Smear::KinType> >*) G__getstructoffset())->operator[]((vector<Smear::KinType,allocator<Smear::KinType> >::size_type) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         G__letint(result7, 'i', (long)obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_458_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<Smear::KinType,allocator<Smear::KinType> >::const_reference obj = ((const vector<Smear::KinType,allocator<Smear::KinType> >*) G__getstructoffset())->operator[]((vector<Smear::KinType,allocator<Smear::KinType> >::size_type) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         G__letint(result7, 'i', (long)obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_458_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<Smear::KinType,allocator<Smear::KinType> >* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<Smear::KinType,allocator<Smear::KinType> >[n];
     } else {
       p = new((void*) gvp) vector<Smear::KinType,allocator<Smear::KinType> >[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<Smear::KinType,allocator<Smear::KinType> >;
     } else {
       p = new((void*) gvp) vector<Smear::KinType,allocator<Smear::KinType> >;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__smearDictLN_vectorlESmearcLcLKinTypecOallocatorlESmearcLcLKinTypegRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_458_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<Smear::KinType,allocator<Smear::KinType> >* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<Smear::KinType,allocator<Smear::KinType> >((vector<Smear::KinType,allocator<Smear::KinType> >::size_type) G__int(libp->para[0]), *(Smear::KinType*) libp->para[1].ref);
     } else {
       p = new((void*) gvp) vector<Smear::KinType,allocator<Smear::KinType> >((vector<Smear::KinType,allocator<Smear::KinType> >::size_type) G__int(libp->para[0]), *(Smear::KinType*) libp->para[1].ref);
     }
     break;
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<Smear::KinType,allocator<Smear::KinType> >((vector<Smear::KinType,allocator<Smear::KinType> >::size_type) G__int(libp->para[0]));
     } else {
       p = new((void*) gvp) vector<Smear::KinType,allocator<Smear::KinType> >((vector<Smear::KinType,allocator<Smear::KinType> >::size_type) G__int(libp->para[0]));
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__smearDictLN_vectorlESmearcLcLKinTypecOallocatorlESmearcLcLKinTypegRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_458_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<Smear::KinType,allocator<Smear::KinType> >* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new vector<Smear::KinType,allocator<Smear::KinType> >(*(vector<Smear::KinType,allocator<Smear::KinType> >*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) vector<Smear::KinType,allocator<Smear::KinType> >(*(vector<Smear::KinType,allocator<Smear::KinType> >*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__smearDictLN_vectorlESmearcLcLKinTypecOallocatorlESmearcLcLKinTypegRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_458_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<Smear::KinType,allocator<Smear::KinType> >* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new vector<Smear::KinType,allocator<Smear::KinType> >(*((vector<Smear::KinType,allocator<Smear::KinType> >::const_iterator*) G__int(libp->para[0])), *((vector<Smear::KinType,allocator<Smear::KinType> >::const_iterator*) G__int(libp->para[1])));
   } else {
     p = new((void*) gvp) vector<Smear::KinType,allocator<Smear::KinType> >(*((vector<Smear::KinType,allocator<Smear::KinType> >::const_iterator*) G__int(libp->para[0])), *((vector<Smear::KinType,allocator<Smear::KinType> >::const_iterator*) G__int(libp->para[1])));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__smearDictLN_vectorlESmearcLcLKinTypecOallocatorlESmearcLcLKinTypegRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_458_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<Smear::KinType,allocator<Smear::KinType> >& obj = ((vector<Smear::KinType,allocator<Smear::KinType> >*) G__getstructoffset())->operator=(*(vector<Smear::KinType,allocator<Smear::KinType> >*) libp->para[0].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_458_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<Smear::KinType,allocator<Smear::KinType> >*) G__getstructoffset())->reserve((vector<Smear::KinType,allocator<Smear::KinType> >::size_type) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_458_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Smear::KinType& obj = ((vector<Smear::KinType,allocator<Smear::KinType> >*) G__getstructoffset())->front();
         result7->ref = (long) (&obj);
         G__letint(result7, 'i', (long)obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_458_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Smear::KinType& obj = ((vector<Smear::KinType,allocator<Smear::KinType> >*) G__getstructoffset())->back();
         result7->ref = (long) (&obj);
         G__letint(result7, 'i', (long)obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_458_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<Smear::KinType,allocator<Smear::KinType> >*) G__getstructoffset())->push_back(*(Smear::KinType*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_458_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<Smear::KinType,allocator<Smear::KinType> >*) G__getstructoffset())->swap(*(vector<Smear::KinType,allocator<Smear::KinType> >*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_458_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<Smear::KinType,allocator<Smear::KinType> >::iterator* pobj;
         vector<Smear::KinType,allocator<Smear::KinType> >::iterator xobj = ((vector<Smear::KinType,allocator<Smear::KinType> >*) G__getstructoffset())->insert(*((vector<Smear::KinType,allocator<Smear::KinType> >::iterator*) G__int(libp->para[0])), *(Smear::KinType*) libp->para[1].ref);
         pobj = new vector<Smear::KinType,allocator<Smear::KinType> >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_458_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<Smear::KinType,allocator<Smear::KinType> >*) G__getstructoffset())->insert(*((vector<Smear::KinType,allocator<Smear::KinType> >::iterator*) G__int(libp->para[0])), *((vector<Smear::KinType,allocator<Smear::KinType> >::const_iterator*) G__int(libp->para[1]))
, *((vector<Smear::KinType,allocator<Smear::KinType> >::const_iterator*) G__int(libp->para[2])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_458_0_27(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<Smear::KinType,allocator<Smear::KinType> >*) G__getstructoffset())->insert(*((vector<Smear::KinType,allocator<Smear::KinType> >::iterator*) G__int(libp->para[0])), (vector<Smear::KinType,allocator<Smear::KinType> >::size_type) G__int(libp->para[1])
, *(Smear::KinType*) libp->para[2].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_458_0_28(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<Smear::KinType,allocator<Smear::KinType> >*) G__getstructoffset())->pop_back();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_458_0_29(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<Smear::KinType,allocator<Smear::KinType> >*) G__getstructoffset())->erase(*((vector<Smear::KinType,allocator<Smear::KinType> >::iterator*) G__int(libp->para[0])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_458_0_30(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<Smear::KinType,allocator<Smear::KinType> >*) G__getstructoffset())->erase(*((vector<Smear::KinType,allocator<Smear::KinType> >::iterator*) G__int(libp->para[0])), *((vector<Smear::KinType,allocator<Smear::KinType> >::iterator*) G__int(libp->para[1])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_458_0_31(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<Smear::KinType,allocator<Smear::KinType> >*) G__getstructoffset())->clear();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef vector<Smear::KinType,allocator<Smear::KinType> > G__TvectorlESmearcLcLKinTypecOallocatorlESmearcLcLKinTypegRsPgR;
static int G__smearDict_458_0_32(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (vector<Smear::KinType,allocator<Smear::KinType> >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((vector<Smear::KinType,allocator<Smear::KinType> >*) (soff+(sizeof(vector<Smear::KinType,allocator<Smear::KinType> >)*i)))->~G__TvectorlESmearcLcLKinTypecOallocatorlESmearcLcLKinTypegRsPgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (vector<Smear::KinType,allocator<Smear::KinType> >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((vector<Smear::KinType,allocator<Smear::KinType> >*) (soff))->~G__TvectorlESmearcLcLKinTypecOallocatorlESmearcLcLKinTypegRsPgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Smear::Bremsstrahlung */
static int G__smearDict_461_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Smear::Bremsstrahlung* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 3:
     //m: 3
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Smear::Bremsstrahlung(
(double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]));
     } else {
       p = new((void*) gvp) Smear::Bremsstrahlung(
(double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]));
     }
     break;
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Smear::Bremsstrahlung((double) G__double(libp->para[0]), (double) G__double(libp->para[1]));
     } else {
       p = new((void*) gvp) Smear::Bremsstrahlung((double) G__double(libp->para[0]), (double) G__double(libp->para[1]));
     }
     break;
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Smear::Bremsstrahlung((double) G__double(libp->para[0]));
     } else {
       p = new((void*) gvp) Smear::Bremsstrahlung((double) G__double(libp->para[0]));
     }
     break;
   case 0:
     int n = G__getaryconstruct();
     if (n) {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new Smear::Bremsstrahlung[n];
       } else {
         p = new((void*) gvp) Smear::Bremsstrahlung[n];
       }
     } else {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new Smear::Bremsstrahlung;
       } else {
         p = new((void*) gvp) Smear::Bremsstrahlung;
       }
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__smearDictLN_SmearcLcLBremsstrahlung));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_461_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Smear::Bremsstrahlung* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new Smear::Bremsstrahlung(*(Smear::Bremsstrahlung*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) Smear::Bremsstrahlung(*(Smear::Bremsstrahlung*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__smearDictLN_SmearcLcLBremsstrahlung));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_461_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) Smear::Bremsstrahlung::Class());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_461_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) Smear::Bremsstrahlung::Class_Name());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_461_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 115, (long) Smear::Bremsstrahlung::Class_Version());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_461_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      Smear::Bremsstrahlung::Dictionary();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_461_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Smear::Bremsstrahlung*) G__getstructoffset())->StreamerNVirtual(*(TBuffer*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_461_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) Smear::Bremsstrahlung::DeclFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_461_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) Smear::Bremsstrahlung::ImplFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_461_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) Smear::Bremsstrahlung::ImplFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_461_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) Smear::Bremsstrahlung::DeclFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Smear::Bremsstrahlung G__TSmearcLcLBremsstrahlung;
static int G__smearDict_461_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 1
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (Smear::Bremsstrahlung*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((Smear::Bremsstrahlung*) (soff+(sizeof(Smear::Bremsstrahlung)*i)))->~G__TSmearcLcLBremsstrahlung();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (Smear::Bremsstrahlung*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((Smear::Bremsstrahlung*) (soff))->~G__TSmearcLcLBremsstrahlung();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* auto_ptr<erhic::ParticleMC> */
static int G__smearDict_462_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   auto_ptr<erhic::ParticleMC>* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new auto_ptr<erhic::ParticleMC>((erhic::ParticleMC*) G__int(libp->para[0]));
     } else {
       p = new((void*) gvp) auto_ptr<erhic::ParticleMC>((erhic::ParticleMC*) G__int(libp->para[0]));
     }
     break;
   case 0:
     int n = G__getaryconstruct();
     if (n) {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new auto_ptr<erhic::ParticleMC>[n];
       } else {
         p = new((void*) gvp) auto_ptr<erhic::ParticleMC>[n];
       }
     } else {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new auto_ptr<erhic::ParticleMC>;
       } else {
         p = new((void*) gvp) auto_ptr<erhic::ParticleMC>;
       }
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__smearDictLN_auto_ptrlEerhiccLcLParticleMCgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_462_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   auto_ptr<erhic::ParticleMC>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new auto_ptr<erhic::ParticleMC>(*(auto_ptr<erhic::ParticleMC>*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) auto_ptr<erhic::ParticleMC>(*(auto_ptr<erhic::ParticleMC>*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__smearDictLN_auto_ptrlEerhiccLcLParticleMCgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_462_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const auto_ptr<erhic::ParticleMC>& obj = ((auto_ptr<erhic::ParticleMC>*) G__getstructoffset())->operator=(*(auto_ptr<erhic::ParticleMC>*) libp->para[0].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_462_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const erhic::ParticleMC& obj = ((const auto_ptr<erhic::ParticleMC>*) G__getstructoffset())->operator*();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_462_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const auto_ptr<erhic::ParticleMC>*) G__getstructoffset())->operator->());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_462_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const auto_ptr<erhic::ParticleMC>*) G__getstructoffset())->get());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_462_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((auto_ptr<erhic::ParticleMC>*) G__getstructoffset())->release());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef auto_ptr<erhic::ParticleMC> G__Tauto_ptrlEerhiccLcLParticleMCgR;
static int G__smearDict_462_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (auto_ptr<erhic::ParticleMC>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((auto_ptr<erhic::ParticleMC>*) (soff+(sizeof(auto_ptr<erhic::ParticleMC>)*i)))->~G__Tauto_ptrlEerhiccLcLParticleMCgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (auto_ptr<erhic::ParticleMC>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((auto_ptr<erhic::ParticleMC>*) (soff))->~G__Tauto_ptrlEerhiccLcLParticleMCgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Smear::Detector */
static int G__smearDict_463_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Smear::Detector* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Smear::Detector[n];
     } else {
       p = new((void*) gvp) Smear::Detector[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Smear::Detector;
     } else {
       p = new((void*) gvp) Smear::Detector;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__smearDictLN_SmearcLcLDetector));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_463_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Smear::Detector* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new Smear::Detector(*(Smear::Detector*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) Smear::Detector(*(Smear::Detector*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__smearDictLN_SmearcLcLDetector));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_463_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Smear::Detector& obj = ((Smear::Detector*) G__getstructoffset())->operator=(*(Smear::Detector*) libp->para[0].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_463_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Smear::Detector*) G__getstructoffset())->AddDevice(*(Smear::Smearer*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_463_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Smear::Detector*) G__getstructoffset())->SetEventKinematicsCalculator(*((TString*) G__int(libp->para[0])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_463_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Smear::Detector*) G__getstructoffset())->DeleteAllDevices();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_463_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((Smear::Detector*) G__getstructoffset())->GetDevice((int) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_463_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const Smear::Detector*) G__getstructoffset())->GetNDevices());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_463_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Smear::Detector*) G__getstructoffset())->FillEventKinematics((Smear::Event*) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_463_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const Smear::Detector*) G__getstructoffset())->Smear(*(erhic::VirtualParticle*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_463_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const list<Smear::Smearer*>* pobj;
         const list<Smear::Smearer*> xobj = ((const Smear::Detector*) G__getstructoffset())->Accept(*(erhic::VirtualParticle*) libp->para[0].ref);
         pobj = new list<Smear::Smearer*>(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_463_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) Smear::Detector::Class());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_463_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) Smear::Detector::Class_Name());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_463_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 115, (long) Smear::Detector::Class_Version());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_463_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      Smear::Detector::Dictionary();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_463_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Smear::Detector*) G__getstructoffset())->StreamerNVirtual(*(TBuffer*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_463_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) Smear::Detector::DeclFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_463_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) Smear::Detector::ImplFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_463_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) Smear::Detector::ImplFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_463_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) Smear::Detector::DeclFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Smear::Detector G__TSmearcLcLDetector;
static int G__smearDict_463_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 1
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (Smear::Detector*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((Smear::Detector*) (soff+(sizeof(Smear::Detector)*i)))->~G__TSmearcLcLDetector();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (Smear::Detector*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((Smear::Detector*) (soff))->~G__TSmearcLcLDetector();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Smear::ParticleID */
static int G__smearDict_765_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Smear::ParticleID* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Smear::ParticleID[n];
     } else {
       p = new((void*) gvp) Smear::ParticleID[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Smear::ParticleID;
     } else {
       p = new((void*) gvp) Smear::ParticleID;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__smearDictLN_SmearcLcLParticleID));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_765_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Smear::ParticleID* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new Smear::ParticleID(*((TString*) G__int(libp->para[0])));
   } else {
     p = new((void*) gvp) Smear::ParticleID(*((TString*) G__int(libp->para[0])));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__smearDictLN_SmearcLcLParticleID));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_765_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Smear::ParticleID*) G__getstructoffset())->SetPMatrixPath(*((TString*) G__int(libp->para[0])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_765_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Smear::ParticleID*) G__getstructoffset())->SetPIDUseMC((bool) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_765_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const TRandom3& obj = ((Smear::ParticleID*) G__getstructoffset())->GetRandomGenerator();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_765_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Smear::ParticleID*) G__getstructoffset())->SetRanSeed((int) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_765_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Smear::ParticleID*) G__getstructoffset())->GetAcceptanceFromDevice(*(Smear::Device*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_765_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Smear::ParticleID*) G__getstructoffset())->SetPMatrixSize();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_765_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Smear::ParticleID*) G__getstructoffset())->SetupProbabilityArray();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_765_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((Smear::ParticleID*) G__getstructoffset())->Wild((int) G__int(libp->para[0]), (int) G__int(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_765_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((Smear::ParticleID*) G__getstructoffset())->InListOfTrue((int) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_765_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((Smear::ParticleID*) G__getstructoffset())->InListOfFalse((int) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_765_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Smear::ParticleID*) G__getstructoffset())->ReadP(*((TString*) G__int(libp->para[0])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_765_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Smear::ParticleID*) G__getstructoffset())->Speak();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_765_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) Smear::ParticleID::Class());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_765_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) Smear::ParticleID::Class_Name());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_765_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 115, (long) Smear::ParticleID::Class_Version());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_765_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      Smear::ParticleID::Dictionary();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_765_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Smear::ParticleID*) G__getstructoffset())->StreamerNVirtual(*(TBuffer*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_765_0_27(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) Smear::ParticleID::DeclFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_765_0_28(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) Smear::ParticleID::ImplFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_765_0_29(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) Smear::ParticleID::ImplFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_765_0_30(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) Smear::ParticleID::DeclFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__smearDict_765_0_31(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   Smear::ParticleID* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new Smear::ParticleID(*(Smear::ParticleID*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__smearDictLN_SmearcLcLParticleID));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Smear::ParticleID G__TSmearcLcLParticleID;
static int G__smearDict_765_0_32(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 1
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (Smear::ParticleID*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((Smear::ParticleID*) (soff+(sizeof(Smear::ParticleID)*i)))->~G__TSmearcLcLParticleID();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (Smear::ParticleID*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((Smear::ParticleID*) (soff))->~G__TSmearcLcLParticleID();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__smearDict_765_0_33(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Smear::ParticleID* dest = (Smear::ParticleID*) G__getstructoffset();
   *dest = *(Smear::ParticleID*) libp->para[0].ref;
   const Smear::ParticleID& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* vector<int,allocator<int> > */
static int G__smearDict_766_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<int,allocator<int> >::reference obj = ((vector<int,allocator<int> >*) G__getstructoffset())->at((vector<int,allocator<int> >::size_type) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         G__letint(result7, 'i', (long)obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_766_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<int,allocator<int> >::const_reference obj = ((const vector<int,allocator<int> >*) G__getstructoffset())->at((vector<int,allocator<int> >::size_type) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         G__letint(result7, 'i', (long)obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_766_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<int,allocator<int> >::iterator* pobj;
         vector<int,allocator<int> >::iterator xobj = ((vector<int,allocator<int> >*) G__getstructoffset())->begin();
         pobj = new vector<int,allocator<int> >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_766_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<int,allocator<int> >::iterator* pobj;
         vector<int,allocator<int> >::iterator xobj = ((vector<int,allocator<int> >*) G__getstructoffset())->end();
         pobj = new vector<int,allocator<int> >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_766_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<int,allocator<int> >::reverse_iterator* pobj;
         vector<int,allocator<int> >::reverse_iterator xobj = ((vector<int,allocator<int> >*) G__getstructoffset())->rbegin();
         pobj = new vector<int,allocator<int> >::reverse_iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_766_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<int,allocator<int> >::reverse_iterator* pobj;
         vector<int,allocator<int> >::reverse_iterator xobj = ((vector<int,allocator<int> >*) G__getstructoffset())->rend();
         pobj = new vector<int,allocator<int> >::reverse_iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_766_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 107, (long) ((const vector<int,allocator<int> >*) G__getstructoffset())->size());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_766_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 107, (long) ((const vector<int,allocator<int> >*) G__getstructoffset())->max_size());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_766_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<int,allocator<int> >*) G__getstructoffset())->resize((vector<int,allocator<int> >::size_type) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_766_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<int,allocator<int> >*) G__getstructoffset())->resize((vector<int,allocator<int> >::size_type) G__int(libp->para[0]), (int) G__int(libp->para[1]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_766_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 107, (long) ((const vector<int,allocator<int> >*) G__getstructoffset())->capacity());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_766_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const vector<int,allocator<int> >*) G__getstructoffset())->empty());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_766_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<int,allocator<int> >::reference obj = ((vector<int,allocator<int> >*) G__getstructoffset())->operator[]((vector<int,allocator<int> >::size_type) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         G__letint(result7, 'i', (long)obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_766_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<int,allocator<int> >::const_reference obj = ((const vector<int,allocator<int> >*) G__getstructoffset())->operator[]((vector<int,allocator<int> >::size_type) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         G__letint(result7, 'i', (long)obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_766_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<int,allocator<int> >* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<int,allocator<int> >[n];
     } else {
       p = new((void*) gvp) vector<int,allocator<int> >[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<int,allocator<int> >;
     } else {
       p = new((void*) gvp) vector<int,allocator<int> >;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__smearDictLN_vectorlEintcOallocatorlEintgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_766_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<int,allocator<int> >* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<int,allocator<int> >((vector<int,allocator<int> >::size_type) G__int(libp->para[0]), *(int*) G__Intref(&libp->para[1]));
     } else {
       p = new((void*) gvp) vector<int,allocator<int> >((vector<int,allocator<int> >::size_type) G__int(libp->para[0]), *(int*) G__Intref(&libp->para[1]));
     }
     break;
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<int,allocator<int> >((vector<int,allocator<int> >::size_type) G__int(libp->para[0]));
     } else {
       p = new((void*) gvp) vector<int,allocator<int> >((vector<int,allocator<int> >::size_type) G__int(libp->para[0]));
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__smearDictLN_vectorlEintcOallocatorlEintgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_766_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<int,allocator<int> >* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new vector<int,allocator<int> >(*(vector<int,allocator<int> >*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) vector<int,allocator<int> >(*(vector<int,allocator<int> >*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__smearDictLN_vectorlEintcOallocatorlEintgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_766_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<int,allocator<int> >* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new vector<int,allocator<int> >(*((vector<int,allocator<int> >::const_iterator*) G__int(libp->para[0])), *((vector<int,allocator<int> >::const_iterator*) G__int(libp->para[1])));
   } else {
     p = new((void*) gvp) vector<int,allocator<int> >(*((vector<int,allocator<int> >::const_iterator*) G__int(libp->para[0])), *((vector<int,allocator<int> >::const_iterator*) G__int(libp->para[1])));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__smearDictLN_vectorlEintcOallocatorlEintgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_766_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<int,allocator<int> >& obj = ((vector<int,allocator<int> >*) G__getstructoffset())->operator=(*(vector<int,allocator<int> >*) libp->para[0].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_766_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<int,allocator<int> >*) G__getstructoffset())->reserve((vector<int,allocator<int> >::size_type) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_766_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const int& obj = ((vector<int,allocator<int> >*) G__getstructoffset())->front();
         result7->ref = (long) (&obj);
         G__letint(result7, 'i', (long)obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_766_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const int& obj = ((vector<int,allocator<int> >*) G__getstructoffset())->back();
         result7->ref = (long) (&obj);
         G__letint(result7, 'i', (long)obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_766_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<int,allocator<int> >*) G__getstructoffset())->push_back(*(int*) G__Intref(&libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_766_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<int,allocator<int> >*) G__getstructoffset())->swap(*(vector<int,allocator<int> >*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_766_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<int,allocator<int> >::iterator* pobj;
         vector<int,allocator<int> >::iterator xobj = ((vector<int,allocator<int> >*) G__getstructoffset())->insert(*((vector<int,allocator<int> >::iterator*) G__int(libp->para[0])), *(int*) G__Intref(&libp->para[1]));
         pobj = new vector<int,allocator<int> >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_766_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<int,allocator<int> >*) G__getstructoffset())->insert(*((vector<int,allocator<int> >::iterator*) G__int(libp->para[0])), *((vector<int,allocator<int> >::const_iterator*) G__int(libp->para[1]))
, *((vector<int,allocator<int> >::const_iterator*) G__int(libp->para[2])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_766_0_27(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<int,allocator<int> >*) G__getstructoffset())->insert(*((vector<int,allocator<int> >::iterator*) G__int(libp->para[0])), (vector<int,allocator<int> >::size_type) G__int(libp->para[1])
, *(int*) G__Intref(&libp->para[2]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_766_0_28(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<int,allocator<int> >*) G__getstructoffset())->pop_back();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_766_0_29(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<int,allocator<int> >*) G__getstructoffset())->erase(*((vector<int,allocator<int> >::iterator*) G__int(libp->para[0])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_766_0_30(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<int,allocator<int> >*) G__getstructoffset())->erase(*((vector<int,allocator<int> >::iterator*) G__int(libp->para[0])), *((vector<int,allocator<int> >::iterator*) G__int(libp->para[1])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_766_0_31(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<int,allocator<int> >*) G__getstructoffset())->clear();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef vector<int,allocator<int> > G__TvectorlEintcOallocatorlEintgRsPgR;
static int G__smearDict_766_0_32(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (vector<int,allocator<int> >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((vector<int,allocator<int> >*) (soff+(sizeof(vector<int,allocator<int> >)*i)))->~G__TvectorlEintcOallocatorlEintgRsPgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (vector<int,allocator<int> >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((vector<int,allocator<int> >*) (soff))->~G__TvectorlEintcOallocatorlEintgRsPgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Smear::PerfectID */
static int G__smearDict_777_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Smear::PerfectID* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Smear::PerfectID(*(vector<Int_t>*) libp->para[0].ref);
     } else {
       p = new((void*) gvp) Smear::PerfectID(*(vector<Int_t>*) libp->para[0].ref);
     }
     break;
   case 0:
     int n = G__getaryconstruct();
     if (n) {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new Smear::PerfectID[n];
       } else {
         p = new((void*) gvp) Smear::PerfectID[n];
       }
     } else {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new Smear::PerfectID;
       } else {
         p = new((void*) gvp) Smear::PerfectID;
       }
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__smearDictLN_SmearcLcLPerfectID));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_777_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Smear::PerfectID*) G__getstructoffset())->Insert((Int_t) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_777_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) Smear::PerfectID::Class());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_777_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) Smear::PerfectID::Class_Name());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_777_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 115, (long) Smear::PerfectID::Class_Version());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_777_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      Smear::PerfectID::Dictionary();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_777_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Smear::PerfectID*) G__getstructoffset())->StreamerNVirtual(*(TBuffer*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_777_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) Smear::PerfectID::DeclFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_777_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) Smear::PerfectID::ImplFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_777_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) Smear::PerfectID::ImplFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_777_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) Smear::PerfectID::DeclFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__smearDict_777_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   Smear::PerfectID* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new Smear::PerfectID(*(Smear::PerfectID*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__smearDictLN_SmearcLcLPerfectID));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Smear::PerfectID G__TSmearcLcLPerfectID;
static int G__smearDict_777_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 1
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (Smear::PerfectID*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((Smear::PerfectID*) (soff+(sizeof(Smear::PerfectID)*i)))->~G__TSmearcLcLPerfectID();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (Smear::PerfectID*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((Smear::PerfectID*) (soff))->~G__TSmearcLcLPerfectID();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__smearDict_777_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Smear::PerfectID* dest = (Smear::PerfectID*) G__getstructoffset();
   *dest = *(Smear::PerfectID*) libp->para[0].ref;
   const Smear::PerfectID& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Smear::Tracker */
static int G__smearDict_778_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const Smear::Tracker*) G__getstructoffset())->Resolution(*(erhic::VirtualParticle*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_778_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const Smear::Tracker*) G__getstructoffset())->L(*(erhic::VirtualParticle*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_778_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const Smear::Tracker*) G__getstructoffset())->LPrime(*(erhic::VirtualParticle*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_778_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const Smear::Tracker*) G__getstructoffset())->NPoints(*(erhic::VirtualParticle*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_778_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Smear::Tracker*) G__getstructoffset())->Accepts(*(erhic::VirtualParticle*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_778_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const Smear::Tracker*) G__getstructoffset())->GetThetaMin());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_778_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const Smear::Tracker*) G__getstructoffset())->GetThetaMax());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_778_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Smear::Tracker*) G__getstructoffset())->SetVertexConstraint((bool) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_778_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) Smear::Tracker::Class());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_778_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) Smear::Tracker::Class_Name());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_778_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 115, (long) Smear::Tracker::Class_Version());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_778_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      Smear::Tracker::Dictionary();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_778_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Smear::Tracker*) G__getstructoffset())->StreamerNVirtual(*(TBuffer*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_778_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) Smear::Tracker::DeclFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_778_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) Smear::Tracker::ImplFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_778_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) Smear::Tracker::ImplFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_778_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) Smear::Tracker::DeclFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Smear::Tracker G__TSmearcLcLTracker;
static int G__smearDict_778_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 1
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (Smear::Tracker*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((Smear::Tracker*) (soff+(sizeof(Smear::Tracker)*i)))->~G__TSmearcLcLTracker();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (Smear::Tracker*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((Smear::Tracker*) (soff))->~G__TSmearcLcLTracker();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__smearDict_778_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Smear::Tracker* dest = (Smear::Tracker*) G__getstructoffset();
   *dest = *(Smear::Tracker*) libp->para[0].ref;
   const Smear::Tracker& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Smear::PlanarTracker */
static int G__smearDict_779_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Smear::PlanarTracker* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Smear::PlanarTracker[n];
     } else {
       p = new((void*) gvp) Smear::PlanarTracker[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Smear::PlanarTracker;
     } else {
       p = new((void*) gvp) Smear::PlanarTracker;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__smearDictLN_SmearcLcLPlanarTracker));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_779_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Smear::PlanarTracker* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 8
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new Smear::PlanarTracker(
(double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])
, (double) G__double(libp->para[4]), (double) G__double(libp->para[5])
, (double) G__double(libp->para[6]), (double) G__double(libp->para[7]));
   } else {
     p = new((void*) gvp) Smear::PlanarTracker(
(double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])
, (double) G__double(libp->para[4]), (double) G__double(libp->para[5])
, (double) G__double(libp->para[6]), (double) G__double(libp->para[7]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__smearDictLN_SmearcLcLPlanarTracker));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_779_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) Smear::PlanarTracker::Class());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_779_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) Smear::PlanarTracker::Class_Name());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_779_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 115, (long) Smear::PlanarTracker::Class_Version());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_779_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      Smear::PlanarTracker::Dictionary();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_779_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Smear::PlanarTracker*) G__getstructoffset())->StreamerNVirtual(*(TBuffer*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_779_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) Smear::PlanarTracker::DeclFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_779_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) Smear::PlanarTracker::ImplFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_779_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) Smear::PlanarTracker::ImplFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_779_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) Smear::PlanarTracker::DeclFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__smearDict_779_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   Smear::PlanarTracker* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new Smear::PlanarTracker(*(Smear::PlanarTracker*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__smearDictLN_SmearcLcLPlanarTracker));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Smear::PlanarTracker G__TSmearcLcLPlanarTracker;
static int G__smearDict_779_0_27(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 1
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (Smear::PlanarTracker*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((Smear::PlanarTracker*) (soff+(sizeof(Smear::PlanarTracker)*i)))->~G__TSmearcLcLPlanarTracker();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (Smear::PlanarTracker*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((Smear::PlanarTracker*) (soff))->~G__TSmearcLcLPlanarTracker();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__smearDict_779_0_28(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Smear::PlanarTracker* dest = (Smear::PlanarTracker*) G__getstructoffset();
   *dest = *(Smear::PlanarTracker*) libp->para[0].ref;
   const Smear::PlanarTracker& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Smear::RadialTracker */
static int G__smearDict_780_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Smear::RadialTracker* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Smear::RadialTracker[n];
     } else {
       p = new((void*) gvp) Smear::RadialTracker[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Smear::RadialTracker;
     } else {
       p = new((void*) gvp) Smear::RadialTracker;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__smearDictLN_SmearcLcLRadialTracker));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_780_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Smear::RadialTracker* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 8
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new Smear::RadialTracker(
(double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])
, (double) G__double(libp->para[4]), (double) G__double(libp->para[5])
, (double) G__double(libp->para[6]), (double) G__double(libp->para[7]));
   } else {
     p = new((void*) gvp) Smear::RadialTracker(
(double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])
, (double) G__double(libp->para[4]), (double) G__double(libp->para[5])
, (double) G__double(libp->para[6]), (double) G__double(libp->para[7]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__smearDictLN_SmearcLcLRadialTracker));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_780_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) Smear::RadialTracker::Class());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_780_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) Smear::RadialTracker::Class_Name());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_780_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 115, (long) Smear::RadialTracker::Class_Version());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_780_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      Smear::RadialTracker::Dictionary();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_780_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Smear::RadialTracker*) G__getstructoffset())->StreamerNVirtual(*(TBuffer*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_780_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) Smear::RadialTracker::DeclFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_780_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) Smear::RadialTracker::ImplFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_780_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) Smear::RadialTracker::ImplFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__smearDict_780_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) Smear::RadialTracker::DeclFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__smearDict_780_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   Smear::RadialTracker* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new Smear::RadialTracker(*(Smear::RadialTracker*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__smearDictLN_SmearcLcLRadialTracker));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Smear::RadialTracker G__TSmearcLcLRadialTracker;
static int G__smearDict_780_0_27(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 1
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (Smear::RadialTracker*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((Smear::RadialTracker*) (soff+(sizeof(Smear::RadialTracker)*i)))->~G__TSmearcLcLRadialTracker();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (Smear::RadialTracker*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((Smear::RadialTracker*) (soff))->~G__TSmearcLcLRadialTracker();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__smearDict_780_0_28(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Smear::RadialTracker* dest = (Smear::RadialTracker*) G__getstructoffset();
   *dest = *(Smear::RadialTracker*) libp->para[0].ref;
   const Smear::RadialTracker& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Setting up global function */
static int G__smearDict__0_3775(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 4:
      G__letint(result7, 105, (long) SmearTree(*(Smear::Detector*) libp->para[0].ref, *(TString*) libp->para[1].ref
, *(TString*) libp->para[2].ref, (Long64_t) G__Longlong(libp->para[3])));
      break;
   case 3:
      G__letint(result7, 105, (long) SmearTree(*(Smear::Detector*) libp->para[0].ref, *(TString*) libp->para[1].ref
, *(TString*) libp->para[2].ref));
      break;
   case 2:
      G__letint(result7, 105, (long) SmearTree(*(Smear::Detector*) libp->para[0].ref, *(TString*) libp->para[1].ref));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}


/*********************************************************
* Member function Stub
*********************************************************/

/* Smear */

/* Smear::Event */

/* Smear::ParticleMCS */

/* Smear::Acceptance */

/* Smear::Acceptance::CustomCut */

/* Smear::Acceptance::Zone */

/* Smear::Distributor */

/* Smear::Smearer */

/* Smear::FormulaString */

/* Smear::Device */

/* vector<Smear::KinType,allocator<Smear::KinType> > */

/* Smear::Bremsstrahlung */

/* auto_ptr<erhic::ParticleMC> */

/* Smear::Detector */

/* Smear::ParticleID */

/* vector<int,allocator<int> > */

/* Smear::PerfectID */

/* Smear::Tracker */

/* Smear::PlanarTracker */

/* Smear::RadialTracker */

/*********************************************************
* Global function Stub
*********************************************************/

/*********************************************************
* Get size of pointer to member function
*********************************************************/
class G__Sizep2memfuncsmearDict {
 public:
  G__Sizep2memfuncsmearDict(): p(&G__Sizep2memfuncsmearDict::sizep2memfunc) {}
    size_t sizep2memfunc() { return(sizeof(p)); }
  private:
    size_t (G__Sizep2memfuncsmearDict::*p)();
};

size_t G__get_sizep2memfuncsmearDict()
{
  G__Sizep2memfuncsmearDict a;
  G__setsizep2memfunc((int)a.sizep2memfunc());
  return((size_t)a.sizep2memfunc());
}


/*********************************************************
* virtual base class offset calculation interface
*********************************************************/

   /* Setting up class inheritance */

/*********************************************************
* Inheritance information setup/
*********************************************************/
extern "C" void G__cpp_setup_inheritancesmearDict() {

   /* Setting up class inheritance */
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__smearDictLN_SmearcLcLEvent))) {
     Smear::Event *G__Lderived;
     G__Lderived=(Smear::Event*)0x1000;
     {
       erhic::EventDis *G__Lpbase=(erhic::EventDis*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__smearDictLN_SmearcLcLEvent),G__get_linked_tagnum(&G__smearDictLN_erhiccLcLEventDis),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       erhic::VirtualEvent *G__Lpbase=(erhic::VirtualEvent*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__smearDictLN_SmearcLcLEvent),G__get_linked_tagnum(&G__smearDictLN_erhiccLcLVirtualEvent),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
     {
       TObject *G__Lpbase=(TObject*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__smearDictLN_SmearcLcLEvent),G__get_linked_tagnum(&G__smearDictLN_TObject),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__smearDictLN_SmearcLcLParticleMCS))) {
     Smear::ParticleMCS *G__Lderived;
     G__Lderived=(Smear::ParticleMCS*)0x1000;
     {
       erhic::VirtualParticle *G__Lpbase=(erhic::VirtualParticle*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__smearDictLN_SmearcLcLParticleMCS),G__get_linked_tagnum(&G__smearDictLN_erhiccLcLVirtualParticle),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       TObject *G__Lpbase=(TObject*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__smearDictLN_SmearcLcLParticleMCS),G__get_linked_tagnum(&G__smearDictLN_TObject),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__smearDictLN_SmearcLcLSmearer))) {
     Smear::Smearer *G__Lderived;
     G__Lderived=(Smear::Smearer*)0x1000;
     {
       TObject *G__Lpbase=(TObject*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__smearDictLN_SmearcLcLSmearer),G__get_linked_tagnum(&G__smearDictLN_TObject),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__smearDictLN_SmearcLcLFormulaString))) {
     Smear::FormulaString *G__Lderived;
     G__Lderived=(Smear::FormulaString*)0x1000;
     {
       TObject *G__Lpbase=(TObject*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__smearDictLN_SmearcLcLFormulaString),G__get_linked_tagnum(&G__smearDictLN_TObject),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__smearDictLN_SmearcLcLDevice))) {
     Smear::Device *G__Lderived;
     G__Lderived=(Smear::Device*)0x1000;
     {
       Smear::Smearer *G__Lpbase=(Smear::Smearer*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__smearDictLN_SmearcLcLDevice),G__get_linked_tagnum(&G__smearDictLN_SmearcLcLSmearer),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       TObject *G__Lpbase=(TObject*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__smearDictLN_SmearcLcLDevice),G__get_linked_tagnum(&G__smearDictLN_TObject),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__smearDictLN_SmearcLcLBremsstrahlung))) {
     Smear::Bremsstrahlung *G__Lderived;
     G__Lderived=(Smear::Bremsstrahlung*)0x1000;
     {
       Smear::Device *G__Lpbase=(Smear::Device*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__smearDictLN_SmearcLcLBremsstrahlung),G__get_linked_tagnum(&G__smearDictLN_SmearcLcLDevice),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       Smear::Smearer *G__Lpbase=(Smear::Smearer*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__smearDictLN_SmearcLcLBremsstrahlung),G__get_linked_tagnum(&G__smearDictLN_SmearcLcLSmearer),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
     {
       TObject *G__Lpbase=(TObject*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__smearDictLN_SmearcLcLBremsstrahlung),G__get_linked_tagnum(&G__smearDictLN_TObject),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__smearDictLN_SmearcLcLDetector))) {
     Smear::Detector *G__Lderived;
     G__Lderived=(Smear::Detector*)0x1000;
     {
       TObject *G__Lpbase=(TObject*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__smearDictLN_SmearcLcLDetector),G__get_linked_tagnum(&G__smearDictLN_TObject),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__smearDictLN_SmearcLcLParticleID))) {
     Smear::ParticleID *G__Lderived;
     G__Lderived=(Smear::ParticleID*)0x1000;
     {
       Smear::Smearer *G__Lpbase=(Smear::Smearer*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__smearDictLN_SmearcLcLParticleID),G__get_linked_tagnum(&G__smearDictLN_SmearcLcLSmearer),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       TObject *G__Lpbase=(TObject*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__smearDictLN_SmearcLcLParticleID),G__get_linked_tagnum(&G__smearDictLN_TObject),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__smearDictLN_SmearcLcLPerfectID))) {
     Smear::PerfectID *G__Lderived;
     G__Lderived=(Smear::PerfectID*)0x1000;
     {
       Smear::Smearer *G__Lpbase=(Smear::Smearer*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__smearDictLN_SmearcLcLPerfectID),G__get_linked_tagnum(&G__smearDictLN_SmearcLcLSmearer),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       TObject *G__Lpbase=(TObject*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__smearDictLN_SmearcLcLPerfectID),G__get_linked_tagnum(&G__smearDictLN_TObject),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__smearDictLN_SmearcLcLTracker))) {
     Smear::Tracker *G__Lderived;
     G__Lderived=(Smear::Tracker*)0x1000;
     {
       Smear::Smearer *G__Lpbase=(Smear::Smearer*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__smearDictLN_SmearcLcLTracker),G__get_linked_tagnum(&G__smearDictLN_SmearcLcLSmearer),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       TObject *G__Lpbase=(TObject*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__smearDictLN_SmearcLcLTracker),G__get_linked_tagnum(&G__smearDictLN_TObject),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__smearDictLN_SmearcLcLPlanarTracker))) {
     Smear::PlanarTracker *G__Lderived;
     G__Lderived=(Smear::PlanarTracker*)0x1000;
     {
       Smear::Tracker *G__Lpbase=(Smear::Tracker*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__smearDictLN_SmearcLcLPlanarTracker),G__get_linked_tagnum(&G__smearDictLN_SmearcLcLTracker),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       Smear::Smearer *G__Lpbase=(Smear::Smearer*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__smearDictLN_SmearcLcLPlanarTracker),G__get_linked_tagnum(&G__smearDictLN_SmearcLcLSmearer),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
     {
       TObject *G__Lpbase=(TObject*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__smearDictLN_SmearcLcLPlanarTracker),G__get_linked_tagnum(&G__smearDictLN_TObject),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__smearDictLN_SmearcLcLRadialTracker))) {
     Smear::RadialTracker *G__Lderived;
     G__Lderived=(Smear::RadialTracker*)0x1000;
     {
       Smear::Tracker *G__Lpbase=(Smear::Tracker*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__smearDictLN_SmearcLcLRadialTracker),G__get_linked_tagnum(&G__smearDictLN_SmearcLcLTracker),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       Smear::Smearer *G__Lpbase=(Smear::Smearer*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__smearDictLN_SmearcLcLRadialTracker),G__get_linked_tagnum(&G__smearDictLN_SmearcLcLSmearer),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
     {
       TObject *G__Lpbase=(TObject*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__smearDictLN_SmearcLcLRadialTracker),G__get_linked_tagnum(&G__smearDictLN_TObject),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
   }
}

/*********************************************************
* typedef information setup/
*********************************************************/
extern "C" void G__cpp_setup_typetablesmearDict() {

   /* Setting up typedef entry */
   G__search_typename2("Int_t",105,-1,0,-1);
   G__setnewtype(-1,"Signed integer 4 bytes (int)",0);
   G__search_typename2("UInt_t",104,-1,0,-1);
   G__setnewtype(-1,"Unsigned integer 4 bytes (unsigned int)",0);
   G__search_typename2("Double_t",100,-1,0,-1);
   G__setnewtype(-1,"Double 8 bytes",0);
   G__search_typename2("Bool_t",103,-1,0,-1);
   G__setnewtype(-1,"Boolean (0=false, 1=true) (bool)",0);
   G__search_typename2("Version_t",115,-1,0,-1);
   G__setnewtype(-1,"Class version identifier (short)",0);
   G__search_typename2("Long64_t",110,-1,0,-1);
   G__setnewtype(-1,"Portable signed long integer 8 bytes",0);
   G__search_typename2("vector<ROOT::TSchemaHelper>",117,G__get_linked_tagnum(&G__smearDictLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__smearDictLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__smearDictLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__smearDictLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__smearDictLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<TVirtualArray*>",117,G__get_linked_tagnum(&G__smearDictLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__smearDictLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__smearDictLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__smearDictLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__smearDictLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<std::bidirectional_iterator_tag,TObject*,std::ptrdiff_t,const TObject**,const TObject*&>",117,G__get_linked_tagnum(&G__smearDictLN_iteratorlEbidirectional_iterator_tagcOTObjectmUcOlongcOconstsPTObjectmUmUcOconstsPTObjectmUaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<bidirectional_iterator_tag,TObject*,std::ptrdiff_t,const TObject**,const TObject*&>",117,G__get_linked_tagnum(&G__smearDictLN_iteratorlEbidirectional_iterator_tagcOTObjectmUcOlongcOconstsPTObjectmUmUcOconstsPTObjectmUaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<bidirectional_iterator_tag,TObject*>",117,G__get_linked_tagnum(&G__smearDictLN_iteratorlEbidirectional_iterator_tagcOTObjectmUcOlongcOconstsPTObjectmUmUcOconstsPTObjectmUaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<bidirectional_iterator_tag,TObject*,long>",117,G__get_linked_tagnum(&G__smearDictLN_iteratorlEbidirectional_iterator_tagcOTObjectmUcOlongcOconstsPTObjectmUmUcOconstsPTObjectmUaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<bidirectional_iterator_tag,TObject*,long,const TObject**>",117,G__get_linked_tagnum(&G__smearDictLN_iteratorlEbidirectional_iterator_tagcOTObjectmUcOlongcOconstsPTObjectmUmUcOconstsPTObjectmUaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TMatrixTBase<Float_t>",117,G__get_linked_tagnum(&G__smearDictLN_TMatrixTBaselEfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TMatrixTBase<Double_t>",117,G__get_linked_tagnum(&G__smearDictLN_TMatrixTBaselEdoublegR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TVectorT<Float_t>",117,G__get_linked_tagnum(&G__smearDictLN_TVectorTlEfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TVectorT<Double_t>",117,G__get_linked_tagnum(&G__smearDictLN_TVectorTlEdoublegR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TMatrixT<Float_t>",117,G__get_linked_tagnum(&G__smearDictLN_TMatrixTlEfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TMatrixTRow_const<Float_t>",117,G__get_linked_tagnum(&G__smearDictLN_TMatrixTRow_constlEfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TMatrixTColumn_const<Float_t>",117,G__get_linked_tagnum(&G__smearDictLN_TMatrixTColumn_constlEfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TMatrixTDiag_const<Float_t>",117,G__get_linked_tagnum(&G__smearDictLN_TMatrixTDiag_constlEfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TMatrixTFlat_const<Float_t>",117,G__get_linked_tagnum(&G__smearDictLN_TMatrixTFlat_constlEfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TMatrixTSub_const<Float_t>",117,G__get_linked_tagnum(&G__smearDictLN_TMatrixTSub_constlEfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TMatrixTSparseRow_const<Float_t>",117,G__get_linked_tagnum(&G__smearDictLN_TMatrixTSparseRow_constlEfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TMatrixTSparseDiag_const<Float_t>",117,G__get_linked_tagnum(&G__smearDictLN_TMatrixTSparseDiag_constlEfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TMatrixTRow<Float_t>",117,G__get_linked_tagnum(&G__smearDictLN_TMatrixTRowlEfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TMatrixTColumn<Float_t>",117,G__get_linked_tagnum(&G__smearDictLN_TMatrixTColumnlEfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TMatrixTDiag<Float_t>",117,G__get_linked_tagnum(&G__smearDictLN_TMatrixTDiaglEfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TMatrixTFlat<Float_t>",117,G__get_linked_tagnum(&G__smearDictLN_TMatrixTFlatlEfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TMatrixTSub<Float_t>",117,G__get_linked_tagnum(&G__smearDictLN_TMatrixTSublEfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TMatrixTSparseRow<Float_t>",117,G__get_linked_tagnum(&G__smearDictLN_TMatrixTSparseRowlEfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TMatrixTSparseDiag<Float_t>",117,G__get_linked_tagnum(&G__smearDictLN_TMatrixTSparseDiaglEfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TElementActionT<Float_t>",117,G__get_linked_tagnum(&G__smearDictLN_TElementActionTlEfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TElementPosActionT<Float_t>",117,G__get_linked_tagnum(&G__smearDictLN_TElementPosActionTlEfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<UInt_t>",117,G__get_linked_tagnum(&G__smearDictLN_vectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<TString>",117,G__get_linked_tagnum(&G__smearDictLN_vectorlETStringcOallocatorlETStringgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__smearDictLN_reverse_iteratorlEvectorlETStringcOallocatorlETStringgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__smearDictLN_vectorlETStringcOallocatorlETStringgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__smearDictLN_reverse_iteratorlEvectorlETStringcOallocatorlETStringgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__smearDictLN_vectorlETStringcOallocatorlETStringgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<const erhic::VirtualParticle*>",117,G__get_linked_tagnum(&G__smearDictLN_vectorlEconstsPerhiccLcLVirtualParticlemUcOallocatorlEconstsPerhiccLcLVirtualParticlemUgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__smearDictLN_reverse_iteratorlEvectorlEconstsPerhiccLcLVirtualParticlemUcOallocatorlEconstsPerhiccLcLVirtualParticlemUgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__smearDictLN_vectorlEconstsPerhiccLcLVirtualParticlemUcOallocatorlEconstsPerhiccLcLVirtualParticlemUgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__smearDictLN_reverse_iteratorlEvectorlEconstsPerhiccLcLVirtualParticlemUcOallocatorlEconstsPerhiccLcLVirtualParticlemUgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__smearDictLN_vectorlEconstsPerhiccLcLVirtualParticlemUcOallocatorlEconstsPerhiccLcLVirtualParticlemUgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<Smear::Acceptance::CustomCut>",117,G__get_linked_tagnum(&G__smearDictLN_vectorlESmearcLcLAcceptancecLcLCustomCutcOallocatorlESmearcLcLAcceptancecLcLCustomCutgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__smearDictLN_reverse_iteratorlEvectorlESmearcLcLAcceptancecLcLCustomCutcOallocatorlESmearcLcLAcceptancecLcLCustomCutgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__smearDictLN_vectorlESmearcLcLAcceptancecLcLCustomCutcOallocatorlESmearcLcLAcceptancecLcLCustomCutgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__smearDictLN_reverse_iteratorlEvectorlESmearcLcLAcceptancecLcLCustomCutcOallocatorlESmearcLcLAcceptancecLcLCustomCutgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__smearDictLN_vectorlESmearcLcLAcceptancecLcLCustomCutcOallocatorlESmearcLcLAcceptancecLcLCustomCutgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<Zone>",117,G__get_linked_tagnum(&G__smearDictLN_vectorlESmearcLcLAcceptancecLcLZonecOallocatorlESmearcLcLAcceptancecLcLZonegRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__smearDictLN_reverse_iteratorlEvectorlESmearcLcLAcceptancecLcLZonecOallocatorlESmearcLcLAcceptancecLcLZonegRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__smearDictLN_vectorlESmearcLcLAcceptancecLcLZonecOallocatorlESmearcLcLAcceptancecLcLZonegRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__smearDictLN_reverse_iteratorlEvectorlESmearcLcLAcceptancecLcLZonecOallocatorlESmearcLcLAcceptancecLcLZonegRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__smearDictLN_vectorlESmearcLcLAcceptancecLcLZonecOallocatorlESmearcLcLAcceptancecLcLZonegRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<Smear::Acceptance::Zone>",117,G__get_linked_tagnum(&G__smearDictLN_vectorlESmearcLcLAcceptancecLcLZonecOallocatorlESmearcLcLAcceptancecLcLZonegRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<Smear::KinType>",117,G__get_linked_tagnum(&G__smearDictLN_vectorlESmearcLcLKinTypecOallocatorlESmearcLcLKinTypegRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("value_type",117,G__get_linked_tagnum(&G__smearDictLN_SmearcLcLKinType),0,G__get_linked_tagnum(&G__smearDictLN_vectorlESmearcLcLKinTypecOallocatorlESmearcLcLKinTypegRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("pointer",85,G__get_linked_tagnum(&G__smearDictLN_SmearcLcLKinType),0,G__get_linked_tagnum(&G__smearDictLN_vectorlESmearcLcLKinTypecOallocatorlESmearcLcLKinTypegRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_pointer",85,G__get_linked_tagnum(&G__smearDictLN_SmearcLcLKinType),256,G__get_linked_tagnum(&G__smearDictLN_vectorlESmearcLcLKinTypecOallocatorlESmearcLcLKinTypegRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reference",117,G__get_linked_tagnum(&G__smearDictLN_SmearcLcLKinType),1,G__get_linked_tagnum(&G__smearDictLN_vectorlESmearcLcLKinTypecOallocatorlESmearcLcLKinTypegRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_reference",117,G__get_linked_tagnum(&G__smearDictLN_SmearcLcLKinType),257,G__get_linked_tagnum(&G__smearDictLN_vectorlESmearcLcLKinTypecOallocatorlESmearcLcLKinTypegRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("size_type",107,-1,0,G__get_linked_tagnum(&G__smearDictLN_vectorlESmearcLcLKinTypecOallocatorlESmearcLcLKinTypegRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("difference_type",108,-1,0,G__get_linked_tagnum(&G__smearDictLN_vectorlESmearcLcLKinTypecOallocatorlESmearcLcLKinTypegRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_iterator",117,G__get_linked_tagnum(&G__smearDictLN_vectorlESmearcLcLKinTypecOallocatorlESmearcLcLKinTypegRsPgRcLcLiterator),256,G__get_linked_tagnum(&G__smearDictLN_vectorlESmearcLcLKinTypecOallocatorlESmearcLcLKinTypegRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__smearDictLN_reverse_iteratorlEvectorlESmearcLcLKinTypecOallocatorlESmearcLcLKinTypegRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__smearDictLN_vectorlESmearcLcLKinTypecOallocatorlESmearcLcLKinTypegRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_reverse_iterator",117,G__get_linked_tagnum(&G__smearDictLN_reverse_iteratorlEvectorlESmearcLcLKinTypecOallocatorlESmearcLcLKinTypegRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__smearDictLN_vectorlESmearcLcLKinTypecOallocatorlESmearcLcLKinTypegRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__smearDictLN_reverse_iteratorlEvectorlESmearcLcLKinTypecOallocatorlESmearcLcLKinTypegRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__smearDictLN_vectorlESmearcLcLKinTypecOallocatorlESmearcLcLKinTypegRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator",117,G__get_linked_tagnum(&G__smearDictLN_reverse_iteratorlEvectorlESmearcLcLKinTypecOallocatorlESmearcLcLKinTypegRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__smearDictLN_vectorlESmearcLcLKinTypecOallocatorlESmearcLcLKinTypegRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("element_type",117,G__get_linked_tagnum(&G__smearDictLN_erhiccLcLParticleMC),0,G__get_linked_tagnum(&G__smearDictLN_auto_ptrlEerhiccLcLParticleMCgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("list<Smear::Smearer*>",117,G__get_linked_tagnum(&G__smearDictLN_listlESmearcLcLSmearermUcOallocatorlESmearcLcLSmearermUgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<Smear::Smearer*>",117,G__get_linked_tagnum(&G__smearDictLN_vectorlESmearcLcLSmearermUcOallocatorlESmearcLcLSmearermUgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__smearDictLN_reverse_iteratorlEvectorlESmearcLcLSmearermUcOallocatorlESmearcLcLSmearermUgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__smearDictLN_vectorlESmearcLcLSmearermUcOallocatorlESmearcLcLSmearermUgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__smearDictLN_reverse_iteratorlEvectorlESmearcLcLSmearermUcOallocatorlESmearcLcLSmearermUgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__smearDictLN_vectorlESmearcLcLSmearermUcOallocatorlESmearcLcLSmearermUgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<Smearer*>",117,G__get_linked_tagnum(&G__smearDictLN_vectorlESmearcLcLSmearermUcOallocatorlESmearcLcLSmearermUgRsPgR),0,G__get_linked_tagnum(&G__smearDictLN_SmearcLcLDetector));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<ParticleMCS*>",117,G__get_linked_tagnum(&G__smearDictLN_vectorlESmearcLcLParticleMCSmUcOallocatorlESmearcLcLParticleMCSmUgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__smearDictLN_reverse_iteratorlEvectorlESmearcLcLParticleMCSmUcOallocatorlESmearcLcLParticleMCSmUgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__smearDictLN_vectorlESmearcLcLParticleMCSmUcOallocatorlESmearcLcLParticleMCSmUgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__smearDictLN_reverse_iteratorlEvectorlESmearcLcLParticleMCSmUcOallocatorlESmearcLcLParticleMCSmUgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__smearDictLN_vectorlESmearcLcLParticleMCSmUcOallocatorlESmearcLcLParticleMCSmUgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<Smear::ParticleMCS*>",117,G__get_linked_tagnum(&G__smearDictLN_vectorlESmearcLcLParticleMCSmUcOallocatorlESmearcLcLParticleMCSmUgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("map<std::string,TObjArray*>",117,G__get_linked_tagnum(&G__smearDictLN_maplEstringcOTObjArraymUcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOTObjArraymUgRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("map<string,TObjArray*>",117,G__get_linked_tagnum(&G__smearDictLN_maplEstringcOTObjArraymUcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOTObjArraymUgRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("map<string,TObjArray*>",117,G__get_linked_tagnum(&G__smearDictLN_maplEstringcOTObjArraymUcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOTObjArraymUgRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("map<string,TObjArray*,less<string> >",117,G__get_linked_tagnum(&G__smearDictLN_maplEstringcOTObjArraymUcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOTObjArraymUgRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<int>",117,G__get_linked_tagnum(&G__smearDictLN_vectorlEintcOallocatorlEintgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("value_type",105,-1,0,G__get_linked_tagnum(&G__smearDictLN_vectorlEintcOallocatorlEintgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("pointer",73,-1,0,G__get_linked_tagnum(&G__smearDictLN_vectorlEintcOallocatorlEintgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_pointer",73,-1,256,G__get_linked_tagnum(&G__smearDictLN_vectorlEintcOallocatorlEintgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reference",105,-1,1,G__get_linked_tagnum(&G__smearDictLN_vectorlEintcOallocatorlEintgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_reference",105,-1,257,G__get_linked_tagnum(&G__smearDictLN_vectorlEintcOallocatorlEintgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("size_type",107,-1,0,G__get_linked_tagnum(&G__smearDictLN_vectorlEintcOallocatorlEintgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("difference_type",108,-1,0,G__get_linked_tagnum(&G__smearDictLN_vectorlEintcOallocatorlEintgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_iterator",117,G__get_linked_tagnum(&G__smearDictLN_vectorlEintcOallocatorlEintgRsPgRcLcLiterator),256,G__get_linked_tagnum(&G__smearDictLN_vectorlEintcOallocatorlEintgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__smearDictLN_reverse_iteratorlEvectorlEintcOallocatorlEintgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__smearDictLN_vectorlEintcOallocatorlEintgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_reverse_iterator",117,G__get_linked_tagnum(&G__smearDictLN_reverse_iteratorlEvectorlEintcOallocatorlEintgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__smearDictLN_vectorlEintcOallocatorlEintgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__smearDictLN_reverse_iteratorlEvectorlEintcOallocatorlEintgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__smearDictLN_vectorlEintcOallocatorlEintgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator",117,G__get_linked_tagnum(&G__smearDictLN_reverse_iteratorlEvectorlEintcOallocatorlEintgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__smearDictLN_vectorlEintcOallocatorlEintgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<std::vector<double> >",117,G__get_linked_tagnum(&G__smearDictLN_vectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<vector<double> >",117,G__get_linked_tagnum(&G__smearDictLN_vectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__smearDictLN_reverse_iteratorlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__smearDictLN_vectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__smearDictLN_reverse_iteratorlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__smearDictLN_vectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<vector<double,allocator<double> > >",117,G__get_linked_tagnum(&G__smearDictLN_vectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<std::vector<std::vector<double> > >",117,G__get_linked_tagnum(&G__smearDictLN_vectorlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRcOallocatorlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<vector<vector<double> > >",117,G__get_linked_tagnum(&G__smearDictLN_vectorlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRcOallocatorlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__smearDictLN_reverse_iteratorlEvectorlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRcOallocatorlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRsPgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__smearDictLN_vectorlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRcOallocatorlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__smearDictLN_reverse_iteratorlEvectorlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRcOallocatorlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRsPgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__smearDictLN_vectorlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRcOallocatorlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<vector<vector<double,allocator<double> >,allocator<vector<double,allocator<double> > > > >",117,G__get_linked_tagnum(&G__smearDictLN_vectorlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRcOallocatorlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<Int_t>",117,G__get_linked_tagnum(&G__smearDictLN_vectorlEintcOallocatorlEintgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("set<Int_t>",117,G__get_linked_tagnum(&G__smearDictLN_setlEintcOlesslEintgRcOallocatorlEintgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
}

/*********************************************************
* Data Member information setup/
*********************************************************/

   /* Setting up class,struct,union tag member variable */

   /* Smear */
static void G__setup_memvarSmear(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__smearDictLN_Smear));
   {
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__smearDictLN_SmearcLcLKinType),-1,-2,1,G__FastAllocString(2048).Format("kE=%lldLL",(long long)Smear::kE).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__smearDictLN_SmearcLcLKinType),-1,-2,1,G__FastAllocString(2048).Format("kP=%lldLL",(long long)Smear::kP).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__smearDictLN_SmearcLcLKinType),-1,-2,1,G__FastAllocString(2048).Format("kTheta=%lldLL",(long long)Smear::kTheta).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__smearDictLN_SmearcLcLKinType),-1,-2,1,G__FastAllocString(2048).Format("kPhi=%lldLL",(long long)Smear::kPhi).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__smearDictLN_SmearcLcLKinType),-1,-2,1,G__FastAllocString(2048).Format("kPz=%lldLL",(long long)Smear::kPz).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__smearDictLN_SmearcLcLKinType),-1,-2,1,G__FastAllocString(2048).Format("kPt=%lldLL",(long long)Smear::kPt).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__smearDictLN_SmearcLcLKinType),-1,-2,1,G__FastAllocString(2048).Format("kInvalidKinType=%lldLL",(long long)Smear::kInvalidKinType).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__smearDictLN_SmearcLcLEGenre),-1,-2,1,G__FastAllocString(2048).Format("kAll=%lldLL",(long long)Smear::kAll).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__smearDictLN_SmearcLcLEGenre),-1,-2,1,G__FastAllocString(2048).Format("kElectromagnetic=%lldLL",(long long)Smear::kElectromagnetic).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__smearDictLN_SmearcLcLEGenre),-1,-2,1,G__FastAllocString(2048).Format("kHadronic=%lldLL",(long long)Smear::kHadronic).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__smearDictLN_SmearcLcLECharge),-1,-2,1,G__FastAllocString(2048).Format("kNeutral=%lldLL",(long long)Smear::kNeutral).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__smearDictLN_SmearcLcLECharge),-1,-2,1,G__FastAllocString(2048).Format("kCharged=%lldLL",(long long)Smear::kCharged).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__smearDictLN_SmearcLcLECharge),-1,-2,1,G__FastAllocString(2048).Format("kAllCharges=%lldLL",(long long)Smear::kAllCharges).data(),0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* Smear::Event */
static void G__setup_memvarSmearcLcLEvent(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__smearDictLN_SmearcLcLEvent));
   { Smear::Event *p; p=(Smear::Event*)0x1000; if (p) { }
   G__memvar_setup((void*)0,105,0,0,-1,G__defined_typename("Int_t"),-1,2,"nTracks=",0,"/< Number of particles (intermediate + final)");
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__smearDictLN_vectorlESmearcLcLParticleMCSmUcOallocatorlESmearcLcLParticleMCSmUgRsPgR),G__defined_typename("vector<ParticleMCS*>"),-1,2,"particles=",0,"/< The smeared particle list");
   G__memvar_setup((void*)0,105,0,0,-1,G__defined_typename("Int_t"),-1,2,"mScatteredIndex=",0,(char*)NULL);
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__smearDictLN_TClass),G__defined_typename("atomic_TClass_ptr"),-2,4,"fgIsA=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* Smear::ParticleMCS */
static void G__setup_memvarSmearcLcLParticleMCS(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__smearDictLN_SmearcLcLParticleMCS));
   { Smear::ParticleMCS *p; p=(Smear::ParticleMCS*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->status)-(long)(p)),114,0,0,-1,G__defined_typename("UShort_t"),-1,1,"status=",0,"/< Status code");
   G__memvar_setup((void*)((long)(&p->id)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"id=",0,"/< PDG particle code");
   G__memvar_setup((void*)((long)(&p->px)-(long)(p)),100,0,0,-1,G__defined_typename("Double32_t"),-1,1,"px=",0,"/< x component of particle momentum");
   G__memvar_setup((void*)((long)(&p->py)-(long)(p)),100,0,0,-1,G__defined_typename("Double32_t"),-1,1,"py=",0,"/< y component of particle momentum");
   G__memvar_setup((void*)((long)(&p->pz)-(long)(p)),100,0,0,-1,G__defined_typename("Double32_t"),-1,1,"pz=",0,"/< z component of particle momentum");
   G__memvar_setup((void*)((long)(&p->E)-(long)(p)),100,0,0,-1,G__defined_typename("Double32_t"),-1,1,"E=",0,"/< Energy of particle");
   G__memvar_setup((void*)((long)(&p->pt)-(long)(p)),100,0,0,-1,G__defined_typename("Double32_t"),-1,1,"pt=",0,"/< Transverse momentum of particle");
   G__memvar_setup((void*)((long)(&p->p)-(long)(p)),100,0,0,-1,G__defined_typename("Double32_t"),-1,1,"p=",0,"/< Total momentum of particle");
   G__memvar_setup((void*)((long)(&p->theta)-(long)(p)),100,0,0,-1,G__defined_typename("Double32_t"),-1,1,"theta=",0,"/< Polar angle");
   G__memvar_setup((void*)((long)(&p->phi)-(long)(p)),100,0,0,-1,G__defined_typename("Double32_t"),-1,1,"phi=",0,"/< Azimuthal angle");
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__smearDictLN_TClass),G__defined_typename("atomic_TClass_ptr"),-2,4,"fgIsA=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* Smear::Acceptance */
static void G__setup_memvarSmearcLcLAcceptance(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__smearDictLN_SmearcLcLAcceptance));
   { Smear::Acceptance *p; p=(Smear::Acceptance*)0x1000; if (p) { }
   G__memvar_setup((void*)0,108,0,0,-1,-1,-1,4,"G__virtualinfo=",0,(char*)NULL);
   G__memvar_setup((void*)0,105,0,0,-1,-1,-1,2,"mGenre=",0,(char*)NULL);
   G__memvar_setup((void*)0,105,0,0,G__get_linked_tagnum(&G__smearDictLN_SmearcLcLECharge),-1,-1,2,"mCharge=",0,"Particle charges accepted (neutral, charged or all)");
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__smearDictLN_vectorlESmearcLcLAcceptancecLcLZonecOallocatorlESmearcLcLAcceptancecLcLZonegRsPgR),G__defined_typename("vector<Zone>"),-1,2,"mZones=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__smearDictLN_setlEintcOlesslEintgRcOallocatorlEintgRsPgR),G__defined_typename("set<int>"),-1,2,"mParticles=",0,(char*)NULL);
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__smearDictLN_TClass),G__defined_typename("atomic_TClass_ptr"),-2,4,"fgIsA=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* Smear::Acceptance::CustomCut */
static void G__setup_memvarSmearcLcLAcceptancecLcLCustomCut(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__smearDictLN_SmearcLcLAcceptancecLcLCustomCut));
   { Smear::Acceptance::CustomCut *p; p=(Smear::Acceptance::CustomCut*)0x1000; if (p) { }
   G__memvar_setup((void*)0,108,0,0,-1,-1,-1,4,"G__virtualinfo=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__smearDictLN_TFormula),-1,-1,2,"mFormula=",0,(char*)NULL);
   G__memvar_setup((void*)0,105,0,0,-1,-1,-1,2,"dim=",0,(char*)NULL);
   G__memvar_setup((void*)0,105,0,0,G__get_linked_tagnum(&G__smearDictLN_SmearcLcLKinType),-1,-1,2,"Kin1=",0,(char*)NULL);
   G__memvar_setup((void*)0,105,0,0,G__get_linked_tagnum(&G__smearDictLN_SmearcLcLKinType),-1,-1,2,"Kin2=",0,(char*)NULL);
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,2,"Min=",0,(char*)NULL);
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,2,"Max=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* Smear::Acceptance::Zone */
static void G__setup_memvarSmearcLcLAcceptancecLcLZone(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__smearDictLN_SmearcLcLAcceptancecLcLZone));
   { Smear::Acceptance::Zone *p; p=(Smear::Acceptance::Zone*)0x1000; if (p) { }
   G__memvar_setup((void*)0,108,0,0,-1,-1,-1,4,"G__virtualinfo=",0,(char*)NULL);
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,2,"thetaMin=",0,(char*)NULL);
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,2,"thetaMax=",0,(char*)NULL);
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,2,"phiMin=",0,(char*)NULL);
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,2,"phiMax=",0,(char*)NULL);
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,2,"EMin=",0,(char*)NULL);
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,2,"EMax=",0,(char*)NULL);
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,2,"PMin=",0,(char*)NULL);
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,2,"PMax=",0,(char*)NULL);
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,2,"pTMin=",0,(char*)NULL);
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,2,"pTMax=",0,(char*)NULL);
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,2,"pZMin=",0,(char*)NULL);
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,2,"pZMax=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__smearDictLN_vectorlESmearcLcLAcceptancecLcLCustomCutcOallocatorlESmearcLcLAcceptancecLcLCustomCutgRsPgR),G__defined_typename("vector<Smear::Acceptance::CustomCut>"),-1,2,"CustomCuts=",0,(char*)NULL);
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__smearDictLN_TClass),G__defined_typename("atomic_TClass_ptr"),-2,4,"fgIsA=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* Smear::Distributor */
static void G__setup_memvarSmearcLcLDistributor(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__smearDictLN_SmearcLcLDistributor));
   { Smear::Distributor *p; p=(Smear::Distributor*)0x1000; if (p) { }
   G__memvar_setup((void*)0,108,0,0,-1,-1,-1,4,"G__virtualinfo=",0,(char*)NULL);
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,2,"mPlus=",0,(char*)NULL);
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,2,"mMinus=",0,(char*)NULL);
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__smearDictLN_TF1),-1,-1,2,"mDistribution=",0,(char*)NULL);
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__smearDictLN_TClass),G__defined_typename("atomic_TClass_ptr"),-2,4,"fgIsA=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* Smear::Smearer */
static void G__setup_memvarSmearcLcLSmearer(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__smearDictLN_SmearcLcLSmearer));
   { Smear::Smearer *p; p=(Smear::Smearer*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->Accept)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__smearDictLN_SmearcLcLAcceptance),-1,-1,1,"Accept=",0,(char*)NULL);
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__smearDictLN_TClass),G__defined_typename("atomic_TClass_ptr"),-2,4,"fgIsA=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* Smear::FormulaString */
static void G__setup_memvarSmearcLcLFormulaString(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__smearDictLN_SmearcLcLFormulaString));
   { Smear::FormulaString *p; p=(Smear::FormulaString*)0x1000; if (p) { }
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__smearDictLN_TFormula),-1,-1,2,"mFormula=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__smearDictLN_string),-1,-1,2,"mInput=",0,"/< Original formula (before parsing)");
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__smearDictLN_vectorlESmearcLcLKinTypecOallocatorlESmearcLcLKinTypegRsPgR),G__defined_typename("vector<Smear::KinType>"),-1,2,"mVariables=",0,(char*)NULL);
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__smearDictLN_TClass),G__defined_typename("atomic_TClass_ptr"),-2,4,"fgIsA=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* Smear::Device */
static void G__setup_memvarSmearcLcLDevice(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__smearDictLN_SmearcLcLDevice));
   { Smear::Device *p; p=(Smear::Device*)0x1000; if (p) { }
   G__memvar_setup((void*)0,105,0,0,G__get_linked_tagnum(&G__smearDictLN_SmearcLcLKinType),-1,-1,2,"mSmeared=",0,"/< Smeared variable");
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__smearDictLN_TF1),-1,-1,2,"mKinematicFunction=",0,(char*)NULL);
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__smearDictLN_SmearcLcLFormulaString),-1,-1,2,"mFormula=",0,"/< Expression for resolution standard deviation");
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__smearDictLN_vectorlESmearcLcLKinTypecOallocatorlESmearcLcLKinTypegRsPgR),G__defined_typename("vector<Smear::KinType>"),-1,2,"mDimensions=",0,"/< Variables on which smearing");
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__smearDictLN_SmearcLcLDistributor),-1,-1,2,"mDistribution=",0,"/< Random distribution");
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__smearDictLN_TClass),G__defined_typename("atomic_TClass_ptr"),-2,4,"fgIsA=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* vector<Smear::KinType,allocator<Smear::KinType> > */
static void G__setup_memvarvectorlESmearcLcLKinTypecOallocatorlESmearcLcLKinTypegRsPgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__smearDictLN_vectorlESmearcLcLKinTypecOallocatorlESmearcLcLKinTypegRsPgR));
   { vector<Smear::KinType,allocator<Smear::KinType> > *p; p=(vector<Smear::KinType,allocator<Smear::KinType> >*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* Smear::Bremsstrahlung */
static void G__setup_memvarSmearcLcLBremsstrahlung(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__smearDictLN_SmearcLcLBremsstrahlung));
   { Smear::Bremsstrahlung *p; p=(Smear::Bremsstrahlung*)0x1000; if (p) { }
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__smearDictLN_auto_ptrlEerhiccLcLParticleMCgR),-1,-1,2,"mParticle=",0,"!< Copy of the current particle");
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,2,"mKMin=",0,(char*)NULL);
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,2,"mKMax=",0,(char*)NULL);
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,2,"mEpsilon=",0,(char*)NULL);
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,2,"mTraversed=",0,(char*)NULL);
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,2,"mRadLength=",0,(char*)NULL);
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__smearDictLN_TF1),-1,-1,2,"mPdf=",0,"!< dSigma/dK function");
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__smearDictLN_TClass),G__defined_typename("atomic_TClass_ptr"),-2,4,"fgIsA=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* auto_ptr<erhic::ParticleMC> */
static void G__setup_memvarauto_ptrlEerhiccLcLParticleMCgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__smearDictLN_auto_ptrlEerhiccLcLParticleMCgR));
   { auto_ptr<erhic::ParticleMC> *p; p=(auto_ptr<erhic::ParticleMC>*)0x1000; if (p) { }
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__smearDictLN_erhiccLcLParticleMC),-1,-1,4,"ptr=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* Smear::Detector */
static void G__setup_memvarSmearcLcLDetector(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__smearDictLN_SmearcLcLDetector));
   { Smear::Detector *p; p=(Smear::Detector*)0x1000; if (p) { }
   G__memvar_setup((void*)0,103,0,0,-1,-1,-1,2,"useNM=",0,(char*)NULL);
   G__memvar_setup((void*)0,103,0,0,-1,-1,-1,2,"useJB=",0,(char*)NULL);
   G__memvar_setup((void*)0,103,0,0,-1,-1,-1,2,"useDA=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__smearDictLN_vectorlESmearcLcLSmearermUcOallocatorlESmearcLcLSmearermUgRsPgR),-1,-1,2,"Devices=",0,(char*)NULL);
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__smearDictLN_TClass),G__defined_typename("atomic_TClass_ptr"),-2,4,"fgIsA=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* Smear::ParticleID */
static void G__setup_memvarSmearcLcLParticleID(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__smearDictLN_SmearcLcLParticleID));
   { Smear::ParticleID *p; p=(Smear::ParticleID*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->Ran)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__smearDictLN_TRandom3),-1,-1,1,"Ran=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->PMatPath)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__smearDictLN_TString),-1,-1,1,"PMatPath=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->TrueIdent)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__smearDictLN_vectorlEintcOallocatorlEintgRsPgR),G__defined_typename("vector<int>"),-1,1,"TrueIdent=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->FalseIdent)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__smearDictLN_vectorlEintcOallocatorlEintgRsPgR),G__defined_typename("vector<int>"),-1,1,"FalseIdent=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->PMin)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__smearDictLN_vectorlEdoublecOallocatorlEdoublegRsPgR),G__defined_typename("vector<double>"),-1,1,"PMin=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->PMax)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__smearDictLN_vectorlEdoublecOallocatorlEdoublegRsPgR),G__defined_typename("vector<double>"),-1,1,"PMax=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->PMatrix)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__smearDictLN_vectorlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRcOallocatorlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRsPgRsPgR),G__defined_typename("vector<std::vector<std::vector<double> > >"),-1,1,"PMatrix=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Range)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__smearDictLN_vectorlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRcOallocatorlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRsPgRsPgR),G__defined_typename("vector<std::vector<std::vector<double> > >"),-1,1,"Range=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->bUseMC)-(long)(p)),103,0,0,-1,-1,-1,1,"bUseMC=",0,(char*)NULL);
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__smearDictLN_TClass),G__defined_typename("atomic_TClass_ptr"),-2,4,"fgIsA=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* vector<int,allocator<int> > */
static void G__setup_memvarvectorlEintcOallocatorlEintgRsPgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__smearDictLN_vectorlEintcOallocatorlEintgRsPgR));
   { vector<int,allocator<int> > *p; p=(vector<int,allocator<int> >*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* Smear::PerfectID */
static void G__setup_memvarSmearcLcLPerfectID(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__smearDictLN_SmearcLcLPerfectID));
   { Smear::PerfectID *p; p=(Smear::PerfectID*)0x1000; if (p) { }
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__smearDictLN_setlEintcOlesslEintgRcOallocatorlEintgRsPgR),G__defined_typename("set<Int_t>"),-1,2,"mPdg=",0,(char*)NULL);
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__smearDictLN_TClass),G__defined_typename("atomic_TClass_ptr"),-2,4,"fgIsA=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* Smear::Tracker */
static void G__setup_memvarSmearcLcLTracker(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__smearDictLN_SmearcLcLTracker));
   { Smear::Tracker *p; p=(Smear::Tracker*)0x1000; if (p) { }
   G__memvar_setup((void*)0,105,0,0,-1,G__defined_typename("Int_t"),-1,2,"mFactor=",0,"/< Factor in intrinsic resolution calculation");
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,2,"mMagField=",0,"/< Magnetic field strength in Tesla");
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,2,"mNRadLengths=",0,"/< Number of radiation lengths (dimensionless)");
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,2,"mSigmaRPhi=",0,"/< Point resolution");
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__smearDictLN_SmearcLcLDistributor),-1,-1,2,"Distribution=",0,"/< Random distribution");
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__smearDictLN_TClass),G__defined_typename("atomic_TClass_ptr"),-2,4,"fgIsA=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* Smear::PlanarTracker */
static void G__setup_memvarSmearcLcLPlanarTracker(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__smearDictLN_SmearcLcLPlanarTracker));
   { Smear::PlanarTracker *p; p=(Smear::PlanarTracker*)0x1000; if (p) { }
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,2,"mNPlanes=",0,"/< Number of planes");
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,2,"mInnerRadius=",0,"/< Inner radius (m)");
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,2,"mOuterRadius=",0,"/< Outer radius (m)");
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,2,"mZMin=",0,"/< Lower (most negative) z face");
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,2,"mZMax=",0,"/< Upper (most positive) z face");
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__smearDictLN_TClass),G__defined_typename("atomic_TClass_ptr"),-2,4,"fgIsA=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* Smear::RadialTracker */
static void G__setup_memvarSmearcLcLRadialTracker(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__smearDictLN_SmearcLcLRadialTracker));
   { Smear::RadialTracker *p; p=(Smear::RadialTracker*)0x1000; if (p) { }
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,2,"mNFitPoints=",0,"/< Number of fit points");
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,2,"mInnerRadius=",0,"/< Inner radius (m)");
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,2,"mOuterRadius=",0,"/< Outer radius (m)");
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,2,"mZMin=",0,"/< Lower (most negative) z face");
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,2,"mZMax=",0,"/< Upper (most positive) z face");
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__smearDictLN_TClass),G__defined_typename("atomic_TClass_ptr"),-2,4,"fgIsA=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}

extern "C" void G__cpp_setup_memvarsmearDict() {
}
/***********************************************************
************************************************************
************************************************************
************************************************************
************************************************************
************************************************************
************************************************************
***********************************************************/

/*********************************************************
* Member function information setup for each class
*********************************************************/
static void G__setup_memfuncSmear(void) {
   /* Smear */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__smearDictLN_Smear));
   G__memfunc_setup("PGenre",577,G__smearDict_436_0_1, 105, -1, -1, 0, 1, 1, 1, 0, "u 'erhic::VirtualParticle' - 11 - prt", (char*)NULL, (void*) G__func2void( (int (*)(const erhic::VirtualParticle&))(&Smear::PGenre) ), 0);
   G__memfunc_setup("FixTheta",797,G__smearDict_436_0_2, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - theta", (char*)NULL, (void*) G__func2void( (double (*)(double))(&Smear::FixTheta) ), 0);
   G__memfunc_setup("FixPhi",584,G__smearDict_436_0_3, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - phi", (char*)NULL, (void*) G__func2void( (double (*)(double))(&Smear::FixPhi) ), 0);
   G__memfunc_setup("GetVariable",1094,G__smearDict_436_0_4, 100, -1, -1, 0, 2, 1, 1, 0, 
"u 'erhic::VirtualParticle' - 11 - prt i 'Smear::KinType' - 0 - kin", (char*)NULL, (void*) G__func2void( (double (*)(const erhic::VirtualParticle&, Smear::KinType))(&Smear::GetVariable) ), 0);
   G__memfunc_setup("SetVariable",1106,G__smearDict_436_0_5, 121, -1, -1, 0, 3, 1, 1, 0, 
"u 'Smear::ParticleMCS' - 1 - prt d - - 0 - z "
"i 'Smear::KinType' - 0 - kin", (char*)NULL, (void*) G__func2void( (void (*)(Smear::ParticleMCS&, double, Smear::KinType))(&Smear::SetVariable) ), 0);
   G__memfunc_setup("HandleBogusValues",1724,G__smearDict_436_0_6, 121, -1, -1, 0, 2, 1, 1, 0, 
"u 'Smear::ParticleMCS' - 1 - prt i 'Smear::KinType' - 0 - kin", (char*)NULL, (void*) G__func2void( (void (*)(Smear::ParticleMCS&, Smear::KinType))(&Smear::HandleBogusValues) ), 0);
   G__memfunc_setup("HandleBogusValues",1724,G__smearDict_436_0_7, 121, -1, -1, 0, 1, 1, 1, 0, "u 'Smear::ParticleMCS' - 1 - prt", (char*)NULL, (void*) G__func2void( (void (*)(Smear::ParticleMCS&))(&Smear::HandleBogusValues) ), 0);
   G__memfunc_setup("IsCoreType",999,G__smearDict_436_0_8, 103, -1, -1, 0, 1, 1, 1, 0, "i 'Smear::KinType' - 0 - kin", (char*)NULL, (void*) G__func2void( (bool (*)(Smear::KinType))(&Smear::IsCoreType) ), 0);
   G__memfunc_setup("ParseInputFunction",1873,G__smearDict_436_0_9, 105, -1, -1, 0, 3, 1, 1, 0, 
"u 'TString' - 1 - s i 'Smear::KinType' - 1 - kin1 "
"i 'Smear::KinType' - 1 - kin2", (char*)NULL, (void*) G__func2void( (int (*)(TString&, Smear::KinType&, Smear::KinType&))(&Smear::ParseInputFunction) ), 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncSmearcLcLEvent(void) {
   /* Smear::Event */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__smearDictLN_SmearcLcLEvent));
   G__memfunc_setup("Event",514,G__smearDict_437_0_1, 105, G__get_linked_tagnum(&G__smearDictLN_SmearcLcLEvent), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Reset",515,G__smearDict_437_0_2, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ClearParticles",1422,G__smearDict_437_0_3, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetNTracks",982,(G__InterfaceMethod) NULL,104, -1, G__defined_typename("UInt_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetTrack",789,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__smearDictLN_SmearcLcLParticleMCS), -1, 0, 1, 1, 1, 9, "h - 'UInt_t' 0 - u", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetTrack",789,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__smearDictLN_SmearcLcLParticleMCS), -1, 0, 1, 1, 1, 0, "h - 'UInt_t' 0 - u", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetQ2",431,G__smearDict_437_0_7, 121, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - Q2", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetX",388,G__smearDict_437_0_8, 121, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - xB", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetY",389,G__smearDict_437_0_9, 121, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - inelasticity", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetW2",437,G__smearDict_437_0_10, 121, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - W2", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetNu",495,G__smearDict_437_0_11, 121, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - Nu", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("BeamLepton",999,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__smearDictLN_SmearcLcLParticleMCS), -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("BeamHadron",977,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__smearDictLN_SmearcLcLParticleMCS), -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ExchangeBoson",1316,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__smearDictLN_SmearcLcLParticleMCS), -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ScatteredLepton",1553,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__smearDictLN_SmearcLcLParticleMCS), -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("AddLast",669,G__smearDict_437_0_16, 121, -1, -1, 0, 1, 1, 1, 0, "U 'Smear::ParticleMCS' - 0 - particle", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("HadronicFinalState",1811,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 8, "u 'vector<const erhic::VirtualParticle*,allocator<const erhic::VirtualParticle*> >' 'erhic::VirtualEvent::ParticlePtrList' 1 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetTracks",904,G__smearDict_437_0_18, 117, G__get_linked_tagnum(&G__smearDictLN_vectorlEconstsPerhiccLcLVirtualParticlemUcOallocatorlEconstsPerhiccLcLVirtualParticlemUgRsPgR), G__defined_typename("vector<const erhic::VirtualParticle*>"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetScattered",1227,G__smearDict_437_0_19, 121, -1, -1, 0, 1, 1, 1, 0, "i - - 0 - index", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Print",525,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 8, "C - 'Option_t' 10 '\"\"' -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Class",502,G__smearDict_437_0_21, 85, G__get_linked_tagnum(&G__smearDictLN_TClass), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (TClass* (*)())(&Smear::Event::Class) ), 0);
   G__memfunc_setup("Class_Name",982,G__smearDict_437_0_22, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&Smear::Event::Class_Name) ), 0);
   G__memfunc_setup("Class_Version",1339,G__smearDict_437_0_23, 115, -1, G__defined_typename("Version_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Version_t (*)())(&Smear::Event::Class_Version) ), 0);
   G__memfunc_setup("Dictionary",1046,G__smearDict_437_0_24, 121, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (void (*)())(&Smear::Event::Dictionary) ), 0);
   G__memfunc_setup("IsA",253,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__smearDictLN_TClass), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ShowMembers",1132,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TMemberInspector' - 1 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Streamer",835,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("StreamerNVirtual",1656,G__smearDict_437_0_28, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - ClassDef_StreamerNVirtual_b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DeclFileName",1145,G__smearDict_437_0_29, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&Smear::Event::DeclFileName) ), 0);
   G__memfunc_setup("ImplFileLine",1178,G__smearDict_437_0_30, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&Smear::Event::ImplFileLine) ), 0);
   G__memfunc_setup("ImplFileName",1171,G__smearDict_437_0_31, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&Smear::Event::ImplFileName) ), 0);
   G__memfunc_setup("DeclFileLine",1152,G__smearDict_437_0_32, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&Smear::Event::DeclFileLine) ), 0);
   // automatic copy constructor
   G__memfunc_setup("Event", 514, G__smearDict_437_0_33, (int) ('i'), G__get_linked_tagnum(&G__smearDictLN_SmearcLcLEvent), -1, 0, 1, 1, 1, 0, "u 'Smear::Event' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Event", 640, G__smearDict_437_0_34, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__smearDict_437_0_35, (int) ('u'), G__get_linked_tagnum(&G__smearDictLN_SmearcLcLEvent), -1, 1, 1, 1, 1, 0, "u 'Smear::Event' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncSmearcLcLParticleMCS(void) {
   /* Smear::ParticleMCS */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__smearDictLN_SmearcLcLParticleMCS));
   G__memfunc_setup("ParticleMCS",1047,G__smearDict_438_0_1, 105, G__get_linked_tagnum(&G__smearDictLN_SmearcLcLParticleMCS), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ParticleMCS",1047,G__smearDict_438_0_2, 105, G__get_linked_tagnum(&G__smearDictLN_SmearcLcLParticleMCS), -1, 0, 3, 1, 1, 0, 
"u 'TLorentzVector' - 11 - - i - - 0 - pdg "
"i - - 0 - status", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetPx",488,(G__InterfaceMethod) NULL,100, -1, G__defined_typename("Double_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetPy",489,(G__InterfaceMethod) NULL,100, -1, G__defined_typename("Double_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetPz",490,(G__InterfaceMethod) NULL,100, -1, G__defined_typename("Double_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetE",357,(G__InterfaceMethod) NULL,100, -1, G__defined_typename("Double_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Get4Vector",967,(G__InterfaceMethod) NULL,117, G__get_linked_tagnum(&G__smearDictLN_TLorentzVector), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("PxPyPzE",672,G__smearDict_438_0_8, 117, G__get_linked_tagnum(&G__smearDictLN_TLorentzVector), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetM",365,(G__InterfaceMethod) NULL,100, -1, G__defined_typename("Double_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetPt",484,(G__InterfaceMethod) NULL,100, -1, G__defined_typename("Double_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetVertex",926,(G__InterfaceMethod) NULL,117, G__get_linked_tagnum(&G__smearDictLN_TVector3), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetP",368,(G__InterfaceMethod) NULL,100, -1, G__defined_typename("Double_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetTheta",790,(G__InterfaceMethod) NULL,100, -1, G__defined_typename("Double_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetPhi",577,(G__InterfaceMethod) NULL,100, -1, G__defined_typename("Double_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetRapidity",1126,(G__InterfaceMethod) NULL,100, -1, G__defined_typename("Double_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetEta",570,(G__InterfaceMethod) NULL,100, -1, G__defined_typename("Double_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetStatus",932,(G__InterfaceMethod) NULL,114, -1, G__defined_typename("UShort_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Id",173,(G__InterfaceMethod) NULL,117, G__get_linked_tagnum(&G__smearDictLN_erhiccLcLPid), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetE",369,G__smearDict_438_0_19, 121, -1, -1, 0, 1, 1, 1, 0, "d - 'Double_t' 0 - e", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetP",380,G__smearDict_438_0_20, 121, -1, -1, 0, 1, 1, 1, 0, "d - 'Double_t' 0 - momentum", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetPt",496,G__smearDict_438_0_21, 121, -1, -1, 0, 1, 1, 1, 0, "d - 'Double_t' 0 - momentum", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetPz",502,G__smearDict_438_0_22, 121, -1, -1, 0, 1, 1, 1, 0, "d - 'Double_t' 0 - momentum", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetPhi",589,G__smearDict_438_0_23, 121, -1, -1, 0, 1, 1, 1, 0, "d - 'Double_t' 0 - value", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetTheta",802,G__smearDict_438_0_24, 121, -1, -1, 0, 1, 1, 1, 0, "d - 'Double_t' 0 - value", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Set4Vector",979,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TLorentzVector' - 11 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetId",473,G__smearDict_438_0_26, 121, -1, -1, 0, 1, 1, 1, 0, "i - 'Int_t' 0 - i", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetStatus",944,G__smearDict_438_0_27, 121, -1, -1, 0, 1, 1, 1, 0, "i - 'Int_t' 0 - i", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetParentIndex",1410,(G__InterfaceMethod) NULL,114, -1, G__defined_typename("UShort_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Print",525,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 8, "C - 'Option_t' 10 '\"\"' -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetVertex",938,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TVector3' - 11 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Class",502,G__smearDict_438_0_31, 85, G__get_linked_tagnum(&G__smearDictLN_TClass), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (TClass* (*)())(&Smear::ParticleMCS::Class) ), 0);
   G__memfunc_setup("Class_Name",982,G__smearDict_438_0_32, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&Smear::ParticleMCS::Class_Name) ), 0);
   G__memfunc_setup("Class_Version",1339,G__smearDict_438_0_33, 115, -1, G__defined_typename("Version_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Version_t (*)())(&Smear::ParticleMCS::Class_Version) ), 0);
   G__memfunc_setup("Dictionary",1046,G__smearDict_438_0_34, 121, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (void (*)())(&Smear::ParticleMCS::Dictionary) ), 0);
   G__memfunc_setup("IsA",253,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__smearDictLN_TClass), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ShowMembers",1132,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TMemberInspector' - 1 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Streamer",835,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("StreamerNVirtual",1656,G__smearDict_438_0_38, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - ClassDef_StreamerNVirtual_b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DeclFileName",1145,G__smearDict_438_0_39, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&Smear::ParticleMCS::DeclFileName) ), 0);
   G__memfunc_setup("ImplFileLine",1178,G__smearDict_438_0_40, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&Smear::ParticleMCS::ImplFileLine) ), 0);
   G__memfunc_setup("ImplFileName",1171,G__smearDict_438_0_41, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&Smear::ParticleMCS::ImplFileName) ), 0);
   G__memfunc_setup("DeclFileLine",1152,G__smearDict_438_0_42, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&Smear::ParticleMCS::DeclFileLine) ), 0);
   // automatic copy constructor
   G__memfunc_setup("ParticleMCS", 1047, G__smearDict_438_0_43, (int) ('i'), G__get_linked_tagnum(&G__smearDictLN_SmearcLcLParticleMCS), -1, 0, 1, 1, 1, 0, "u 'Smear::ParticleMCS' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~ParticleMCS", 1173, G__smearDict_438_0_44, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__smearDict_438_0_45, (int) ('u'), G__get_linked_tagnum(&G__smearDictLN_SmearcLcLParticleMCS), -1, 1, 1, 1, 1, 0, "u 'Smear::ParticleMCS' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncSmearcLcLAcceptance(void) {
   /* Smear::Acceptance */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__smearDictLN_SmearcLcLAcceptance));
   G__memfunc_setup("Acceptance",999,G__smearDict_442_0_1, 105, G__get_linked_tagnum(&G__smearDictLN_SmearcLcLAcceptance), -1, 0, 1, 5, 1, 0, "i - - 0 'kAll' genre", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddZone",677,G__smearDict_442_0_2, 121, -1, -1, 0, 1, 1, 1, 0, "u 'Smear::Acceptance::Zone' - 11 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetNZones",893,G__smearDict_442_0_3, 104, -1, G__defined_typename("UInt_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetGenre",785,G__smearDict_442_0_4, 105, -1, G__defined_typename("Int_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetGenre",797,G__smearDict_442_0_5, 121, -1, -1, 0, 1, 1, 1, 0, "i - - 0 - genre", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetCharge",886,G__smearDict_442_0_6, 121, -1, -1, 0, 1, 1, 1, 0, "i 'Smear::ECharge' - 0 - charge", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetCharge",874,G__smearDict_442_0_7, 105, G__get_linked_tagnum(&G__smearDictLN_SmearcLcLECharge), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddParticle",1085,G__smearDict_442_0_8, 121, -1, -1, 0, 1, 1, 1, 0, "i - - 0 - particle", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Is",188,G__smearDict_442_0_9, 103, -1, -1, 0, 1, 1, 1, 8, "u 'erhic::VirtualParticle' - 11 - prt", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Class",502,G__smearDict_442_0_10, 85, G__get_linked_tagnum(&G__smearDictLN_TClass), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (TClass* (*)())(&Smear::Acceptance::Class) ), 0);
   G__memfunc_setup("Class_Name",982,G__smearDict_442_0_11, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&Smear::Acceptance::Class_Name) ), 0);
   G__memfunc_setup("Class_Version",1339,G__smearDict_442_0_12, 115, -1, G__defined_typename("Version_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Version_t (*)())(&Smear::Acceptance::Class_Version) ), 0);
   G__memfunc_setup("Dictionary",1046,G__smearDict_442_0_13, 121, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (void (*)())(&Smear::Acceptance::Dictionary) ), 0);
   G__memfunc_setup("IsA",253,G__smearDict_442_0_14, 85, G__get_linked_tagnum(&G__smearDictLN_TClass), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ShowMembers",1132,G__smearDict_442_0_15, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TMemberInspector' - 1 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Streamer",835,G__smearDict_442_0_16, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("StreamerNVirtual",1656,G__smearDict_442_0_17, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - ClassDef_StreamerNVirtual_b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DeclFileName",1145,G__smearDict_442_0_18, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&Smear::Acceptance::DeclFileName) ), 0);
   G__memfunc_setup("ImplFileLine",1178,G__smearDict_442_0_19, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&Smear::Acceptance::ImplFileLine) ), 0);
   G__memfunc_setup("ImplFileName",1171,G__smearDict_442_0_20, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&Smear::Acceptance::ImplFileName) ), 0);
   G__memfunc_setup("DeclFileLine",1152,G__smearDict_442_0_21, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&Smear::Acceptance::DeclFileLine) ), 0);
   // automatic copy constructor
   G__memfunc_setup("Acceptance", 999, G__smearDict_442_0_22, (int) ('i'), G__get_linked_tagnum(&G__smearDictLN_SmearcLcLAcceptance), -1, 0, 1, 1, 1, 0, "u 'Smear::Acceptance' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Acceptance", 1125, G__smearDict_442_0_23, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__smearDict_442_0_24, (int) ('u'), G__get_linked_tagnum(&G__smearDictLN_SmearcLcLAcceptance), -1, 1, 1, 1, 1, 0, "u 'Smear::Acceptance' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncSmearcLcLAcceptancecLcLCustomCut(void) {
   /* Smear::Acceptance::CustomCut */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__smearDictLN_SmearcLcLAcceptancecLcLCustomCut));
   G__memfunc_setup("CustomCut",935,G__smearDict_443_0_1, 105, G__get_linked_tagnum(&G__smearDictLN_SmearcLcLAcceptancecLcLCustomCut), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("CustomCut",935,G__smearDict_443_0_2, 105, G__get_linked_tagnum(&G__smearDictLN_SmearcLcLAcceptancecLcLCustomCut), -1, 0, 3, 1, 1, 0, 
"u 'TString' - 11 - - d - - 0 - min "
"d - - 0 - max", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Contains",831,G__smearDict_443_0_3, 103, -1, -1, 0, 1, 1, 1, 8, "u 'erhic::VirtualParticle' - 11 - -", (char*)NULL, (void*) NULL, 1);
   // automatic destructor
   G__memfunc_setup("~CustomCut", 1061, G__smearDict_443_0_4, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncSmearcLcLAcceptancecLcLZone(void) {
   /* Smear::Acceptance::Zone */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__smearDictLN_SmearcLcLAcceptancecLcLZone));
   G__memfunc_setup("Zone",412,G__smearDict_444_0_1, 105, G__get_linked_tagnum(&G__smearDictLN_SmearcLcLAcceptancecLcLZone), -1, 0, 12, 1, 1, 0, 
"d - - 0 '0.' theta d - - 0 'TMath::Pi()' - "
"d - - 0 '0.' phi d - - 0 'TMath::TwoPi()' - "
"d - - 0 '0.' E d - - 0 'TMath::Infinity()' - "
"d - - 0 '0.' p d - - 0 'TMath::Infinity()' - "
"d - - 0 '0.' pt d - - 0 'TMath::Infinity()' - "
"d - - 0 '-TMath::Infinity()' pz d - - 0 'TMath::Infinity()' -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Add",265,G__smearDict_444_0_2, 121, -1, -1, 0, 1, 1, 1, 0, "u 'Smear::Acceptance::CustomCut' - 11 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Contains",831,G__smearDict_444_0_3, 103, -1, G__defined_typename("Bool_t"), 0, 1, 1, 1, 8, "u 'erhic::VirtualParticle' - 11 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Class",502,G__smearDict_444_0_4, 85, G__get_linked_tagnum(&G__smearDictLN_TClass), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (TClass* (*)())(&Smear::Acceptance::Zone::Class) ), 0);
   G__memfunc_setup("Class_Name",982,G__smearDict_444_0_5, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&Smear::Acceptance::Zone::Class_Name) ), 0);
   G__memfunc_setup("Class_Version",1339,G__smearDict_444_0_6, 115, -1, G__defined_typename("Version_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Version_t (*)())(&Smear::Acceptance::Zone::Class_Version) ), 0);
   G__memfunc_setup("Dictionary",1046,G__smearDict_444_0_7, 121, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (void (*)())(&Smear::Acceptance::Zone::Dictionary) ), 0);
   G__memfunc_setup("IsA",253,G__smearDict_444_0_8, 85, G__get_linked_tagnum(&G__smearDictLN_TClass), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ShowMembers",1132,G__smearDict_444_0_9, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TMemberInspector' - 1 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Streamer",835,G__smearDict_444_0_10, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("StreamerNVirtual",1656,G__smearDict_444_0_11, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - ClassDef_StreamerNVirtual_b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DeclFileName",1145,G__smearDict_444_0_12, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&Smear::Acceptance::Zone::DeclFileName) ), 0);
   G__memfunc_setup("ImplFileLine",1178,G__smearDict_444_0_13, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&Smear::Acceptance::Zone::ImplFileLine) ), 0);
   G__memfunc_setup("ImplFileName",1171,G__smearDict_444_0_14, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&Smear::Acceptance::Zone::ImplFileName) ), 0);
   G__memfunc_setup("DeclFileLine",1152,G__smearDict_444_0_15, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&Smear::Acceptance::Zone::DeclFileLine) ), 0);
   // automatic copy constructor
   G__memfunc_setup("Zone", 412, G__smearDict_444_0_16, (int) ('i'), G__get_linked_tagnum(&G__smearDictLN_SmearcLcLAcceptancecLcLZone), -1, 0, 1, 1, 1, 0, "u 'Smear::Acceptance::Zone' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Zone", 538, G__smearDict_444_0_17, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__smearDict_444_0_18, (int) ('u'), G__get_linked_tagnum(&G__smearDictLN_SmearcLcLAcceptancecLcLZone), -1, 1, 1, 1, 1, 0, "u 'Smear::Acceptance::Zone' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncSmearcLcLDistributor(void) {
   /* Smear::Distributor */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__smearDictLN_SmearcLcLDistributor));
   G__memfunc_setup("Distributor",1179,G__smearDict_453_0_1, 105, G__get_linked_tagnum(&G__smearDictLN_SmearcLcLDistributor), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Distributor",1179,G__smearDict_453_0_2, 105, G__get_linked_tagnum(&G__smearDictLN_SmearcLcLDistributor), -1, 0, 5, 1, 1, 0, 
"u 'TString' - 11 - formula d - - 0 - lower "
"d - - 0 - upper d - - 0 '-1.e6' minimum "
"d - - 0 '1.e6' maximum", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Generate",811,G__smearDict_453_0_3, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - midpoint d - - 0 - width", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Class",502,G__smearDict_453_0_4, 85, G__get_linked_tagnum(&G__smearDictLN_TClass), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (TClass* (*)())(&Smear::Distributor::Class) ), 0);
   G__memfunc_setup("Class_Name",982,G__smearDict_453_0_5, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&Smear::Distributor::Class_Name) ), 0);
   G__memfunc_setup("Class_Version",1339,G__smearDict_453_0_6, 115, -1, G__defined_typename("Version_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Version_t (*)())(&Smear::Distributor::Class_Version) ), 0);
   G__memfunc_setup("Dictionary",1046,G__smearDict_453_0_7, 121, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (void (*)())(&Smear::Distributor::Dictionary) ), 0);
   G__memfunc_setup("IsA",253,G__smearDict_453_0_8, 85, G__get_linked_tagnum(&G__smearDictLN_TClass), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ShowMembers",1132,G__smearDict_453_0_9, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TMemberInspector' - 1 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Streamer",835,G__smearDict_453_0_10, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("StreamerNVirtual",1656,G__smearDict_453_0_11, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - ClassDef_StreamerNVirtual_b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DeclFileName",1145,G__smearDict_453_0_12, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&Smear::Distributor::DeclFileName) ), 0);
   G__memfunc_setup("ImplFileLine",1178,G__smearDict_453_0_13, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&Smear::Distributor::ImplFileLine) ), 0);
   G__memfunc_setup("ImplFileName",1171,G__smearDict_453_0_14, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&Smear::Distributor::ImplFileName) ), 0);
   G__memfunc_setup("DeclFileLine",1152,G__smearDict_453_0_15, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&Smear::Distributor::DeclFileLine) ), 0);
   // automatic copy constructor
   G__memfunc_setup("Distributor", 1179, G__smearDict_453_0_16, (int) ('i'), G__get_linked_tagnum(&G__smearDictLN_SmearcLcLDistributor), -1, 0, 1, 1, 1, 0, "u 'Smear::Distributor' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Distributor", 1305, G__smearDict_453_0_17, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__smearDict_453_0_18, (int) ('u'), G__get_linked_tagnum(&G__smearDictLN_SmearcLcLDistributor), -1, 1, 1, 1, 1, 0, "u 'Smear::Distributor' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncSmearcLcLSmearer(void) {
   /* Smear::Smearer */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__smearDictLN_SmearcLcLSmearer));
   G__memfunc_setup("Clone",497,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__smearDictLN_SmearcLcLSmearer), -1, 0, 1, 1, 1, 8, "C - - 10 '\"\"' -", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("Smear",504,G__smearDict_454_0_2, 121, -1, -1, 0, 2, 1, 1, 0, 
"u 'erhic::VirtualParticle' - 11 - - u 'Smear::ParticleMCS' - 1 - -", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("Class",502,G__smearDict_454_0_3, 85, G__get_linked_tagnum(&G__smearDictLN_TClass), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (TClass* (*)())(&Smear::Smearer::Class) ), 0);
   G__memfunc_setup("Class_Name",982,G__smearDict_454_0_4, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&Smear::Smearer::Class_Name) ), 0);
   G__memfunc_setup("Class_Version",1339,G__smearDict_454_0_5, 115, -1, G__defined_typename("Version_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Version_t (*)())(&Smear::Smearer::Class_Version) ), 0);
   G__memfunc_setup("Dictionary",1046,G__smearDict_454_0_6, 121, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (void (*)())(&Smear::Smearer::Dictionary) ), 0);
   G__memfunc_setup("IsA",253,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__smearDictLN_TClass), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ShowMembers",1132,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TMemberInspector' - 1 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Streamer",835,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("StreamerNVirtual",1656,G__smearDict_454_0_10, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - ClassDef_StreamerNVirtual_b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DeclFileName",1145,G__smearDict_454_0_11, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&Smear::Smearer::DeclFileName) ), 0);
   G__memfunc_setup("ImplFileLine",1178,G__smearDict_454_0_12, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&Smear::Smearer::ImplFileLine) ), 0);
   G__memfunc_setup("ImplFileName",1171,G__smearDict_454_0_13, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&Smear::Smearer::ImplFileName) ), 0);
   G__memfunc_setup("DeclFileLine",1152,G__smearDict_454_0_14, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&Smear::Smearer::DeclFileLine) ), 0);
   // automatic destructor
   G__memfunc_setup("~Smearer", 845, G__smearDict_454_0_15, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__smearDict_454_0_16, (int) ('u'), G__get_linked_tagnum(&G__smearDictLN_SmearcLcLSmearer), -1, 1, 1, 1, 1, 0, "u 'Smear::Smearer' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncSmearcLcLFormulaString(void) {
   /* Smear::FormulaString */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__smearDictLN_SmearcLcLFormulaString));
   G__memfunc_setup("FormulaString",1357,G__smearDict_455_0_1, 105, G__get_linked_tagnum(&G__smearDictLN_SmearcLcLFormulaString), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FormulaString",1357,G__smearDict_455_0_2, 105, G__get_linked_tagnum(&G__smearDictLN_SmearcLcLFormulaString), -1, 0, 1, 5, 1, 0, "u 'string' - 11 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Eval",392,G__smearDict_455_0_3, 100, -1, -1, 0, 1, 1, 1, 8, "u 'vector<double,allocator<double> >' 'vector<double>' 11 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Variables",921,G__smearDict_455_0_4, 117, G__get_linked_tagnum(&G__smearDictLN_vectorlESmearcLcLKinTypecOallocatorlESmearcLcLKinTypegRsPgR), G__defined_typename("vector<Smear::KinType>"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetString",919,G__smearDict_455_0_5, 117, G__get_linked_tagnum(&G__smearDictLN_string), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetInputString",1447,G__smearDict_455_0_6, 117, G__get_linked_tagnum(&G__smearDictLN_string), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetKinName",963,G__smearDict_455_0_7, 117, G__get_linked_tagnum(&G__smearDictLN_string), -1, 0, 1, 3, 1, 0, "i 'Smear::KinType' - 0 - -", (char*)NULL, (void*) G__func2void( (string (*)(Smear::KinType))(&Smear::FormulaString::GetKinName) ), 0);
   G__memfunc_setup("GetKinType",996,G__smearDict_455_0_8, 105, G__get_linked_tagnum(&G__smearDictLN_SmearcLcLKinType), -1, 0, 1, 3, 1, 0, "u 'string' - 11 - -", (char*)NULL, (void*) G__func2void( (Smear::KinType (*)(const string&))(&Smear::FormulaString::GetKinType) ), 0);
   G__memfunc_setup("Parse",507,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__smearDictLN_string), -1, 0, 1, 1, 2, 0, "u 'string' - 11 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Class",502,G__smearDict_455_0_10, 85, G__get_linked_tagnum(&G__smearDictLN_TClass), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (TClass* (*)())(&Smear::FormulaString::Class) ), 0);
   G__memfunc_setup("Class_Name",982,G__smearDict_455_0_11, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&Smear::FormulaString::Class_Name) ), 0);
   G__memfunc_setup("Class_Version",1339,G__smearDict_455_0_12, 115, -1, G__defined_typename("Version_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Version_t (*)())(&Smear::FormulaString::Class_Version) ), 0);
   G__memfunc_setup("Dictionary",1046,G__smearDict_455_0_13, 121, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (void (*)())(&Smear::FormulaString::Dictionary) ), 0);
   G__memfunc_setup("IsA",253,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__smearDictLN_TClass), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ShowMembers",1132,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TMemberInspector' - 1 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Streamer",835,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("StreamerNVirtual",1656,G__smearDict_455_0_17, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - ClassDef_StreamerNVirtual_b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DeclFileName",1145,G__smearDict_455_0_18, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&Smear::FormulaString::DeclFileName) ), 0);
   G__memfunc_setup("ImplFileLine",1178,G__smearDict_455_0_19, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&Smear::FormulaString::ImplFileLine) ), 0);
   G__memfunc_setup("ImplFileName",1171,G__smearDict_455_0_20, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&Smear::FormulaString::ImplFileName) ), 0);
   G__memfunc_setup("DeclFileLine",1152,G__smearDict_455_0_21, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&Smear::FormulaString::DeclFileLine) ), 0);
   // automatic copy constructor
   G__memfunc_setup("FormulaString", 1357, G__smearDict_455_0_22, (int) ('i'), G__get_linked_tagnum(&G__smearDictLN_SmearcLcLFormulaString), -1, 0, 1, 1, 1, 0, "u 'Smear::FormulaString' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~FormulaString", 1483, G__smearDict_455_0_23, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__smearDict_455_0_24, (int) ('u'), G__get_linked_tagnum(&G__smearDictLN_SmearcLcLFormulaString), -1, 1, 1, 1, 1, 0, "u 'Smear::FormulaString' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncSmearcLcLDevice(void) {
   /* Smear::Device */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__smearDictLN_SmearcLcLDevice));
   G__memfunc_setup("Device",592,G__smearDict_456_0_1, 105, G__get_linked_tagnum(&G__smearDictLN_SmearcLcLDevice), -1, 0, 3, 1, 1, 0, 
"i 'Smear::KinType' - 0 'kE' - u 'TString' - 11 '\"0\"' formula "
"i 'Smear::EGenre' - 0 'kAll' -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Device",592,G__smearDict_456_0_2, 105, G__get_linked_tagnum(&G__smearDictLN_SmearcLcLDevice), -1, 0, 3, 1, 1, 0, 
"u 'TString' - 11 - - u 'TString' - 11 '\"0\"' resolution "
"i 'Smear::EGenre' - 0 'kAll' -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Device",592,G__smearDict_456_0_3, 105, G__get_linked_tagnum(&G__smearDictLN_SmearcLcLDevice), -1, 0, 1, 1, 1, 0, "u 'Smear::Device' - 11 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Clone",497,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__smearDictLN_SmearcLcLDevice), -1, 0, 1, 1, 1, 8, "C - - 10 '\"\"' -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Smear",504,(G__InterfaceMethod) NULL,121, -1, -1, 0, 2, 1, 1, 0, 
"u 'erhic::VirtualParticle' - 11 - - u 'Smear::ParticleMCS' - 1 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetDistribution",1580,G__smearDict_456_0_6, 121, -1, -1, 0, 1, 1, 1, 0, "u 'Smear::Distributor' - 11 - d", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Print",525,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 8, "C - 'Option_t' 10 '\"\"' -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Init",404,(G__InterfaceMethod) NULL, 103, -1, -1, 0, 3, 1, 2, 0, 
"u 'TString' - 11 - - u 'TString' - 11 - - "
"i - - 0 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__smearDictLN_SmearcLcLDevice), -1, 1, 1, 1, 4, 0, "u 'Smear::Device' - 11 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Class",502,G__smearDict_456_0_10, 85, G__get_linked_tagnum(&G__smearDictLN_TClass), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (TClass* (*)())(&Smear::Device::Class) ), 0);
   G__memfunc_setup("Class_Name",982,G__smearDict_456_0_11, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&Smear::Device::Class_Name) ), 0);
   G__memfunc_setup("Class_Version",1339,G__smearDict_456_0_12, 115, -1, G__defined_typename("Version_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Version_t (*)())(&Smear::Device::Class_Version) ), 0);
   G__memfunc_setup("Dictionary",1046,G__smearDict_456_0_13, 121, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (void (*)())(&Smear::Device::Dictionary) ), 0);
   G__memfunc_setup("IsA",253,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__smearDictLN_TClass), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ShowMembers",1132,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TMemberInspector' - 1 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Streamer",835,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("StreamerNVirtual",1656,G__smearDict_456_0_17, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - ClassDef_StreamerNVirtual_b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DeclFileName",1145,G__smearDict_456_0_18, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&Smear::Device::DeclFileName) ), 0);
   G__memfunc_setup("ImplFileLine",1178,G__smearDict_456_0_19, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&Smear::Device::ImplFileLine) ), 0);
   G__memfunc_setup("ImplFileName",1171,G__smearDict_456_0_20, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&Smear::Device::ImplFileName) ), 0);
   G__memfunc_setup("DeclFileLine",1152,G__smearDict_456_0_21, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&Smear::Device::DeclFileLine) ), 0);
   // automatic destructor
   G__memfunc_setup("~Device", 718, G__smearDict_456_0_22, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncvectorlESmearcLcLKinTypecOallocatorlESmearcLcLKinTypegRsPgR(void) {
   /* vector<Smear::KinType,allocator<Smear::KinType> > */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__smearDictLN_vectorlESmearcLcLKinTypecOallocatorlESmearcLcLKinTypegRsPgR));
   G__memfunc_setup("at",213,G__smearDict_458_0_1, 105, G__get_linked_tagnum(&G__smearDictLN_SmearcLcLKinType), G__defined_typename("vector<Smear::KinType,allocator<Smear::KinType> >::reference"), 1, 1, 1, 1, 0, "k - 'vector<Smear::KinType,allocator<Smear::KinType> >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("at",213,G__smearDict_458_0_2, 105, G__get_linked_tagnum(&G__smearDictLN_SmearcLcLKinType), G__defined_typename("vector<Smear::KinType,allocator<Smear::KinType> >::const_reference"), 1, 1, 1, 1, 8, "k - 'vector<Smear::KinType,allocator<Smear::KinType> >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("begin",517,G__smearDict_458_0_3, 117, G__get_linked_tagnum(&G__smearDictLN_vectorlESmearcLcLKinTypecOallocatorlESmearcLcLKinTypegRsPgRcLcLiterator), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("end",311,G__smearDict_458_0_4, 117, G__get_linked_tagnum(&G__smearDictLN_vectorlESmearcLcLKinTypecOallocatorlESmearcLcLKinTypegRsPgRcLcLiterator), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("rbegin",631,G__smearDict_458_0_5, 117, G__get_linked_tagnum(&G__smearDictLN_reverse_iteratorlEvectorlESmearcLcLKinTypecOallocatorlESmearcLcLKinTypegRsPgRcLcLiteratorgR), G__defined_typename("vector<Smear::KinType,allocator<Smear::KinType> >::reverse_iterator"), 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("rend",425,G__smearDict_458_0_6, 117, G__get_linked_tagnum(&G__smearDictLN_reverse_iteratorlEvectorlESmearcLcLKinTypecOallocatorlESmearcLcLKinTypegRsPgRcLcLiteratorgR), G__defined_typename("vector<Smear::KinType,allocator<Smear::KinType> >::reverse_iterator"), 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("size",443,G__smearDict_458_0_7, 107, -1, G__defined_typename("vector<Smear::KinType,allocator<Smear::KinType> >::size_type"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("max_size",864,G__smearDict_458_0_8, 107, -1, G__defined_typename("vector<Smear::KinType,allocator<Smear::KinType> >::size_type"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("resize",658,G__smearDict_458_0_9, 121, -1, -1, 0, 1, 1, 1, 0, "k - 'vector<Smear::KinType,allocator<Smear::KinType> >::size_type' 0 - sz", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("resize",658,G__smearDict_458_0_10, 121, -1, -1, 0, 2, 1, 1, 0, 
"k - 'vector<Smear::KinType,allocator<Smear::KinType> >::size_type' 0 - sz i 'Smear::KinType' - 0 - c", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("capacity",846,G__smearDict_458_0_11, 107, -1, G__defined_typename("vector<Smear::KinType,allocator<Smear::KinType> >::size_type"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("empty",559,G__smearDict_458_0_12, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator[]",1060,G__smearDict_458_0_13, 105, G__get_linked_tagnum(&G__smearDictLN_SmearcLcLKinType), G__defined_typename("vector<Smear::KinType,allocator<Smear::KinType> >::reference"), 1, 1, 1, 1, 0, "k - 'vector<Smear::KinType,allocator<Smear::KinType> >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator[]",1060,G__smearDict_458_0_14, 105, G__get_linked_tagnum(&G__smearDictLN_SmearcLcLKinType), G__defined_typename("vector<Smear::KinType,allocator<Smear::KinType> >::const_reference"), 1, 1, 1, 1, 8, "k - 'vector<Smear::KinType,allocator<Smear::KinType> >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<Smear::KinType,allocator<Smear::KinType> >",4596,G__smearDict_458_0_15, 105, G__get_linked_tagnum(&G__smearDictLN_vectorlESmearcLcLKinTypecOallocatorlESmearcLcLKinTypegRsPgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<Smear::KinType,allocator<Smear::KinType> >",4596,G__smearDict_458_0_16, 105, G__get_linked_tagnum(&G__smearDictLN_vectorlESmearcLcLKinTypecOallocatorlESmearcLcLKinTypegRsPgR), -1, 0, 2, 1, 1, 0, 
"k - 'vector<Smear::KinType,allocator<Smear::KinType> >::size_type' 0 - n i 'Smear::KinType' - 11 'Smear::KinType()' value", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<Smear::KinType,allocator<Smear::KinType> >",4596,G__smearDict_458_0_17, 105, G__get_linked_tagnum(&G__smearDictLN_vectorlESmearcLcLKinTypecOallocatorlESmearcLcLKinTypegRsPgR), -1, 0, 1, 1, 1, 0, "u 'vector<Smear::KinType,allocator<Smear::KinType> >' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<Smear::KinType,allocator<Smear::KinType> >",4596,G__smearDict_458_0_18, 105, G__get_linked_tagnum(&G__smearDictLN_vectorlESmearcLcLKinTypecOallocatorlESmearcLcLKinTypegRsPgR), -1, 0, 2, 1, 1, 0, 
"u 'vector<Smear::KinType,allocator<Smear::KinType> >::iterator' 'vector<Smear::KinType,allocator<Smear::KinType> >::const_iterator' 10 - first u 'vector<Smear::KinType,allocator<Smear::KinType> >::iterator' 'vector<Smear::KinType,allocator<Smear::KinType> >::const_iterator' 10 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,G__smearDict_458_0_19, 117, G__get_linked_tagnum(&G__smearDictLN_vectorlESmearcLcLKinTypecOallocatorlESmearcLcLKinTypegRsPgR), -1, 1, 1, 1, 1, 0, "u 'vector<Smear::KinType,allocator<Smear::KinType> >' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("reserve",764,G__smearDict_458_0_20, 121, -1, -1, 0, 1, 1, 1, 0, "k - 'vector<Smear::KinType,allocator<Smear::KinType> >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("front",553,G__smearDict_458_0_21, 105, G__get_linked_tagnum(&G__smearDictLN_SmearcLcLKinType), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("back",401,G__smearDict_458_0_22, 105, G__get_linked_tagnum(&G__smearDictLN_SmearcLcLKinType), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("push_back",944,G__smearDict_458_0_23, 121, -1, -1, 0, 1, 1, 1, 0, "i 'Smear::KinType' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("swap",443,G__smearDict_458_0_24, 121, -1, -1, 0, 1, 1, 1, 0, "u 'vector<Smear::KinType,allocator<Smear::KinType> >' - 1 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__smearDict_458_0_25, 117, G__get_linked_tagnum(&G__smearDictLN_vectorlESmearcLcLKinTypecOallocatorlESmearcLcLKinTypegRsPgRcLcLiterator), -1, 0, 2, 1, 1, 0, 
"u 'vector<Smear::KinType,allocator<Smear::KinType> >::iterator' - 0 - position i 'Smear::KinType' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__smearDict_458_0_26, 121, -1, -1, 0, 3, 1, 1, 0, 
"u 'vector<Smear::KinType,allocator<Smear::KinType> >::iterator' - 0 - position u 'vector<Smear::KinType,allocator<Smear::KinType> >::iterator' 'vector<Smear::KinType,allocator<Smear::KinType> >::const_iterator' 10 - first "
"u 'vector<Smear::KinType,allocator<Smear::KinType> >::iterator' 'vector<Smear::KinType,allocator<Smear::KinType> >::const_iterator' 10 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__smearDict_458_0_27, 121, -1, -1, 0, 3, 1, 1, 0, 
"u 'vector<Smear::KinType,allocator<Smear::KinType> >::iterator' - 0 - position k - 'vector<Smear::KinType,allocator<Smear::KinType> >::size_type' 0 - n "
"i 'Smear::KinType' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pop_back",831,G__smearDict_458_0_28, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("erase",528,G__smearDict_458_0_29, 121, -1, -1, 0, 1, 1, 1, 0, "u 'vector<Smear::KinType,allocator<Smear::KinType> >::iterator' - 0 - position", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("erase",528,G__smearDict_458_0_30, 121, -1, -1, 0, 2, 1, 1, 0, 
"u 'vector<Smear::KinType,allocator<Smear::KinType> >::iterator' - 0 - first u 'vector<Smear::KinType,allocator<Smear::KinType> >::iterator' - 0 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("clear",519,G__smearDict_458_0_31, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~vector<Smear::KinType,allocator<Smear::KinType> >", 4722, G__smearDict_458_0_32, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncSmearcLcLBremsstrahlung(void) {
   /* Smear::Bremsstrahlung */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__smearDictLN_SmearcLcLBremsstrahlung));
   G__memfunc_setup("Bremsstrahlung",1489,G__smearDict_461_0_1, 105, G__get_linked_tagnum(&G__smearDictLN_SmearcLcLBremsstrahlung), -1, 0, 3, 1, 1, 0, 
"d - - 0 '0.01' epsilon d - - 0 '10.' traversed "
"d - - 0 '47.1' radLength", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Bremsstrahlung",1489,G__smearDict_461_0_2, 105, G__get_linked_tagnum(&G__smearDictLN_SmearcLcLBremsstrahlung), -1, 0, 1, 1, 1, 0, "u 'Smear::Bremsstrahlung' - 11 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Clone",497,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__smearDictLN_SmearcLcLBremsstrahlung), -1, 0, 1, 1, 1, 8, "C - 'Option_t' 10 '\"not used\"' option", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Smear",504,(G__InterfaceMethod) NULL,121, -1, -1, 0, 2, 1, 1, 0, 
"u 'erhic::VirtualParticle' - 11 - - u 'Smear::ParticleMCS' - 1 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("dSigmadK",772,(G__InterfaceMethod) NULL, 100, -1, -1, 0, 2, 1, 2, 0, 
"D - - 0 - x D - - 0 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("NGamma",561,(G__InterfaceMethod) NULL, 105, -1, -1, 0, 0, 1, 2, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FixParticleKinematics",2147,(G__InterfaceMethod) NULL, 121, -1, -1, 0, 1, 1, 2, 0, "u 'Smear::ParticleMCS' - 1 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetParticle",1120,(G__InterfaceMethod) NULL, 121, -1, -1, 0, 1, 1, 2, 0, "u 'erhic::VirtualParticle' - 11 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetupPDF",747,(G__InterfaceMethod) NULL, 103, -1, -1, 0, 0, 1, 2, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Class",502,G__smearDict_461_0_10, 85, G__get_linked_tagnum(&G__smearDictLN_TClass), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (TClass* (*)())(&Smear::Bremsstrahlung::Class) ), 0);
   G__memfunc_setup("Class_Name",982,G__smearDict_461_0_11, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&Smear::Bremsstrahlung::Class_Name) ), 0);
   G__memfunc_setup("Class_Version",1339,G__smearDict_461_0_12, 115, -1, G__defined_typename("Version_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Version_t (*)())(&Smear::Bremsstrahlung::Class_Version) ), 0);
   G__memfunc_setup("Dictionary",1046,G__smearDict_461_0_13, 121, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (void (*)())(&Smear::Bremsstrahlung::Dictionary) ), 0);
   G__memfunc_setup("IsA",253,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__smearDictLN_TClass), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ShowMembers",1132,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TMemberInspector' - 1 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Streamer",835,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("StreamerNVirtual",1656,G__smearDict_461_0_17, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - ClassDef_StreamerNVirtual_b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DeclFileName",1145,G__smearDict_461_0_18, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&Smear::Bremsstrahlung::DeclFileName) ), 0);
   G__memfunc_setup("ImplFileLine",1178,G__smearDict_461_0_19, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&Smear::Bremsstrahlung::ImplFileLine) ), 0);
   G__memfunc_setup("ImplFileName",1171,G__smearDict_461_0_20, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&Smear::Bremsstrahlung::ImplFileName) ), 0);
   G__memfunc_setup("DeclFileLine",1152,G__smearDict_461_0_21, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&Smear::Bremsstrahlung::DeclFileLine) ), 0);
   // automatic destructor
   G__memfunc_setup("~Bremsstrahlung", 1615, G__smearDict_461_0_22, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncauto_ptrlEerhiccLcLParticleMCgR(void) {
   /* auto_ptr<erhic::ParticleMC> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__smearDictLN_auto_ptrlEerhiccLcLParticleMCgR));
   G__memfunc_setup("auto_ptr<erhic::ParticleMC>",2603,G__smearDict_462_0_1, 105, G__get_linked_tagnum(&G__smearDictLN_auto_ptrlEerhiccLcLParticleMCgR), -1, 0, 1, 5, 1, 0, "U 'erhic::ParticleMC' - 0 '0' p", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("auto_ptr<erhic::ParticleMC>",2603,G__smearDict_462_0_2, 105, G__get_linked_tagnum(&G__smearDictLN_auto_ptrlEerhiccLcLParticleMCgR), -1, 0, 1, 1, 1, 0, "u 'auto_ptr<erhic::ParticleMC>' - 1 - a", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,G__smearDict_462_0_3, 117, G__get_linked_tagnum(&G__smearDictLN_auto_ptrlEerhiccLcLParticleMCgR), -1, 1, 1, 1, 1, 0, "u 'auto_ptr<erhic::ParticleMC>' - 1 - a", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator*",918,G__smearDict_462_0_4, 117, G__get_linked_tagnum(&G__smearDictLN_erhiccLcLParticleMC), -1, 1, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator->",983,G__smearDict_462_0_5, 85, G__get_linked_tagnum(&G__smearDictLN_erhiccLcLParticleMC), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("get",320,G__smearDict_462_0_6, 85, G__get_linked_tagnum(&G__smearDictLN_erhiccLcLParticleMC), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("release",737,G__smearDict_462_0_7, 85, G__get_linked_tagnum(&G__smearDictLN_erhiccLcLParticleMC), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~auto_ptr<erhic::ParticleMC>", 2729, G__smearDict_462_0_8, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncSmearcLcLDetector(void) {
   /* Smear::Detector */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__smearDictLN_SmearcLcLDetector));
   G__memfunc_setup("Detector",826,G__smearDict_463_0_1, 105, G__get_linked_tagnum(&G__smearDictLN_SmearcLcLDetector), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Detector",826,G__smearDict_463_0_2, 105, G__get_linked_tagnum(&G__smearDictLN_SmearcLcLDetector), -1, 0, 1, 1, 1, 0, "u 'Smear::Detector' - 11 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,G__smearDict_463_0_3, 117, G__get_linked_tagnum(&G__smearDictLN_SmearcLcLDetector), -1, 1, 1, 1, 1, 0, "u 'Smear::Detector' - 11 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddDevice",857,G__smearDict_463_0_4, 121, -1, -1, 0, 1, 1, 1, 0, "u 'Smear::Smearer' - 1 - device", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetEventKinematicsCalculator",2880,G__smearDict_463_0_5, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TString' - 0 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DeleteAllDevices",1583,G__smearDict_463_0_6, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetDevice",880,G__smearDict_463_0_7, 85, G__get_linked_tagnum(&G__smearDictLN_SmearcLcLSmearer), -1, 0, 1, 1, 1, 0, "i - - 0 - index", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetNDevices",1073,G__smearDict_463_0_8, 104, -1, G__defined_typename("UInt_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FillEventKinematics",1937,G__smearDict_463_0_9, 121, -1, -1, 0, 1, 1, 1, 0, "U 'Smear::Event' - 0 - event", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Smear",504,G__smearDict_463_0_10, 85, G__get_linked_tagnum(&G__smearDictLN_SmearcLcLParticleMCS), -1, 0, 1, 1, 1, 8, "u 'erhic::VirtualParticle' - 11 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Print",525,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 8, "C - 'Option_t' 10 '\"\"' -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Accept",592,G__smearDict_463_0_12, 117, G__get_linked_tagnum(&G__smearDictLN_listlESmearcLcLSmearermUcOallocatorlESmearcLcLSmearermUgRsPgR), G__defined_typename("list<Smear::Smearer*>"), 0, 1, 1, 1, 8, "u 'erhic::VirtualParticle' - 11 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("CopyDevices",1118,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__smearDictLN_vectorlESmearcLcLSmearermUcOallocatorlESmearcLcLSmearermUgRsPgR), G__defined_typename("vector<Smear::Smearer*>"), 0, 0, 1, 2, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Class",502,G__smearDict_463_0_14, 85, G__get_linked_tagnum(&G__smearDictLN_TClass), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (TClass* (*)())(&Smear::Detector::Class) ), 0);
   G__memfunc_setup("Class_Name",982,G__smearDict_463_0_15, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&Smear::Detector::Class_Name) ), 0);
   G__memfunc_setup("Class_Version",1339,G__smearDict_463_0_16, 115, -1, G__defined_typename("Version_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Version_t (*)())(&Smear::Detector::Class_Version) ), 0);
   G__memfunc_setup("Dictionary",1046,G__smearDict_463_0_17, 121, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (void (*)())(&Smear::Detector::Dictionary) ), 0);
   G__memfunc_setup("IsA",253,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__smearDictLN_TClass), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ShowMembers",1132,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TMemberInspector' - 1 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Streamer",835,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("StreamerNVirtual",1656,G__smearDict_463_0_21, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - ClassDef_StreamerNVirtual_b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DeclFileName",1145,G__smearDict_463_0_22, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&Smear::Detector::DeclFileName) ), 0);
   G__memfunc_setup("ImplFileLine",1178,G__smearDict_463_0_23, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&Smear::Detector::ImplFileLine) ), 0);
   G__memfunc_setup("ImplFileName",1171,G__smearDict_463_0_24, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&Smear::Detector::ImplFileName) ), 0);
   G__memfunc_setup("DeclFileLine",1152,G__smearDict_463_0_25, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&Smear::Detector::DeclFileLine) ), 0);
   // automatic destructor
   G__memfunc_setup("~Detector", 952, G__smearDict_463_0_26, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncSmearcLcLParticleID(void) {
   /* Smear::ParticleID */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__smearDictLN_SmearcLcLParticleID));
   G__memfunc_setup("ParticleID",961,G__smearDict_765_0_1, 105, G__get_linked_tagnum(&G__smearDictLN_SmearcLcLParticleID), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ParticleID",961,G__smearDict_765_0_2, 105, G__get_linked_tagnum(&G__smearDictLN_SmearcLcLParticleID), -1, 0, 1, 5, 1, 0, "u 'TString' - 0 - filename", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetPMatrixPath",1406,G__smearDict_765_0_3, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TString' - 0 - str", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetPIDUseMC",966,G__smearDict_765_0_4, 121, -1, -1, 0, 1, 1, 1, 0, "g - - 0 - d", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetRandomGenerator",1832,G__smearDict_765_0_5, 117, G__get_linked_tagnum(&G__smearDictLN_TRandom3), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetRanSeed",974,G__smearDict_765_0_6, 121, -1, -1, 0, 1, 1, 1, 0, "i - - 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetAcceptanceFromDevice",2283,G__smearDict_765_0_7, 121, -1, -1, 0, 1, 1, 1, 0, "u 'Smear::Device' - 11 - dev", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetPMatrixSize",1420,G__smearDict_765_0_8, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetupProbabilityArray",2193,G__smearDict_765_0_9, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Clone",497,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__smearDictLN_SmearcLcLParticleID), -1, 0, 1, 1, 1, 8, "C - - 10 '\"\"' -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Wild",400,G__smearDict_765_0_11, 105, -1, -1, 0, 2, 1, 1, 0, 
"i - - 0 - pbin i - - 0 - trueID", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("InListOfTrue",1192,G__smearDict_765_0_12, 105, -1, -1, 0, 1, 1, 1, 0, "i - - 0 - ID", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("InListOfFalse",1267,G__smearDict_765_0_13, 105, -1, -1, 0, 1, 1, 1, 0, "i - - 0 - ID", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ReadP",460,G__smearDict_765_0_14, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TString' - 0 - filename", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Smear",504,(G__InterfaceMethod) NULL,121, -1, -1, 0, 2, 1, 1, 0, 
"u 'erhic::VirtualParticle' - 11 - - u 'Smear::ParticleMCS' - 1 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Speak",500,G__smearDict_765_0_16, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Clear",487,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "C - 'Option_t' 10 '\"\"' -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Print",525,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 8, "C - 'Option_t' 10 '\"\"' -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Class",502,G__smearDict_765_0_19, 85, G__get_linked_tagnum(&G__smearDictLN_TClass), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (TClass* (*)())(&Smear::ParticleID::Class) ), 0);
   G__memfunc_setup("Class_Name",982,G__smearDict_765_0_20, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&Smear::ParticleID::Class_Name) ), 0);
   G__memfunc_setup("Class_Version",1339,G__smearDict_765_0_21, 115, -1, G__defined_typename("Version_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Version_t (*)())(&Smear::ParticleID::Class_Version) ), 0);
   G__memfunc_setup("Dictionary",1046,G__smearDict_765_0_22, 121, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (void (*)())(&Smear::ParticleID::Dictionary) ), 0);
   G__memfunc_setup("IsA",253,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__smearDictLN_TClass), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ShowMembers",1132,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TMemberInspector' - 1 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Streamer",835,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("StreamerNVirtual",1656,G__smearDict_765_0_26, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - ClassDef_StreamerNVirtual_b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DeclFileName",1145,G__smearDict_765_0_27, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&Smear::ParticleID::DeclFileName) ), 0);
   G__memfunc_setup("ImplFileLine",1178,G__smearDict_765_0_28, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&Smear::ParticleID::ImplFileLine) ), 0);
   G__memfunc_setup("ImplFileName",1171,G__smearDict_765_0_29, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&Smear::ParticleID::ImplFileName) ), 0);
   G__memfunc_setup("DeclFileLine",1152,G__smearDict_765_0_30, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&Smear::ParticleID::DeclFileLine) ), 0);
   // automatic copy constructor
   G__memfunc_setup("ParticleID", 961, G__smearDict_765_0_31, (int) ('i'), G__get_linked_tagnum(&G__smearDictLN_SmearcLcLParticleID), -1, 0, 1, 1, 1, 0, "u 'Smear::ParticleID' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~ParticleID", 1087, G__smearDict_765_0_32, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__smearDict_765_0_33, (int) ('u'), G__get_linked_tagnum(&G__smearDictLN_SmearcLcLParticleID), -1, 1, 1, 1, 1, 0, "u 'Smear::ParticleID' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncvectorlEintcOallocatorlEintgRsPgR(void) {
   /* vector<int,allocator<int> > */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__smearDictLN_vectorlEintcOallocatorlEintgRsPgR));
   G__memfunc_setup("at",213,G__smearDict_766_0_1, 105, -1, G__defined_typename("vector<int,allocator<int> >::reference"), 1, 1, 1, 1, 0, "k - 'vector<int,allocator<int> >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("at",213,G__smearDict_766_0_2, 105, -1, G__defined_typename("vector<int,allocator<int> >::const_reference"), 1, 1, 1, 1, 8, "k - 'vector<int,allocator<int> >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("begin",517,G__smearDict_766_0_3, 117, G__get_linked_tagnum(&G__smearDictLN_vectorlEintcOallocatorlEintgRsPgRcLcLiterator), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("end",311,G__smearDict_766_0_4, 117, G__get_linked_tagnum(&G__smearDictLN_vectorlEintcOallocatorlEintgRsPgRcLcLiterator), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("rbegin",631,G__smearDict_766_0_5, 117, G__get_linked_tagnum(&G__smearDictLN_reverse_iteratorlEvectorlEintcOallocatorlEintgRsPgRcLcLiteratorgR), G__defined_typename("vector<int,allocator<int> >::reverse_iterator"), 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("rend",425,G__smearDict_766_0_6, 117, G__get_linked_tagnum(&G__smearDictLN_reverse_iteratorlEvectorlEintcOallocatorlEintgRsPgRcLcLiteratorgR), G__defined_typename("vector<int,allocator<int> >::reverse_iterator"), 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("size",443,G__smearDict_766_0_7, 107, -1, G__defined_typename("vector<int,allocator<int> >::size_type"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("max_size",864,G__smearDict_766_0_8, 107, -1, G__defined_typename("vector<int,allocator<int> >::size_type"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("resize",658,G__smearDict_766_0_9, 121, -1, -1, 0, 1, 1, 1, 0, "k - 'vector<int,allocator<int> >::size_type' 0 - sz", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("resize",658,G__smearDict_766_0_10, 121, -1, -1, 0, 2, 1, 1, 0, 
"k - 'vector<int,allocator<int> >::size_type' 0 - sz i - - 0 - c", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("capacity",846,G__smearDict_766_0_11, 107, -1, G__defined_typename("vector<int,allocator<int> >::size_type"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("empty",559,G__smearDict_766_0_12, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator[]",1060,G__smearDict_766_0_13, 105, -1, G__defined_typename("vector<int,allocator<int> >::reference"), 1, 1, 1, 1, 0, "k - 'vector<int,allocator<int> >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator[]",1060,G__smearDict_766_0_14, 105, -1, G__defined_typename("vector<int,allocator<int> >::const_reference"), 1, 1, 1, 1, 8, "k - 'vector<int,allocator<int> >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<int,allocator<int> >",2602,G__smearDict_766_0_15, 105, G__get_linked_tagnum(&G__smearDictLN_vectorlEintcOallocatorlEintgRsPgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<int,allocator<int> >",2602,G__smearDict_766_0_16, 105, G__get_linked_tagnum(&G__smearDictLN_vectorlEintcOallocatorlEintgRsPgR), -1, 0, 2, 1, 1, 0, 
"k - 'vector<int,allocator<int> >::size_type' 0 - n i - - 11 'int()' value", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<int,allocator<int> >",2602,G__smearDict_766_0_17, 105, G__get_linked_tagnum(&G__smearDictLN_vectorlEintcOallocatorlEintgRsPgR), -1, 0, 1, 1, 1, 0, "u 'vector<int,allocator<int> >' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<int,allocator<int> >",2602,G__smearDict_766_0_18, 105, G__get_linked_tagnum(&G__smearDictLN_vectorlEintcOallocatorlEintgRsPgR), -1, 0, 2, 1, 1, 0, 
"u 'vector<int,allocator<int> >::iterator' 'vector<int,allocator<int> >::const_iterator' 10 - first u 'vector<int,allocator<int> >::iterator' 'vector<int,allocator<int> >::const_iterator' 10 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,G__smearDict_766_0_19, 117, G__get_linked_tagnum(&G__smearDictLN_vectorlEintcOallocatorlEintgRsPgR), -1, 1, 1, 1, 1, 0, "u 'vector<int,allocator<int> >' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("reserve",764,G__smearDict_766_0_20, 121, -1, -1, 0, 1, 1, 1, 0, "k - 'vector<int,allocator<int> >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("front",553,G__smearDict_766_0_21, 105, -1, -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("back",401,G__smearDict_766_0_22, 105, -1, -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("push_back",944,G__smearDict_766_0_23, 121, -1, -1, 0, 1, 1, 1, 0, "i - - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("swap",443,G__smearDict_766_0_24, 121, -1, -1, 0, 1, 1, 1, 0, "u 'vector<int,allocator<int> >' - 1 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__smearDict_766_0_25, 117, G__get_linked_tagnum(&G__smearDictLN_vectorlEintcOallocatorlEintgRsPgRcLcLiterator), -1, 0, 2, 1, 1, 0, 
"u 'vector<int,allocator<int> >::iterator' - 0 - position i - - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__smearDict_766_0_26, 121, -1, -1, 0, 3, 1, 1, 0, 
"u 'vector<int,allocator<int> >::iterator' - 0 - position u 'vector<int,allocator<int> >::iterator' 'vector<int,allocator<int> >::const_iterator' 10 - first "
"u 'vector<int,allocator<int> >::iterator' 'vector<int,allocator<int> >::const_iterator' 10 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__smearDict_766_0_27, 121, -1, -1, 0, 3, 1, 1, 0, 
"u 'vector<int,allocator<int> >::iterator' - 0 - position k - 'vector<int,allocator<int> >::size_type' 0 - n "
"i - - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pop_back",831,G__smearDict_766_0_28, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("erase",528,G__smearDict_766_0_29, 121, -1, -1, 0, 1, 1, 1, 0, "u 'vector<int,allocator<int> >::iterator' - 0 - position", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("erase",528,G__smearDict_766_0_30, 121, -1, -1, 0, 2, 1, 1, 0, 
"u 'vector<int,allocator<int> >::iterator' - 0 - first u 'vector<int,allocator<int> >::iterator' - 0 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("clear",519,G__smearDict_766_0_31, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~vector<int,allocator<int> >", 2728, G__smearDict_766_0_32, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncSmearcLcLPerfectID(void) {
   /* Smear::PerfectID */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__smearDictLN_SmearcLcLPerfectID));
   G__memfunc_setup("PerfectID",854,G__smearDict_777_0_1, 105, G__get_linked_tagnum(&G__smearDictLN_SmearcLcLPerfectID), -1, 0, 1, 1, 1, 0, "u 'vector<int,allocator<int> >' 'vector<Int_t>' 11 'std::vector<int>()' pdg", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Clone",497,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__smearDictLN_SmearcLcLPerfectID), -1, 0, 1, 1, 1, 8, "C - - 10 '\"\"' -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Smear",504,(G__InterfaceMethod) NULL,121, -1, -1, 0, 2, 1, 1, 0, 
"u 'erhic::VirtualParticle' - 11 - - u 'Smear::ParticleMCS' - 1 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Print",525,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 8, "C - 'Option_t' 10 '\"\"' -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Insert",629,G__smearDict_777_0_5, 121, -1, -1, 0, 1, 1, 1, 0, "i - 'Int_t' 0 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Class",502,G__smearDict_777_0_6, 85, G__get_linked_tagnum(&G__smearDictLN_TClass), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (TClass* (*)())(&Smear::PerfectID::Class) ), 0);
   G__memfunc_setup("Class_Name",982,G__smearDict_777_0_7, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&Smear::PerfectID::Class_Name) ), 0);
   G__memfunc_setup("Class_Version",1339,G__smearDict_777_0_8, 115, -1, G__defined_typename("Version_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Version_t (*)())(&Smear::PerfectID::Class_Version) ), 0);
   G__memfunc_setup("Dictionary",1046,G__smearDict_777_0_9, 121, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (void (*)())(&Smear::PerfectID::Dictionary) ), 0);
   G__memfunc_setup("IsA",253,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__smearDictLN_TClass), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ShowMembers",1132,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TMemberInspector' - 1 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Streamer",835,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("StreamerNVirtual",1656,G__smearDict_777_0_13, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - ClassDef_StreamerNVirtual_b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DeclFileName",1145,G__smearDict_777_0_14, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&Smear::PerfectID::DeclFileName) ), 0);
   G__memfunc_setup("ImplFileLine",1178,G__smearDict_777_0_15, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&Smear::PerfectID::ImplFileLine) ), 0);
   G__memfunc_setup("ImplFileName",1171,G__smearDict_777_0_16, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&Smear::PerfectID::ImplFileName) ), 0);
   G__memfunc_setup("DeclFileLine",1152,G__smearDict_777_0_17, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&Smear::PerfectID::DeclFileLine) ), 0);
   // automatic copy constructor
   G__memfunc_setup("PerfectID", 854, G__smearDict_777_0_18, (int) ('i'), G__get_linked_tagnum(&G__smearDictLN_SmearcLcLPerfectID), -1, 0, 1, 1, 1, 0, "u 'Smear::PerfectID' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~PerfectID", 980, G__smearDict_777_0_19, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__smearDict_777_0_20, (int) ('u'), G__get_linked_tagnum(&G__smearDictLN_SmearcLcLPerfectID), -1, 1, 1, 1, 1, 0, "u 'Smear::PerfectID' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncSmearcLcLTracker(void) {
   /* Smear::Tracker */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__smearDictLN_SmearcLcLTracker));
   G__memfunc_setup("Resolution",1076,G__smearDict_778_0_2, 100, -1, -1, 0, 1, 1, 1, 8, "u 'erhic::VirtualParticle' - 11 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Smear",504,(G__InterfaceMethod) NULL,121, -1, -1, 0, 2, 1, 1, 0, 
"u 'erhic::VirtualParticle' - 11 - - u 'Smear::ParticleMCS' - 1 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("L",76,G__smearDict_778_0_4, 100, -1, -1, 0, 1, 1, 1, 8, "u 'erhic::VirtualParticle' - 11 - -", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("LPrime",585,G__smearDict_778_0_5, 100, -1, -1, 0, 1, 1, 1, 8, "u 'erhic::VirtualParticle' - 11 - -", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("NPoints",715,G__smearDict_778_0_6, 105, -1, -1, 0, 1, 1, 1, 8, "u 'erhic::VirtualParticle' - 11 - -", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("Accepts",707,G__smearDict_778_0_7, 103, -1, -1, 0, 1, 1, 1, 8, "u 'erhic::VirtualParticle' - 11 - -", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("GetThetaMin",1082,G__smearDict_778_0_8, 100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("GetThetaMax",1084,G__smearDict_778_0_9, 100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("SetVertexConstraint",1999,G__smearDict_778_0_10, 121, -1, -1, 0, 1, 1, 1, 0, "g - - 0 - constrain", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("MultipleScatteringContribution",3168,(G__InterfaceMethod) NULL, 100, -1, -1, 0, 1, 1, 2, 8, "u 'erhic::VirtualParticle' - 11 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("IntrinsicContribution",2227,(G__InterfaceMethod) NULL, 100, -1, -1, 0, 1, 1, 2, 8, "u 'erhic::VirtualParticle' - 11 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Class",502,G__smearDict_778_0_13, 85, G__get_linked_tagnum(&G__smearDictLN_TClass), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (TClass* (*)())(&Smear::Tracker::Class) ), 0);
   G__memfunc_setup("Class_Name",982,G__smearDict_778_0_14, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&Smear::Tracker::Class_Name) ), 0);
   G__memfunc_setup("Class_Version",1339,G__smearDict_778_0_15, 115, -1, G__defined_typename("Version_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Version_t (*)())(&Smear::Tracker::Class_Version) ), 0);
   G__memfunc_setup("Dictionary",1046,G__smearDict_778_0_16, 121, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (void (*)())(&Smear::Tracker::Dictionary) ), 0);
   G__memfunc_setup("IsA",253,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__smearDictLN_TClass), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ShowMembers",1132,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TMemberInspector' - 1 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Streamer",835,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("StreamerNVirtual",1656,G__smearDict_778_0_20, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - ClassDef_StreamerNVirtual_b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DeclFileName",1145,G__smearDict_778_0_21, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&Smear::Tracker::DeclFileName) ), 0);
   G__memfunc_setup("ImplFileLine",1178,G__smearDict_778_0_22, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&Smear::Tracker::ImplFileLine) ), 0);
   G__memfunc_setup("ImplFileName",1171,G__smearDict_778_0_23, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&Smear::Tracker::ImplFileName) ), 0);
   G__memfunc_setup("DeclFileLine",1152,G__smearDict_778_0_24, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&Smear::Tracker::DeclFileLine) ), 0);
   // automatic destructor
   G__memfunc_setup("~Tracker", 842, G__smearDict_778_0_25, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__smearDict_778_0_26, (int) ('u'), G__get_linked_tagnum(&G__smearDictLN_SmearcLcLTracker), -1, 1, 1, 1, 1, 0, "u 'Smear::Tracker' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncSmearcLcLPlanarTracker(void) {
   /* Smear::PlanarTracker */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__smearDictLN_SmearcLcLPlanarTracker));
   G__memfunc_setup("PlanarTracker",1322,G__smearDict_779_0_1, 105, G__get_linked_tagnum(&G__smearDictLN_SmearcLcLPlanarTracker), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("PlanarTracker",1322,G__smearDict_779_0_2, 105, G__get_linked_tagnum(&G__smearDictLN_SmearcLcLPlanarTracker), -1, 0, 8, 1, 1, 0, 
"d - - 0 - innerRadius d - - 0 - outerRadius "
"d - - 0 - zMin d - - 0 - zMax "
"d - - 0 - magneticField d - - 0 - nRadiationLengths "
"d - - 0 - sigmaRPhi d - - 0 - nPlanes", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Clone",497,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__smearDictLN_SmearcLcLPlanarTracker), -1, 0, 1, 1, 1, 8, "C - - 10 '\"\"' -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Print",525,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 8, "C - 'Option_t' 10 '\"\"' -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("L",76,(G__InterfaceMethod) NULL,100, -1, -1, 0, 1, 1, 1, 8, "u 'erhic::VirtualParticle' - 11 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("LPrime",585,(G__InterfaceMethod) NULL,100, -1, -1, 0, 1, 1, 1, 8, "u 'erhic::VirtualParticle' - 11 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("NPoints",715,(G__InterfaceMethod) NULL,105, -1, -1, 0, 1, 1, 1, 8, "u 'erhic::VirtualParticle' - 11 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Accepts",707,(G__InterfaceMethod) NULL,103, -1, -1, 0, 1, 1, 1, 8, "u 'erhic::VirtualParticle' - 11 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetThetaMin",1082,(G__InterfaceMethod) NULL,100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetThetaMax",1084,(G__InterfaceMethod) NULL,100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ComputeIntersectionWithRadius",3032,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__smearDictLN_TVector3), -1, 0, 2, 1, 2, 8, 
"u 'erhic::VirtualParticle' - 11 - - d - - 0 - radius", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ComputeIntersectionWithPlane",2912,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__smearDictLN_TVector3), -1, 0, 2, 1, 2, 8, 
"u 'erhic::VirtualParticle' - 11 - - d - - 0 - z", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ComputePath",1130,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__smearDictLN_TVector3), -1, 0, 1, 1, 2, 8, "u 'erhic::VirtualParticle' - 11 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Class",502,G__smearDict_779_0_14, 85, G__get_linked_tagnum(&G__smearDictLN_TClass), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (TClass* (*)())(&Smear::PlanarTracker::Class) ), 0);
   G__memfunc_setup("Class_Name",982,G__smearDict_779_0_15, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&Smear::PlanarTracker::Class_Name) ), 0);
   G__memfunc_setup("Class_Version",1339,G__smearDict_779_0_16, 115, -1, G__defined_typename("Version_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Version_t (*)())(&Smear::PlanarTracker::Class_Version) ), 0);
   G__memfunc_setup("Dictionary",1046,G__smearDict_779_0_17, 121, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (void (*)())(&Smear::PlanarTracker::Dictionary) ), 0);
   G__memfunc_setup("IsA",253,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__smearDictLN_TClass), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ShowMembers",1132,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TMemberInspector' - 1 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Streamer",835,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("StreamerNVirtual",1656,G__smearDict_779_0_21, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - ClassDef_StreamerNVirtual_b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DeclFileName",1145,G__smearDict_779_0_22, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&Smear::PlanarTracker::DeclFileName) ), 0);
   G__memfunc_setup("ImplFileLine",1178,G__smearDict_779_0_23, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&Smear::PlanarTracker::ImplFileLine) ), 0);
   G__memfunc_setup("ImplFileName",1171,G__smearDict_779_0_24, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&Smear::PlanarTracker::ImplFileName) ), 0);
   G__memfunc_setup("DeclFileLine",1152,G__smearDict_779_0_25, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&Smear::PlanarTracker::DeclFileLine) ), 0);
   // automatic copy constructor
   G__memfunc_setup("PlanarTracker", 1322, G__smearDict_779_0_26, (int) ('i'), G__get_linked_tagnum(&G__smearDictLN_SmearcLcLPlanarTracker), -1, 0, 1, 1, 1, 0, "u 'Smear::PlanarTracker' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~PlanarTracker", 1448, G__smearDict_779_0_27, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__smearDict_779_0_28, (int) ('u'), G__get_linked_tagnum(&G__smearDictLN_SmearcLcLPlanarTracker), -1, 1, 1, 1, 1, 0, "u 'Smear::PlanarTracker' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncSmearcLcLRadialTracker(void) {
   /* Smear::RadialTracker */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__smearDictLN_SmearcLcLRadialTracker));
   G__memfunc_setup("RadialTracker",1305,G__smearDict_780_0_1, 105, G__get_linked_tagnum(&G__smearDictLN_SmearcLcLRadialTracker), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("RadialTracker",1305,G__smearDict_780_0_2, 105, G__get_linked_tagnum(&G__smearDictLN_SmearcLcLRadialTracker), -1, 0, 8, 1, 1, 0, 
"d - - 0 - innerRadius d - - 0 - outerRadius "
"d - - 0 - zMin d - - 0 - zMax "
"d - - 0 - magneticField d - - 0 - numberOfRadiationLengths "
"d - - 0 - sigmaRPhi d - - 0 - numberOfPoints", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Clone",497,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__smearDictLN_SmearcLcLRadialTracker), -1, 0, 1, 1, 1, 8, "C - - 10 '\"\"' -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Print",525,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 8, "C - 'Option_t' 10 '\"\"' -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("L",76,(G__InterfaceMethod) NULL,100, -1, -1, 0, 1, 1, 1, 8, "u 'erhic::VirtualParticle' - 11 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("LPrime",585,(G__InterfaceMethod) NULL,100, -1, -1, 0, 1, 1, 1, 8, "u 'erhic::VirtualParticle' - 11 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("NPoints",715,(G__InterfaceMethod) NULL,105, -1, -1, 0, 1, 1, 1, 8, "u 'erhic::VirtualParticle' - 11 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Accepts",707,(G__InterfaceMethod) NULL,103, -1, -1, 0, 1, 1, 1, 8, "u 'erhic::VirtualParticle' - 11 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetThetaMin",1082,(G__InterfaceMethod) NULL,100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetThetaMax",1084,(G__InterfaceMethod) NULL,100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ComputeIntersectionWithRadius",3032,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__smearDictLN_TVector3), -1, 0, 2, 1, 2, 8, 
"u 'erhic::VirtualParticle' - 11 - - d - - 0 - radius", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ComputeIntersectionWithPlane",2912,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__smearDictLN_TVector3), -1, 0, 2, 1, 2, 8, 
"u 'erhic::VirtualParticle' - 11 - - d - - 0 - z", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ComputePath",1130,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__smearDictLN_TVector3), -1, 0, 1, 1, 2, 8, "u 'erhic::VirtualParticle' - 11 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Class",502,G__smearDict_780_0_14, 85, G__get_linked_tagnum(&G__smearDictLN_TClass), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (TClass* (*)())(&Smear::RadialTracker::Class) ), 0);
   G__memfunc_setup("Class_Name",982,G__smearDict_780_0_15, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&Smear::RadialTracker::Class_Name) ), 0);
   G__memfunc_setup("Class_Version",1339,G__smearDict_780_0_16, 115, -1, G__defined_typename("Version_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Version_t (*)())(&Smear::RadialTracker::Class_Version) ), 0);
   G__memfunc_setup("Dictionary",1046,G__smearDict_780_0_17, 121, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (void (*)())(&Smear::RadialTracker::Dictionary) ), 0);
   G__memfunc_setup("IsA",253,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__smearDictLN_TClass), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ShowMembers",1132,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TMemberInspector' - 1 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Streamer",835,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("StreamerNVirtual",1656,G__smearDict_780_0_21, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - ClassDef_StreamerNVirtual_b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DeclFileName",1145,G__smearDict_780_0_22, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&Smear::RadialTracker::DeclFileName) ), 0);
   G__memfunc_setup("ImplFileLine",1178,G__smearDict_780_0_23, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&Smear::RadialTracker::ImplFileLine) ), 0);
   G__memfunc_setup("ImplFileName",1171,G__smearDict_780_0_24, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&Smear::RadialTracker::ImplFileName) ), 0);
   G__memfunc_setup("DeclFileLine",1152,G__smearDict_780_0_25, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&Smear::RadialTracker::DeclFileLine) ), 0);
   // automatic copy constructor
   G__memfunc_setup("RadialTracker", 1305, G__smearDict_780_0_26, (int) ('i'), G__get_linked_tagnum(&G__smearDictLN_SmearcLcLRadialTracker), -1, 0, 1, 1, 1, 0, "u 'Smear::RadialTracker' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~RadialTracker", 1431, G__smearDict_780_0_27, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__smearDict_780_0_28, (int) ('u'), G__get_linked_tagnum(&G__smearDictLN_SmearcLcLRadialTracker), -1, 1, 1, 1, 1, 0, "u 'Smear::RadialTracker' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}


/*********************************************************
* Member function information setup
*********************************************************/
extern "C" void G__cpp_setup_memfuncsmearDict() {
}

/*********************************************************
* Global variable information setup for each class
*********************************************************/
static void G__cpp_setup_global0() {

   /* Setting up global variables */
   G__resetplocal();

}

static void G__cpp_setup_global1() {
}

static void G__cpp_setup_global2() {
}

static void G__cpp_setup_global3() {
}

static void G__cpp_setup_global4() {
}

static void G__cpp_setup_global5() {

   G__resetglobalenv();
}
extern "C" void G__cpp_setup_globalsmearDict() {
  G__cpp_setup_global0();
  G__cpp_setup_global1();
  G__cpp_setup_global2();
  G__cpp_setup_global3();
  G__cpp_setup_global4();
  G__cpp_setup_global5();
}

/*********************************************************
* Global function information setup for each class
*********************************************************/
static void G__cpp_setup_func0() {
   G__lastifuncposition();

}

static void G__cpp_setup_func1() {
}

static void G__cpp_setup_func2() {
}

static void G__cpp_setup_func3() {
}

static void G__cpp_setup_func4() {
}

static void G__cpp_setup_func5() {
}

static void G__cpp_setup_func6() {
}

static void G__cpp_setup_func7() {
}

static void G__cpp_setup_func8() {
}

static void G__cpp_setup_func9() {
}

static void G__cpp_setup_func10() {
}

static void G__cpp_setup_func11() {
}

static void G__cpp_setup_func12() {
}

static void G__cpp_setup_func13() {
}

static void G__cpp_setup_func14() {
}

static void G__cpp_setup_func15() {
}

static void G__cpp_setup_func16() {
}

static void G__cpp_setup_func17() {
}

static void G__cpp_setup_func18() {
}

static void G__cpp_setup_func19() {
}

static void G__cpp_setup_func20() {
}

static void G__cpp_setup_func21() {
}

static void G__cpp_setup_func22() {
}

static void G__cpp_setup_func23() {
}

static void G__cpp_setup_func24() {
}

static void G__cpp_setup_func25() {
}

static void G__cpp_setup_func26() {
}

static void G__cpp_setup_func27() {
}

static void G__cpp_setup_func28() {
}

static void G__cpp_setup_func29() {
}

static void G__cpp_setup_func30() {
}

static void G__cpp_setup_func31() {
}

static void G__cpp_setup_func32() {
}

static void G__cpp_setup_func33() {
}

static void G__cpp_setup_func34() {
}

static void G__cpp_setup_func35() {
}

static void G__cpp_setup_func36() {
}

static void G__cpp_setup_func37() {
   G__memfunc_setup("SmearTree", 904, G__smearDict__0_3775, 105, -1, -1, 0, 4, 1, 1, 0, 
"u 'Smear::Detector' - 11 - - u 'TString' - 11 - inFileName "
"u 'TString' - 11 '\"\"' outFileName n - 'Long64_t' 0 '-1' nEvents", (char*) NULL
, (void*) NULL, 0);
}

static void G__cpp_setup_func38() {

   G__resetifuncposition();
}

extern "C" void G__cpp_setup_funcsmearDict() {
  G__cpp_setup_func0();
  G__cpp_setup_func1();
  G__cpp_setup_func2();
  G__cpp_setup_func3();
  G__cpp_setup_func4();
  G__cpp_setup_func5();
  G__cpp_setup_func6();
  G__cpp_setup_func7();
  G__cpp_setup_func8();
  G__cpp_setup_func9();
  G__cpp_setup_func10();
  G__cpp_setup_func11();
  G__cpp_setup_func12();
  G__cpp_setup_func13();
  G__cpp_setup_func14();
  G__cpp_setup_func15();
  G__cpp_setup_func16();
  G__cpp_setup_func17();
  G__cpp_setup_func18();
  G__cpp_setup_func19();
  G__cpp_setup_func20();
  G__cpp_setup_func21();
  G__cpp_setup_func22();
  G__cpp_setup_func23();
  G__cpp_setup_func24();
  G__cpp_setup_func25();
  G__cpp_setup_func26();
  G__cpp_setup_func27();
  G__cpp_setup_func28();
  G__cpp_setup_func29();
  G__cpp_setup_func30();
  G__cpp_setup_func31();
  G__cpp_setup_func32();
  G__cpp_setup_func33();
  G__cpp_setup_func34();
  G__cpp_setup_func35();
  G__cpp_setup_func36();
  G__cpp_setup_func37();
  G__cpp_setup_func38();
}

/*********************************************************
* Class,struct,union,enum tag information setup
*********************************************************/
/* Setup class/struct taginfo */
G__linked_taginfo G__smearDictLN_TClass = { "TClass" , 99 , -1 };
G__linked_taginfo G__smearDictLN_TBuffer = { "TBuffer" , 99 , -1 };
G__linked_taginfo G__smearDictLN_TMemberInspector = { "TMemberInspector" , 99 , -1 };
G__linked_taginfo G__smearDictLN_TObject = { "TObject" , 99 , -1 };
G__linked_taginfo G__smearDictLN_TString = { "TString" , 99 , -1 };
G__linked_taginfo G__smearDictLN_vectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgR = { "vector<unsigned int,allocator<unsigned int> >" , 99 , -1 };
G__linked_taginfo G__smearDictLN_vectorlEdoublecOallocatorlEdoublegRsPgR = { "vector<double,allocator<double> >" , 99 , -1 };
G__linked_taginfo G__smearDictLN_string = { "string" , 99 , -1 };
G__linked_taginfo G__smearDictLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR = { "vector<ROOT::TSchemaHelper,allocator<ROOT::TSchemaHelper> >" , 99 , -1 };
G__linked_taginfo G__smearDictLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR = { "reverse_iterator<vector<ROOT::TSchemaHelper,allocator<ROOT::TSchemaHelper> >::iterator>" , 99 , -1 };
G__linked_taginfo G__smearDictLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR = { "vector<TVirtualArray*,allocator<TVirtualArray*> >" , 99 , -1 };
G__linked_taginfo G__smearDictLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<TVirtualArray*,allocator<TVirtualArray*> >::iterator>" , 99 , -1 };
G__linked_taginfo G__smearDictLN_setlEintcOlesslEintgRcOallocatorlEintgRsPgR = { "set<int,less<int>,allocator<int> >" , 99 , -1 };
G__linked_taginfo G__smearDictLN_iteratorlEbidirectional_iterator_tagcOTObjectmUcOlongcOconstsPTObjectmUmUcOconstsPTObjectmUaNgR = { "iterator<bidirectional_iterator_tag,TObject*,long,const TObject**,const TObject*&>" , 115 , -1 };
G__linked_taginfo G__smearDictLN_TFormula = { "TFormula" , 99 , -1 };
G__linked_taginfo G__smearDictLN_TF1 = { "TF1" , 99 , -1 };
G__linked_taginfo G__smearDictLN_TMatrixTBaselEfloatgR = { "TMatrixTBase<float>" , 99 , -1 };
G__linked_taginfo G__smearDictLN_TMatrixTBaselEdoublegR = { "TMatrixTBase<double>" , 99 , -1 };
G__linked_taginfo G__smearDictLN_TVectorTlEfloatgR = { "TVectorT<float>" , 99 , -1 };
G__linked_taginfo G__smearDictLN_TVectorTlEdoublegR = { "TVectorT<double>" , 99 , -1 };
G__linked_taginfo G__smearDictLN_TElementActionTlEfloatgR = { "TElementActionT<float>" , 99 , -1 };
G__linked_taginfo G__smearDictLN_TElementPosActionTlEfloatgR = { "TElementPosActionT<float>" , 99 , -1 };
G__linked_taginfo G__smearDictLN_TMatrixTlEfloatgR = { "TMatrixT<float>" , 99 , -1 };
G__linked_taginfo G__smearDictLN_TMatrixTRow_constlEfloatgR = { "TMatrixTRow_const<float>" , 99 , -1 };
G__linked_taginfo G__smearDictLN_TMatrixTRowlEfloatgR = { "TMatrixTRow<float>" , 99 , -1 };
G__linked_taginfo G__smearDictLN_TMatrixTDiag_constlEfloatgR = { "TMatrixTDiag_const<float>" , 99 , -1 };
G__linked_taginfo G__smearDictLN_TMatrixTColumn_constlEfloatgR = { "TMatrixTColumn_const<float>" , 99 , -1 };
G__linked_taginfo G__smearDictLN_TMatrixTFlat_constlEfloatgR = { "TMatrixTFlat_const<float>" , 99 , -1 };
G__linked_taginfo G__smearDictLN_TMatrixTSub_constlEfloatgR = { "TMatrixTSub_const<float>" , 99 , -1 };
G__linked_taginfo G__smearDictLN_TMatrixTSparseRow_constlEfloatgR = { "TMatrixTSparseRow_const<float>" , 99 , -1 };
G__linked_taginfo G__smearDictLN_TMatrixTSparseDiag_constlEfloatgR = { "TMatrixTSparseDiag_const<float>" , 99 , -1 };
G__linked_taginfo G__smearDictLN_TMatrixTColumnlEfloatgR = { "TMatrixTColumn<float>" , 99 , -1 };
G__linked_taginfo G__smearDictLN_TMatrixTDiaglEfloatgR = { "TMatrixTDiag<float>" , 99 , -1 };
G__linked_taginfo G__smearDictLN_TMatrixTFlatlEfloatgR = { "TMatrixTFlat<float>" , 99 , -1 };
G__linked_taginfo G__smearDictLN_TMatrixTSublEfloatgR = { "TMatrixTSub<float>" , 99 , -1 };
G__linked_taginfo G__smearDictLN_TMatrixTSparseRowlEfloatgR = { "TMatrixTSparseRow<float>" , 99 , -1 };
G__linked_taginfo G__smearDictLN_TMatrixTSparseDiaglEfloatgR = { "TMatrixTSparseDiag<float>" , 99 , -1 };
G__linked_taginfo G__smearDictLN_TVector3 = { "TVector3" , 99 , -1 };
G__linked_taginfo G__smearDictLN_TLorentzVector = { "TLorentzVector" , 99 , -1 };
G__linked_taginfo G__smearDictLN_TRandom3 = { "TRandom3" , 99 , -1 };
G__linked_taginfo G__smearDictLN_vectorlETStringcOallocatorlETStringgRsPgR = { "vector<TString,allocator<TString> >" , 99 , -1 };
G__linked_taginfo G__smearDictLN_reverse_iteratorlEvectorlETStringcOallocatorlETStringgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<TString,allocator<TString> >::iterator>" , 99 , -1 };
G__linked_taginfo G__smearDictLN_erhic = { "erhic" , 110 , -1 };
G__linked_taginfo G__smearDictLN_erhiccLcLPid = { "erhic::Pid" , 99 , -1 };
G__linked_taginfo G__smearDictLN_erhiccLcLVirtualParticle = { "erhic::VirtualParticle" , 99 , -1 };
G__linked_taginfo G__smearDictLN_erhiccLcLParticleMC = { "erhic::ParticleMC" , 99 , -1 };
G__linked_taginfo G__smearDictLN_erhiccLcLVirtualEvent = { "erhic::VirtualEvent" , 99 , -1 };
G__linked_taginfo G__smearDictLN_vectorlEconstsPerhiccLcLVirtualParticlemUcOallocatorlEconstsPerhiccLcLVirtualParticlemUgRsPgR = { "vector<const erhic::VirtualParticle*,allocator<const erhic::VirtualParticle*> >" , 99 , -1 };
G__linked_taginfo G__smearDictLN_reverse_iteratorlEvectorlEconstsPerhiccLcLVirtualParticlemUcOallocatorlEconstsPerhiccLcLVirtualParticlemUgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<const erhic::VirtualParticle*,allocator<const erhic::VirtualParticle*> >::iterator>" , 99 , -1 };
G__linked_taginfo G__smearDictLN_erhiccLcLEventDis = { "erhic::EventDis" , 99 , -1 };
G__linked_taginfo G__smearDictLN_Smear = { "Smear" , 110 , -1 };
G__linked_taginfo G__smearDictLN_SmearcLcLEvent = { "Smear::Event" , 99 , -1 };
G__linked_taginfo G__smearDictLN_SmearcLcLParticleMCS = { "Smear::ParticleMCS" , 99 , -1 };
G__linked_taginfo G__smearDictLN_SmearcLcLKinType = { "Smear::KinType" , 101 , -1 };
G__linked_taginfo G__smearDictLN_SmearcLcLEGenre = { "Smear::EGenre" , 101 , -1 };
G__linked_taginfo G__smearDictLN_SmearcLcLECharge = { "Smear::ECharge" , 101 , -1 };
G__linked_taginfo G__smearDictLN_SmearcLcLAcceptance = { "Smear::Acceptance" , 99 , -1 };
G__linked_taginfo G__smearDictLN_SmearcLcLAcceptancecLcLCustomCut = { "Smear::Acceptance::CustomCut" , 99 , -1 };
G__linked_taginfo G__smearDictLN_SmearcLcLAcceptancecLcLZone = { "Smear::Acceptance::Zone" , 99 , -1 };
G__linked_taginfo G__smearDictLN_vectorlESmearcLcLAcceptancecLcLCustomCutcOallocatorlESmearcLcLAcceptancecLcLCustomCutgRsPgR = { "vector<Smear::Acceptance::CustomCut,allocator<Smear::Acceptance::CustomCut> >" , 99 , -1 };
G__linked_taginfo G__smearDictLN_reverse_iteratorlEvectorlESmearcLcLAcceptancecLcLCustomCutcOallocatorlESmearcLcLAcceptancecLcLCustomCutgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<Smear::Acceptance::CustomCut,allocator<Smear::Acceptance::CustomCut> >::iterator>" , 99 , -1 };
G__linked_taginfo G__smearDictLN_vectorlESmearcLcLAcceptancecLcLZonecOallocatorlESmearcLcLAcceptancecLcLZonegRsPgR = { "vector<Smear::Acceptance::Zone,allocator<Smear::Acceptance::Zone> >" , 99 , -1 };
G__linked_taginfo G__smearDictLN_reverse_iteratorlEvectorlESmearcLcLAcceptancecLcLZonecOallocatorlESmearcLcLAcceptancecLcLZonegRsPgRcLcLiteratorgR = { "reverse_iterator<vector<Smear::Acceptance::Zone,allocator<Smear::Acceptance::Zone> >::iterator>" , 99 , -1 };
G__linked_taginfo G__smearDictLN_SmearcLcLDistributor = { "Smear::Distributor" , 99 , -1 };
G__linked_taginfo G__smearDictLN_SmearcLcLSmearer = { "Smear::Smearer" , 99 , -1 };
G__linked_taginfo G__smearDictLN_SmearcLcLFormulaString = { "Smear::FormulaString" , 99 , -1 };
G__linked_taginfo G__smearDictLN_SmearcLcLDevice = { "Smear::Device" , 99 , -1 };
G__linked_taginfo G__smearDictLN_vectorlESmearcLcLKinTypecOallocatorlESmearcLcLKinTypegRsPgR = { "vector<Smear::KinType,allocator<Smear::KinType> >" , 99 , -1 };
G__linked_taginfo G__smearDictLN_vectorlESmearcLcLKinTypecOallocatorlESmearcLcLKinTypegRsPgRcLcLiterator = { "vector<Smear::KinType,allocator<Smear::KinType> >::iterator" , 99 , -1 };
G__linked_taginfo G__smearDictLN_reverse_iteratorlEvectorlESmearcLcLKinTypecOallocatorlESmearcLcLKinTypegRsPgRcLcLiteratorgR = { "reverse_iterator<vector<Smear::KinType,allocator<Smear::KinType> >::iterator>" , 99 , -1 };
G__linked_taginfo G__smearDictLN_SmearcLcLBremsstrahlung = { "Smear::Bremsstrahlung" , 115 , -1 };
G__linked_taginfo G__smearDictLN_auto_ptrlEerhiccLcLParticleMCgR = { "auto_ptr<erhic::ParticleMC>" , 99 , -1 };
G__linked_taginfo G__smearDictLN_SmearcLcLDetector = { "Smear::Detector" , 99 , -1 };
G__linked_taginfo G__smearDictLN_listlESmearcLcLSmearermUcOallocatorlESmearcLcLSmearermUgRsPgR = { "list<Smear::Smearer*,allocator<Smear::Smearer*> >" , 99 , -1 };
G__linked_taginfo G__smearDictLN_vectorlESmearcLcLSmearermUcOallocatorlESmearcLcLSmearermUgRsPgR = { "vector<Smear::Smearer*,allocator<Smear::Smearer*> >" , 99 , -1 };
G__linked_taginfo G__smearDictLN_reverse_iteratorlEvectorlESmearcLcLSmearermUcOallocatorlESmearcLcLSmearermUgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<Smear::Smearer*,allocator<Smear::Smearer*> >::iterator>" , 99 , -1 };
G__linked_taginfo G__smearDictLN_vectorlESmearcLcLParticleMCSmUcOallocatorlESmearcLcLParticleMCSmUgRsPgR = { "vector<Smear::ParticleMCS*,allocator<Smear::ParticleMCS*> >" , 99 , -1 };
G__linked_taginfo G__smearDictLN_reverse_iteratorlEvectorlESmearcLcLParticleMCSmUcOallocatorlESmearcLcLParticleMCSmUgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<Smear::ParticleMCS*,allocator<Smear::ParticleMCS*> >::iterator>" , 99 , -1 };
G__linked_taginfo G__smearDictLN_maplEstringcOTObjArraymUcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOTObjArraymUgRsPgRsPgR = { "map<string,TObjArray*,less<string>,allocator<pair<const string,TObjArray*> > >" , 99 , -1 };
G__linked_taginfo G__smearDictLN_SmearcLcLParticleID = { "Smear::ParticleID" , 115 , -1 };
G__linked_taginfo G__smearDictLN_vectorlEintcOallocatorlEintgRsPgR = { "vector<int,allocator<int> >" , 99 , -1 };
G__linked_taginfo G__smearDictLN_vectorlEintcOallocatorlEintgRsPgRcLcLiterator = { "vector<int,allocator<int> >::iterator" , 99 , -1 };
G__linked_taginfo G__smearDictLN_reverse_iteratorlEvectorlEintcOallocatorlEintgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<int,allocator<int> >::iterator>" , 99 , -1 };
G__linked_taginfo G__smearDictLN_vectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgR = { "vector<vector<double,allocator<double> >,allocator<vector<double,allocator<double> > > >" , 99 , -1 };
G__linked_taginfo G__smearDictLN_reverse_iteratorlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<vector<double,allocator<double> >,allocator<vector<double,allocator<double> > > >::iterator>" , 99 , -1 };
G__linked_taginfo G__smearDictLN_vectorlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRcOallocatorlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRsPgRsPgR = { "vector<vector<vector<double,allocator<double> >,allocator<vector<double,allocator<double> > > >,allocator<vector<vector<double,allocator<double> >,allocator<vector<double,allocator<double> > > > > >" , 99 , -1 };
G__linked_taginfo G__smearDictLN_reverse_iteratorlEvectorlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRcOallocatorlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRsPgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<vector<vector<double,allocator<double> >,allocator<vector<double,allocator<double> > > >,allocator<vector<vector<double,allocator<double> >,allocator<vector<double,allocator<double> > > > > >::iterator>" , 99 , -1 };
G__linked_taginfo G__smearDictLN_SmearcLcLPerfectID = { "Smear::PerfectID" , 99 , -1 };
G__linked_taginfo G__smearDictLN_SmearcLcLTracker = { "Smear::Tracker" , 99 , -1 };
G__linked_taginfo G__smearDictLN_SmearcLcLPlanarTracker = { "Smear::PlanarTracker" , 99 , -1 };
G__linked_taginfo G__smearDictLN_SmearcLcLRadialTracker = { "Smear::RadialTracker" , 99 , -1 };

/* Reset class/struct taginfo */
extern "C" void G__cpp_reset_tagtablesmearDict() {
  G__smearDictLN_TClass.tagnum = -1 ;
  G__smearDictLN_TBuffer.tagnum = -1 ;
  G__smearDictLN_TMemberInspector.tagnum = -1 ;
  G__smearDictLN_TObject.tagnum = -1 ;
  G__smearDictLN_TString.tagnum = -1 ;
  G__smearDictLN_vectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgR.tagnum = -1 ;
  G__smearDictLN_vectorlEdoublecOallocatorlEdoublegRsPgR.tagnum = -1 ;
  G__smearDictLN_string.tagnum = -1 ;
  G__smearDictLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR.tagnum = -1 ;
  G__smearDictLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__smearDictLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR.tagnum = -1 ;
  G__smearDictLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__smearDictLN_setlEintcOlesslEintgRcOallocatorlEintgRsPgR.tagnum = -1 ;
  G__smearDictLN_iteratorlEbidirectional_iterator_tagcOTObjectmUcOlongcOconstsPTObjectmUmUcOconstsPTObjectmUaNgR.tagnum = -1 ;
  G__smearDictLN_TFormula.tagnum = -1 ;
  G__smearDictLN_TF1.tagnum = -1 ;
  G__smearDictLN_TMatrixTBaselEfloatgR.tagnum = -1 ;
  G__smearDictLN_TMatrixTBaselEdoublegR.tagnum = -1 ;
  G__smearDictLN_TVectorTlEfloatgR.tagnum = -1 ;
  G__smearDictLN_TVectorTlEdoublegR.tagnum = -1 ;
  G__smearDictLN_TElementActionTlEfloatgR.tagnum = -1 ;
  G__smearDictLN_TElementPosActionTlEfloatgR.tagnum = -1 ;
  G__smearDictLN_TMatrixTlEfloatgR.tagnum = -1 ;
  G__smearDictLN_TMatrixTRow_constlEfloatgR.tagnum = -1 ;
  G__smearDictLN_TMatrixTRowlEfloatgR.tagnum = -1 ;
  G__smearDictLN_TMatrixTDiag_constlEfloatgR.tagnum = -1 ;
  G__smearDictLN_TMatrixTColumn_constlEfloatgR.tagnum = -1 ;
  G__smearDictLN_TMatrixTFlat_constlEfloatgR.tagnum = -1 ;
  G__smearDictLN_TMatrixTSub_constlEfloatgR.tagnum = -1 ;
  G__smearDictLN_TMatrixTSparseRow_constlEfloatgR.tagnum = -1 ;
  G__smearDictLN_TMatrixTSparseDiag_constlEfloatgR.tagnum = -1 ;
  G__smearDictLN_TMatrixTColumnlEfloatgR.tagnum = -1 ;
  G__smearDictLN_TMatrixTDiaglEfloatgR.tagnum = -1 ;
  G__smearDictLN_TMatrixTFlatlEfloatgR.tagnum = -1 ;
  G__smearDictLN_TMatrixTSublEfloatgR.tagnum = -1 ;
  G__smearDictLN_TMatrixTSparseRowlEfloatgR.tagnum = -1 ;
  G__smearDictLN_TMatrixTSparseDiaglEfloatgR.tagnum = -1 ;
  G__smearDictLN_TVector3.tagnum = -1 ;
  G__smearDictLN_TLorentzVector.tagnum = -1 ;
  G__smearDictLN_TRandom3.tagnum = -1 ;
  G__smearDictLN_vectorlETStringcOallocatorlETStringgRsPgR.tagnum = -1 ;
  G__smearDictLN_reverse_iteratorlEvectorlETStringcOallocatorlETStringgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__smearDictLN_erhic.tagnum = -1 ;
  G__smearDictLN_erhiccLcLPid.tagnum = -1 ;
  G__smearDictLN_erhiccLcLVirtualParticle.tagnum = -1 ;
  G__smearDictLN_erhiccLcLParticleMC.tagnum = -1 ;
  G__smearDictLN_erhiccLcLVirtualEvent.tagnum = -1 ;
  G__smearDictLN_vectorlEconstsPerhiccLcLVirtualParticlemUcOallocatorlEconstsPerhiccLcLVirtualParticlemUgRsPgR.tagnum = -1 ;
  G__smearDictLN_reverse_iteratorlEvectorlEconstsPerhiccLcLVirtualParticlemUcOallocatorlEconstsPerhiccLcLVirtualParticlemUgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__smearDictLN_erhiccLcLEventDis.tagnum = -1 ;
  G__smearDictLN_Smear.tagnum = -1 ;
  G__smearDictLN_SmearcLcLEvent.tagnum = -1 ;
  G__smearDictLN_SmearcLcLParticleMCS.tagnum = -1 ;
  G__smearDictLN_SmearcLcLKinType.tagnum = -1 ;
  G__smearDictLN_SmearcLcLEGenre.tagnum = -1 ;
  G__smearDictLN_SmearcLcLECharge.tagnum = -1 ;
  G__smearDictLN_SmearcLcLAcceptance.tagnum = -1 ;
  G__smearDictLN_SmearcLcLAcceptancecLcLCustomCut.tagnum = -1 ;
  G__smearDictLN_SmearcLcLAcceptancecLcLZone.tagnum = -1 ;
  G__smearDictLN_vectorlESmearcLcLAcceptancecLcLCustomCutcOallocatorlESmearcLcLAcceptancecLcLCustomCutgRsPgR.tagnum = -1 ;
  G__smearDictLN_reverse_iteratorlEvectorlESmearcLcLAcceptancecLcLCustomCutcOallocatorlESmearcLcLAcceptancecLcLCustomCutgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__smearDictLN_vectorlESmearcLcLAcceptancecLcLZonecOallocatorlESmearcLcLAcceptancecLcLZonegRsPgR.tagnum = -1 ;
  G__smearDictLN_reverse_iteratorlEvectorlESmearcLcLAcceptancecLcLZonecOallocatorlESmearcLcLAcceptancecLcLZonegRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__smearDictLN_SmearcLcLDistributor.tagnum = -1 ;
  G__smearDictLN_SmearcLcLSmearer.tagnum = -1 ;
  G__smearDictLN_SmearcLcLFormulaString.tagnum = -1 ;
  G__smearDictLN_SmearcLcLDevice.tagnum = -1 ;
  G__smearDictLN_vectorlESmearcLcLKinTypecOallocatorlESmearcLcLKinTypegRsPgR.tagnum = -1 ;
  G__smearDictLN_vectorlESmearcLcLKinTypecOallocatorlESmearcLcLKinTypegRsPgRcLcLiterator.tagnum = -1 ;
  G__smearDictLN_reverse_iteratorlEvectorlESmearcLcLKinTypecOallocatorlESmearcLcLKinTypegRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__smearDictLN_SmearcLcLBremsstrahlung.tagnum = -1 ;
  G__smearDictLN_auto_ptrlEerhiccLcLParticleMCgR.tagnum = -1 ;
  G__smearDictLN_SmearcLcLDetector.tagnum = -1 ;
  G__smearDictLN_listlESmearcLcLSmearermUcOallocatorlESmearcLcLSmearermUgRsPgR.tagnum = -1 ;
  G__smearDictLN_vectorlESmearcLcLSmearermUcOallocatorlESmearcLcLSmearermUgRsPgR.tagnum = -1 ;
  G__smearDictLN_reverse_iteratorlEvectorlESmearcLcLSmearermUcOallocatorlESmearcLcLSmearermUgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__smearDictLN_vectorlESmearcLcLParticleMCSmUcOallocatorlESmearcLcLParticleMCSmUgRsPgR.tagnum = -1 ;
  G__smearDictLN_reverse_iteratorlEvectorlESmearcLcLParticleMCSmUcOallocatorlESmearcLcLParticleMCSmUgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__smearDictLN_maplEstringcOTObjArraymUcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOTObjArraymUgRsPgRsPgR.tagnum = -1 ;
  G__smearDictLN_SmearcLcLParticleID.tagnum = -1 ;
  G__smearDictLN_vectorlEintcOallocatorlEintgRsPgR.tagnum = -1 ;
  G__smearDictLN_vectorlEintcOallocatorlEintgRsPgRcLcLiterator.tagnum = -1 ;
  G__smearDictLN_reverse_iteratorlEvectorlEintcOallocatorlEintgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__smearDictLN_vectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgR.tagnum = -1 ;
  G__smearDictLN_reverse_iteratorlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__smearDictLN_vectorlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRcOallocatorlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRsPgRsPgR.tagnum = -1 ;
  G__smearDictLN_reverse_iteratorlEvectorlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRcOallocatorlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRsPgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__smearDictLN_SmearcLcLPerfectID.tagnum = -1 ;
  G__smearDictLN_SmearcLcLTracker.tagnum = -1 ;
  G__smearDictLN_SmearcLcLPlanarTracker.tagnum = -1 ;
  G__smearDictLN_SmearcLcLRadialTracker.tagnum = -1 ;
}


extern "C" void G__cpp_setup_tagtablesmearDict() {

   /* Setting up class,struct,union tag entry */
   G__get_linked_tagnum_fwd(&G__smearDictLN_TClass);
   G__get_linked_tagnum_fwd(&G__smearDictLN_TBuffer);
   G__get_linked_tagnum_fwd(&G__smearDictLN_TMemberInspector);
   G__get_linked_tagnum_fwd(&G__smearDictLN_TObject);
   G__get_linked_tagnum_fwd(&G__smearDictLN_TString);
   G__get_linked_tagnum_fwd(&G__smearDictLN_vectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgR);
   G__get_linked_tagnum_fwd(&G__smearDictLN_vectorlEdoublecOallocatorlEdoublegRsPgR);
   G__get_linked_tagnum_fwd(&G__smearDictLN_string);
   G__get_linked_tagnum_fwd(&G__smearDictLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR);
   G__get_linked_tagnum_fwd(&G__smearDictLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__smearDictLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR);
   G__get_linked_tagnum_fwd(&G__smearDictLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__smearDictLN_setlEintcOlesslEintgRcOallocatorlEintgRsPgR);
   G__get_linked_tagnum_fwd(&G__smearDictLN_iteratorlEbidirectional_iterator_tagcOTObjectmUcOlongcOconstsPTObjectmUmUcOconstsPTObjectmUaNgR);
   G__get_linked_tagnum_fwd(&G__smearDictLN_TFormula);
   G__get_linked_tagnum_fwd(&G__smearDictLN_TF1);
   G__get_linked_tagnum_fwd(&G__smearDictLN_TMatrixTBaselEfloatgR);
   G__get_linked_tagnum_fwd(&G__smearDictLN_TMatrixTBaselEdoublegR);
   G__get_linked_tagnum_fwd(&G__smearDictLN_TVectorTlEfloatgR);
   G__get_linked_tagnum_fwd(&G__smearDictLN_TVectorTlEdoublegR);
   G__get_linked_tagnum_fwd(&G__smearDictLN_TElementActionTlEfloatgR);
   G__get_linked_tagnum_fwd(&G__smearDictLN_TElementPosActionTlEfloatgR);
   G__get_linked_tagnum_fwd(&G__smearDictLN_TMatrixTlEfloatgR);
   G__get_linked_tagnum_fwd(&G__smearDictLN_TMatrixTRow_constlEfloatgR);
   G__get_linked_tagnum_fwd(&G__smearDictLN_TMatrixTRowlEfloatgR);
   G__get_linked_tagnum_fwd(&G__smearDictLN_TMatrixTDiag_constlEfloatgR);
   G__get_linked_tagnum_fwd(&G__smearDictLN_TMatrixTColumn_constlEfloatgR);
   G__get_linked_tagnum_fwd(&G__smearDictLN_TMatrixTFlat_constlEfloatgR);
   G__get_linked_tagnum_fwd(&G__smearDictLN_TMatrixTSub_constlEfloatgR);
   G__get_linked_tagnum_fwd(&G__smearDictLN_TMatrixTSparseRow_constlEfloatgR);
   G__get_linked_tagnum_fwd(&G__smearDictLN_TMatrixTSparseDiag_constlEfloatgR);
   G__get_linked_tagnum_fwd(&G__smearDictLN_TMatrixTColumnlEfloatgR);
   G__get_linked_tagnum_fwd(&G__smearDictLN_TMatrixTDiaglEfloatgR);
   G__get_linked_tagnum_fwd(&G__smearDictLN_TMatrixTFlatlEfloatgR);
   G__get_linked_tagnum_fwd(&G__smearDictLN_TMatrixTSublEfloatgR);
   G__get_linked_tagnum_fwd(&G__smearDictLN_TMatrixTSparseRowlEfloatgR);
   G__get_linked_tagnum_fwd(&G__smearDictLN_TMatrixTSparseDiaglEfloatgR);
   G__get_linked_tagnum_fwd(&G__smearDictLN_TVector3);
   G__get_linked_tagnum_fwd(&G__smearDictLN_TLorentzVector);
   G__get_linked_tagnum_fwd(&G__smearDictLN_TRandom3);
   G__get_linked_tagnum_fwd(&G__smearDictLN_vectorlETStringcOallocatorlETStringgRsPgR);
   G__get_linked_tagnum_fwd(&G__smearDictLN_reverse_iteratorlEvectorlETStringcOallocatorlETStringgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__smearDictLN_erhic);
   G__get_linked_tagnum_fwd(&G__smearDictLN_erhiccLcLPid);
   G__get_linked_tagnum_fwd(&G__smearDictLN_erhiccLcLVirtualParticle);
   G__get_linked_tagnum_fwd(&G__smearDictLN_erhiccLcLParticleMC);
   G__get_linked_tagnum_fwd(&G__smearDictLN_erhiccLcLVirtualEvent);
   G__get_linked_tagnum_fwd(&G__smearDictLN_vectorlEconstsPerhiccLcLVirtualParticlemUcOallocatorlEconstsPerhiccLcLVirtualParticlemUgRsPgR);
   G__get_linked_tagnum_fwd(&G__smearDictLN_reverse_iteratorlEvectorlEconstsPerhiccLcLVirtualParticlemUcOallocatorlEconstsPerhiccLcLVirtualParticlemUgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__smearDictLN_erhiccLcLEventDis);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__smearDictLN_Smear),0,-1,0,(char*)NULL,G__setup_memvarSmear,G__setup_memfuncSmear);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__smearDictLN_SmearcLcLEvent),sizeof(Smear::Event),-1,29952,(char*)NULL,G__setup_memvarSmearcLcLEvent,G__setup_memfuncSmearcLcLEvent);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__smearDictLN_SmearcLcLParticleMCS),sizeof(Smear::ParticleMCS),-1,62720,(char*)NULL,G__setup_memvarSmearcLcLParticleMCS,G__setup_memfuncSmearcLcLParticleMCS);
   G__get_linked_tagnum_fwd(&G__smearDictLN_SmearcLcLKinType);
   G__get_linked_tagnum_fwd(&G__smearDictLN_SmearcLcLEGenre);
   G__get_linked_tagnum_fwd(&G__smearDictLN_SmearcLcLECharge);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__smearDictLN_SmearcLcLAcceptance),sizeof(Smear::Acceptance),-1,263424,(char*)NULL,G__setup_memvarSmearcLcLAcceptance,G__setup_memfuncSmearcLcLAcceptance);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__smearDictLN_SmearcLcLAcceptancecLcLCustomCut),sizeof(Smear::Acceptance::CustomCut),-1,296192,(char*)NULL,G__setup_memvarSmearcLcLAcceptancecLcLCustomCut,G__setup_memfuncSmearcLcLAcceptancecLcLCustomCut);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__smearDictLN_SmearcLcLAcceptancecLcLZone),sizeof(Smear::Acceptance::Zone),-1,263424,(char*)NULL,G__setup_memvarSmearcLcLAcceptancecLcLZone,G__setup_memfuncSmearcLcLAcceptancecLcLZone);
   G__get_linked_tagnum_fwd(&G__smearDictLN_vectorlESmearcLcLAcceptancecLcLCustomCutcOallocatorlESmearcLcLAcceptancecLcLCustomCutgRsPgR);
   G__get_linked_tagnum_fwd(&G__smearDictLN_reverse_iteratorlEvectorlESmearcLcLAcceptancecLcLCustomCutcOallocatorlESmearcLcLAcceptancecLcLCustomCutgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__smearDictLN_vectorlESmearcLcLAcceptancecLcLZonecOallocatorlESmearcLcLAcceptancecLcLZonegRsPgR);
   G__get_linked_tagnum_fwd(&G__smearDictLN_reverse_iteratorlEvectorlESmearcLcLAcceptancecLcLZonecOallocatorlESmearcLcLAcceptancecLcLZonegRsPgRcLcLiteratorgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__smearDictLN_SmearcLcLDistributor),sizeof(Smear::Distributor),-1,296192,(char*)NULL,G__setup_memvarSmearcLcLDistributor,G__setup_memfuncSmearcLcLDistributor);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__smearDictLN_SmearcLcLSmearer),sizeof(Smear::Smearer),-1,291842,(char*)NULL,G__setup_memvarSmearcLcLSmearer,G__setup_memfuncSmearcLcLSmearer);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__smearDictLN_SmearcLcLFormulaString),sizeof(Smear::FormulaString),-1,324864,(char*)NULL,G__setup_memvarSmearcLcLFormulaString,G__setup_memfuncSmearcLcLFormulaString);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__smearDictLN_SmearcLcLDevice),sizeof(Smear::Device),-1,327424,(char*)NULL,G__setup_memvarSmearcLcLDevice,G__setup_memfuncSmearcLcLDevice);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__smearDictLN_vectorlESmearcLcLKinTypecOallocatorlESmearcLcLKinTypegRsPgR),sizeof(vector<Smear::KinType,allocator<Smear::KinType> >),-1,36608,(char*)NULL,G__setup_memvarvectorlESmearcLcLKinTypecOallocatorlESmearcLcLKinTypegRsPgR,G__setup_memfuncvectorlESmearcLcLKinTypecOallocatorlESmearcLcLKinTypegRsPgR);
   G__get_linked_tagnum_fwd(&G__smearDictLN_vectorlESmearcLcLKinTypecOallocatorlESmearcLcLKinTypegRsPgRcLcLiterator);
   G__get_linked_tagnum_fwd(&G__smearDictLN_reverse_iteratorlEvectorlESmearcLcLKinTypecOallocatorlESmearcLcLKinTypegRsPgRcLcLiteratorgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__smearDictLN_SmearcLcLBremsstrahlung),sizeof(Smear::Bremsstrahlung),-1,324352,(char*)NULL,G__setup_memvarSmearcLcLBremsstrahlung,G__setup_memfuncSmearcLcLBremsstrahlung);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__smearDictLN_auto_ptrlEerhiccLcLParticleMCgR),sizeof(auto_ptr<erhic::ParticleMC>),-1,3840,(char*)NULL,G__setup_memvarauto_ptrlEerhiccLcLParticleMCgR,G__setup_memfuncauto_ptrlEerhiccLcLParticleMCgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__smearDictLN_SmearcLcLDetector),sizeof(Smear::Detector),-1,294656,(char*)NULL,G__setup_memvarSmearcLcLDetector,G__setup_memfuncSmearcLcLDetector);
   G__get_linked_tagnum_fwd(&G__smearDictLN_listlESmearcLcLSmearermUcOallocatorlESmearcLcLSmearermUgRsPgR);
   G__get_linked_tagnum_fwd(&G__smearDictLN_vectorlESmearcLcLSmearermUcOallocatorlESmearcLcLSmearermUgRsPgR);
   G__get_linked_tagnum_fwd(&G__smearDictLN_reverse_iteratorlEvectorlESmearcLcLSmearermUcOallocatorlESmearcLcLSmearermUgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__smearDictLN_vectorlESmearcLcLParticleMCSmUcOallocatorlESmearcLcLParticleMCSmUgRsPgR);
   G__get_linked_tagnum_fwd(&G__smearDictLN_reverse_iteratorlEvectorlESmearcLcLParticleMCSmUcOallocatorlESmearcLcLParticleMCSmUgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__smearDictLN_maplEstringcOTObjArraymUcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOTObjArraymUgRsPgRsPgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__smearDictLN_SmearcLcLParticleID),sizeof(Smear::ParticleID),-1,324864,(char*)NULL,G__setup_memvarSmearcLcLParticleID,G__setup_memfuncSmearcLcLParticleID);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__smearDictLN_vectorlEintcOallocatorlEintgRsPgR),sizeof(vector<int,allocator<int> >),-1,36608,(char*)NULL,G__setup_memvarvectorlEintcOallocatorlEintgRsPgR,G__setup_memfuncvectorlEintcOallocatorlEintgRsPgR);
   G__get_linked_tagnum_fwd(&G__smearDictLN_vectorlEintcOallocatorlEintgRsPgRcLcLiterator);
   G__get_linked_tagnum_fwd(&G__smearDictLN_reverse_iteratorlEvectorlEintcOallocatorlEintgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__smearDictLN_vectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgR);
   G__get_linked_tagnum_fwd(&G__smearDictLN_reverse_iteratorlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__smearDictLN_vectorlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRcOallocatorlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRsPgRsPgR);
   G__get_linked_tagnum_fwd(&G__smearDictLN_reverse_iteratorlEvectorlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRcOallocatorlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRsPgRsPgRcLcLiteratorgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__smearDictLN_SmearcLcLPerfectID),sizeof(Smear::PerfectID),-1,292096,(char*)NULL,G__setup_memvarSmearcLcLPerfectID,G__setup_memfuncSmearcLcLPerfectID);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__smearDictLN_SmearcLcLTracker),sizeof(Smear::Tracker),-1,292103,(char*)NULL,G__setup_memvarSmearcLcLTracker,G__setup_memfuncSmearcLcLTracker);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__smearDictLN_SmearcLcLPlanarTracker),sizeof(Smear::PlanarTracker),-1,324864,(char*)NULL,G__setup_memvarSmearcLcLPlanarTracker,G__setup_memfuncSmearcLcLPlanarTracker);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__smearDictLN_SmearcLcLRadialTracker),sizeof(Smear::RadialTracker),-1,324864,(char*)NULL,G__setup_memvarSmearcLcLRadialTracker,G__setup_memfuncSmearcLcLRadialTracker);
}
extern "C" void G__cpp_setupsmearDict(void) {
  G__check_setup_version(30051515,"G__cpp_setupsmearDict()");
  G__set_cpp_environmentsmearDict();
  G__cpp_setup_tagtablesmearDict();

  G__cpp_setup_inheritancesmearDict();

  G__cpp_setup_typetablesmearDict();

  G__cpp_setup_memvarsmearDict();

  G__cpp_setup_memfuncsmearDict();
  G__cpp_setup_globalsmearDict();
  G__cpp_setup_funcsmearDict();

   if(0==G__getsizep2memfunc()) G__get_sizep2memfuncsmearDict();
  return;
}
class G__cpp_setup_initsmearDict {
  public:
    G__cpp_setup_initsmearDict() { G__add_setup_func("smearDict",(G__incsetup)(&G__cpp_setupsmearDict)); G__call_setup_funcs(); }
   ~G__cpp_setup_initsmearDict() { G__remove_setup_func("smearDict"); }
};
G__cpp_setup_initsmearDict G__cpp_setup_initializersmearDict;

